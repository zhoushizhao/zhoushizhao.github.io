var tipuesearch = {"pages":[{"title":"Hello World","url":"/2022/03/21/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":""},{"title":"基因结构注释（4）：整合预测结果","url":"/2020/11/26/2020-11-26-annotion(4)/","text":"参考链接如何对基因组进行注释 从头预测，同源注释和转录组整合都会得到一个预测结果，相当于收集了大量证据，下一步就是通过这些证据定义出更加可靠的基因结构，这一步可以通过人工排查，也可以使用EVidenceModeler(EVM). EVM对gene_prediction.gff3有特殊的要求，就是GFF文件需要反映出一个基因的结构，gene-&gt;(mRNA -&gt; (exon-&gt;cds(?))(+))(+), 表示一个基因可以有多个mRNA，即基因的可变剪接, 一个mRNA都可以由一个或者多个exon(外显子), 外显子可以是非翻译区(UTR),也可以是编码区(CDS). 而GlimmerHMM, SNAP等 这三类根据人为经验来确定其可信度，从直觉上就是用PASA根据mRNA得到的结果高于从头预测。 软件下载： 12wget -4 https://github.com/EVidenceModeler/EVidenceModeler/archive/v1.1.1.tar.gztar xf v1.1.1.tar.gz 权重文件创建首先将EVM文件夹下的simple_example/weights.txt复制到自己的目录 第一列是来源类型(ABINITIO_PREDICTION, PROTEIN, TRANSCRIPT), 第二列对应着GFF3文件的第二列，第三列则是权重. 根据需要修改成自己的,用制表符分割 EVM运行准备好权重文件后，可以运行EVM了 1234567cat augustus.gff genemark.gff &gt; denovo.gffevidence_modeler.pl --genome genome.fa --weights weights.txt \\ --gene_predictions denovo.gff \\ --protein_alignments proteinprediction.gff \\ --transcript_alignments \\ transcripts.fasta.transdecoder.genome.gff3 \\ &gt;evm.out 最后生成的文件为evm.out,转为gff3格式 并行EVM主要是为了让整合结果更快一点 分割原始数据, 用于后续并行. 123456EvmUtils/partition_EVM_inputs.pl --genome genome.fa \\ --gene_predictions denovo.gff3 \\ --protein_alignments proteinprediction.gff \\ --transcript_alignments transcripts.fasta.transdecoder.genome.gff3 \\ --segmentSize 100000 --overlapSize 10000 \\ --partition_listing partitions_list.out 创建并行运算命令并执行 1234567EvmUtils/write_EVM_commands.pl --genome genome.fa --weights `pwd`/weights.txt \\ --gene_predictions denovo.gff3 \\ --protein_alignments proteinprediction.gff \\ --transcript_alignments transcripts.fasta.transdecoder.genome.gff3 \\ --output_file_name evm.out \\ --partitions partitions_list.out &gt; commands.listparallel --jobs 10 &lt; commands.list 合并运行结果 12EvmUtils/recombine_EVM_partial_outputs.pl --partitions partitions_list.out \\ --output_file_name evm.out 结果转成gff3 123EvmUtils/convert_EVM_outputs_to_GFF3.pl --partitions partitions_list.out --output evm.out --genome genome.fafind . -regex &quot;.*evm.out.gff3&quot; -exec cat &#123;&#125; \\; | bedtools sort -i - &gt; EVM.all.gff 基因过滤与命名注释过滤：对于初步预测得到的基因，还可以稍微优化一下，例如剔除编码少于50个AA的预测结果，将转座子单独放到一个文件中 123gffread EVM.all.gff -g input/genome.fa -y tr_cds.fabioawk -c fastx &#x27;$seq &lt; 50 &#123;print $comment&#125;&#x27; tr_cds.fa | cut -d &#x27;=&#x27; -f 2 &gt; short_aa_gene_list.txtgrep -v -w -f short_aa_gene_list.txt EvM.all.gff &gt; filter.gff 可以看到这个顺序还是不对，需要再排序，gene-&gt;mRNA-&gt;exon-&gt;CDS 1234567891011121314151617181920212223242526272829303132333435363738vi sort_EVM.pyimport sysimport refout = open(sys.argv[3],&#x27;w&#x27;)ref_dict=&#123;&#125;with open(sys.argv[1]) as gene_a: for line in gene_a: line_s = line.strip().split(&#x27;\\t&#x27;) info = re.split(&#x27;=|;&#x27;,line_s[8]) ID = info[1] ref_set = [] for n in range(0,8): ref_set.append(line_s[n]) ref_dict.setdefault(ID,[]).append(ref_set) ref_dict.setdefault(ID,[]).append(info[3])with open(sys.argv[2]) as mrna: for eachline in mrna: i = eachline.strip().split(&#x27;\\t&#x27;) info1 = re.split(&#x27;=|;&#x27;,i[8]) parent = info1[3] mrna_n = info1[1] ref_set1 = [] for a in range(0,8): ref_set1.append(i[a]) mrna_h = &#x27;\\t&#x27;.join(ref_set1) if parent in ref_dict: vs = ref_dict[parent] head = &#x27;\\t&#x27;.join(vs[0]) fout.write(&#x27;%s\\tID=%s;Name=%s\\n&#x27;%(head,parent,vs[1])) fout.write(&#x27;%s\\tID=%s;Parent=%s;Name=%s\\n&#x27;%(mrna_h,mrna_n,parent,vs[1]))fout.close()phthon3 sort_EVM.py filter.gff filter.gff EVM_sort.gff 接下来进行重命名 对每个基因实现编号，形如ABCD000010的效果，方便后续分析。如下代码是基于EVM_sort.gff 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950vi rename.py#!/usr/bin/env python3import reimport sysif len(sys.argv) &lt; 3: sys.exit()gff = open(sys.argv[1])prf = sys.argv[2]count = 0mRNA = 0cds = 0exon = 0print(&quot;##gff-version 3.2.1&quot;)for line in gff: if not line.startswith(&quot;\\n&quot;): records = line.split(&quot;\\t&quot;) records[1] = &quot;.&quot; if re.search(r&quot;\\tgene\\t&quot;, line): count = count + 10 mRNA = 0 gene_id = prf + str(count).zfill(6) records[8] = &quot;ID=&#123;&#125;&quot;.format(gene_id) elif re.search(r&quot;\\tmRNA\\t&quot;, line): cds = 0 exon = 0 mRNA = mRNA + 1 mRNA_id = gene_id + &quot;.&quot; + str(mRNA) records[8] = &quot;ID=&#123;&#125;;Parent=&#123;&#125;&quot;.format(mRNA_id, gene_id) elif re.search(r&quot;\\texon\\t&quot;, line): exon = exon + 1 exon_id = mRNA_id + &quot;_exon_&quot; + str(exon) records[8] = &quot;ID=&#123;&#125;;Parent=&#123;&#125;&quot;.format(exon_id, mRNA_id) elif re.search(r&quot;\\tCDS\\t&quot;, line): cds = cds + 1 cds_id = mRNA_id + &quot;_cds_&quot; + str(cds) records[8] = &quot;ID=&#123;&#125;;Parent=&#123;&#125;&quot;.format(cds_id, mRNA_id) else: continue print(&quot;\\t&quot;.join(records))gff.close()gffrename.py EVM_sort.gff LH &gt; renamed.gff 完美成功 结语接下来我将进行功能注释，目前想到的是用Nr库、Swiss-Prot（也可以用TrEMBL，但sp要更可靠）、interproscan（包含了Pfam以及GO）、KEGG这四个基本的注释，对于真菌基因组，可能会再加上COG、CAZyme、病毒相关因子(PHI数据库)、次生代谢基因(AntiSMASH)。","tags":"bioinformatics gene_annotion"},{"title":"基因结构注释（3）：转录组注释","url":"/2020/11/24/2020-11-24-annotion(3)/","text":"对于RNA-seq数据，有两种使用策略，一种是使用HISAT2 + StringTie先比对再组装, 一种是从头组装，然后使用PASA将转录本比对到基因组上。在本篇教程中，只使用有参组装 参考链接：如何对基因组注释 首先，使用HISAT2将RNA-seq数据比对到参考基因组, 这一步和之前相似，但是要增加一个参数--dta，使得StingTie能更好的利用双端信息 12345hisat2-build LH.mask.fa index/chi_masked ##这个是屏蔽重复序列后的一个待发表基因组，与上两篇推文的基因组不一样hisat2 --dta -p 20 -x index/chi_masked -1 1-1_R1.fastq -2 1-1_R2.fastq | samtools sort -@ 10 &gt; results/1-1.bam &amp;hisat2 --dta -p 20 -x index/chi_masked -1 1-2_R1.fastq -2 1-2_R2.fastq | samtools sort -@ 10 &gt; results/1-2.bam &amp;hisat2 --dta -p 20 -x index/chi_masked -1 1-3_R1.fastq -2 1-3_R2.fastq | samtools sort -@ 10 &gt; results/1-3.bam &amp;samtools merge -@ 10 results/merged.bam results/1-1.bam results/1-2.bam results/1-3.bam 然后用StringTie进行转录本预测 1stringtie -p 10 -o results/merged.gtf results/merged.bam 对于后续的EvidenceModeler而言，它不需要UTR信息，只需要编码区CDS，需要用TransDecoder进行编码区预测 12345678TransDecoder-TransDecoder-v5.5.0/util/gtf_genome_to_cdna_fasta.pl merged.gtf input/chi_masked.fa &gt; transcripts.fastaTransDecoder-TransDecoder-v5.5.0/util/gtf_to_alignment_gff3.pl merged.gtf &gt; transcripts.gff3TransDecoder.LongOrfs -t transcripts.fastaTransDecoder.Predict -t transcripts.fastaTransDecoder-TransDecoder-v5.5.0/util/cdna_alignment_orf_to_genome_orf.pl \\ transcripts.fasta.transdecoder.gff3 \\ transcripts.gff3 \\ transcripts.fasta &gt; transcripts.fasta.transdecoder.genome.gff3 最后结果transcripts.fasta.transdecoder.genome.gff3用于提供给EvidenceModeler","tags":"bioinformatics gene_annotion"},{"title":"基因结构注释（2）：同源注释","url":"/2020/11/21/2020-11-21-annotion(2)/","text":"同源预测(homology prediction)利用近缘物种已知基因进行序列比对，找到同源序列。然后在同源序列的基础上，根据基因信号如剪切信号、基因起始和终止密码子对基因结构进行预测. 在同源预测上，目前看到的大部分基因组文章都是基于TBLASTN + GeneWise,但是目前GeneWise已经不在维护，在本次推文中将使用GenomeThreader进行同源注释。 参考链接：如何对基因组注释 确定同源物种蛋白序列首先选择同源物种，在本次分析中，我使用Saccharomyces_cerevisiae、Laccaria_bicolor、Amanita_thiersii、Pleurotus_pulmonarius、Pterula_gracilis进行同源注释 12345cat Saccharomyces_cerevisiae.fa\\ Laccaria_bicolor.fa \\ Amanita_thiersii \\ Pleurotus_pulmonarius \\ Pterula_gracilis &gt;all.pep.fa 然后使用TBLASTN确定匹配到基因组的蛋白序列 1234567891011121314makeblastdb -in pudorinus.fa -parse_seqids -dbtype nucl -out index/pu&amp;## tblastn比对nohup tblastn -query all.pep.fa -out pu.blast -db index/pu -outfmt 6 -evalue 1e-10 -num_threads 8 -qcov_hsp_perc 50.0 -num_alignments 5 &amp;## 提取匹配到基因组的蛋白序列awk &#x27;&#123;print $1&#125;&#x27; pu.blast &gt;pu.listsort pu.list| unique &gt;pi.ho.listseqkit seq all.pep.fa -w 0 &gt; all.favi sh.sh cat list.ru | while read line do grep &quot;$line&quot; -A 1 all.fa &gt;$line.1 done cat *.1 &gt; pudorinus.homo.fa rm -rf *.1 使用gth进行同源注释 12gth -genomic pudorinus.fa -protein pudorinus.homo.fa -intermediate -gff3out &gt; pudorinus.gff 删除一些无用的信息可以看到基本已经注释完成，但是exon之类的没有ID，在后续识别会有问题 12grep -v &quot;^#&quot; pudorinus.gth.gff | grep -v &quot;prime_cis_splice_site&quot; | awk -F &quot;;&quot; &#x27;&#123;print$1&#125;&#x27;&gt;pudorinus.homo.gffless pudorinus.homo.gff 使用脚本处理下(谢谢课题组师姐帮忙写的脚本(#^.^#)) 1234567891011121314151617181920212223242526272829303132333435363738394041424344#!/lustre/home/guohan_lab/local/python-3.6/bin/python3#liyumei#./change-name_lym.py proteinprediction.gff proteinprediction.gff proteinprediction_r.gffimport sysimport refout = open(sys.argv[3],&#x27;w&#x27;)ref_dict=&#123;&#125;with open(sys.argv[1]) as gff: for line in gff: line_s = line.strip().split(&#x27;\\t&#x27;) if &#x27;gene&#x27; == line_s[2]: ref_g = re.split(&#x27;=&#x27;,line_s[8]) ref_gene = ref_g[1] ref_dict[ref_gene]=[] else: pos = line_s[3] ref_dict[ref_gene].append(pos)with open(sys.argv[2]) as gff_r: for eachline in gff_r: i = eachline.strip().split(&#x27;\\t&#x27;) info = re.split(&#x27;=&#x27;,i[8]) name = info[1] ref_set = [] for n in range(0,8): ref_set.append(i[n]) ref_list = &#x27;\\t&#x27;.join(ref_set) ref_set1 = [&#x27;CDS&#x27; if x == &#x27;exon&#x27; else x for x in ref_set] ref_list1 = &#x27;\\t&#x27;.join(ref_set1) if &#x27;gene&#x27; == i[2]: fout.write(eachline) elif &#x27;exon&#x27; == i[2]: if name in ref_dict: vs = ref_dict[name] len_vs = len(vs) for a in range(0,len_vs): if vs[a] == i[3]: b = vs.index(vs[a]) fout.write(&#x27;%s\\tID=%s.t%d;Parent=%s\\n&#x27;%(ref_list,name,b+1,name)) fout.write(&#x27;%s\\tID=%s.c%d;Parent=%s\\n&#x27;%(ref_list1,name,b+1,name))fout.close() 1python3 ../annotion/change-gff_lym.py pudorinus.homo.gff pudorinus.homo.gff prediction.pudorinus.gff 至此同源注释已经结束","tags":"bioinformatics gene_annotion"},{"title":"基因结构注释（1）：从头注释","url":"/2020/11/19/2020-11-19-annotion(1)/","text":"前言最近的推文将是一个大系列，目录就不放了，可能会有点多，主要涉及了基因注释，比较基因组学分析，基因家族分析等，大家看我博客的顺序就行。 基因注释参考链接(不得不说州更大神真的是植物生信方面的专家了) 基因注释主要有三种策略 从头注释(de novo prediction)：通过已有的概率模型来预测基因结构，在预测剪切位点和UTR区准确性较低 同源预测(homology-based prediction)：有一些基因蛋白在相近物种间的保守型搞，所以可以使用已有的高质量近缘物种注释信息通过序列联配的方式确定外显子边界和剪切位点 基于转录组预测(transcriptome-based prediction)：通过物种的RNA-seq数据辅助注释，能够较为准确的确定剪切位点和外显子区域。 每一种方法都有自己的优缺点，所以最后需要用EvidenceModeler(EVM)和GLEAN工具进行整合，合并成完整的基因结构。基于可靠的基因结构，后续可才是功能注释，蛋白功能域注释，基因本体论注释，通路注释等。 在注释之前需要对重复序列进行屏蔽，可以参考我之前的推文：repeatmasker的安装与使用 从头注释 可以看到在该文献中从头注释使用的是augustus和GlimmerHMM augustus根据已有模型训练AUGUSTUS的无root安装比较麻烦，我折腾了好几天最后卒，不过辛亏有bioconda，conda create -n annotation augustus=3.3 我这次预测的基因是一种担子菌，可以使用augustus --species=help查看已有的物种,在本次分析中，我使用laccaria_bicolor作为已有的模型(pudorinus.mask.fa是去除重复序列的基因组序列) 1augustus --species=laccaria_bicolor pudorinus.mask.fa &gt; pudorinus.gff 如果嫌慢，可以试一下并行策略 1234seqkit split pudorinus.mask.fafind pudorinus.mask.fa.split/ -type f -name &quot;*.fa&quot; | parallel -j 30 augustus --species=arabidopsis --gff3=on &gt;&gt; temp.gff #并行处理join_aug_pred.pl &lt; temp.gff | grep -v &#x27;^#&#x27; &gt; temp.joined.gffbedtools sort -i temp.joined.gff &gt; pudorinus.augustus.gff 无监督训练模型GeneMark-ES/ET则是唯一一款支持无监督训练模型，之后再识别真核基因组蛋白编码区的工具。 1234567wget http://topaz.gatech.edu/GeneMark/tmp/GMtool_Qg87n/gm_et_linux_64.tar.gztar xf gm_et_linux_64.tar.gzmv gm_et_linux_64/gmes_petap/ /datadisk02/softwget http://topaz.gatech.edu/GeneMark/tmp/GMtool_Qg87n/gm_key_64.gzgzip -dc gm_key_64.gz &gt; ~/.gm_keycpan YAML Hash::Merge Logger::Simple Parallel::ForkManagerecho &quot;export PATH=$PATH:/datadisk02/soft/gmes_petap/&quot; &gt;&gt; ~/.bashrc 安装之后进行预测 1gmes_petap.pl --ES --sequence pudorinus.mask.fa --cores 50 最后得到的是genemark.gtf，是标准的GTF格式,可以使用gffread转换 1gffread genemark.gtf -o- &gt; pudorinus.genemarkes.gff3 从头注释已经完成，接下来的是同源与转录组。","tags":"bioinformatics gene_annotion"},{"title":"RNA速率：使用Seurat的结果做RNA velocity","url":"/2020/11/14/2020-11-14-RNAvelocity(3)/","text":"参考链接:https://github.com/velocyto-team/velocyto.R http://velocyto.org/velocyto.py/index.html http://pklab.med.harvard.edu/velocyto/notebooks/R/chromaffin2.nb.html https://htmlpreview.github.io/?https://github.com/satijalab/seurat-wrappers/blob/master/docs/velocity.html https://github.com/velocyto-team/velocyto.R/issues/16 https://www.cnblogs.com/raisok/p/12425258.html 目录RNA速率:软件下载与loom文件准备 RNA速率：数据读入 RNA速率：使用Seurat的结果做RNA velocity 导入Seurat以及loom对象123456&gt;library(Seurat)## remotes::install_github(&#x27;satijalab/seurat-wrappers&#x27;)&gt;library(SeuratWrappers)## 导入Seurat对象,之前分析的结果&gt;load(&quot;wang.rds&quot;)&gt;load(&#x27;wang-loom.rds&#x27;) 统一loom对象和Seurat的细胞名与基因名123456789101112131415&gt; wt$spliced[1:3,1:3]3 x 3 sparse Matrix of class &quot;dgCMatrix&quot; WANG:AAAGTAGAGATGTTAGx WANG:AAACCTGTCAGCATGTx WANG:AAAGCAACATTTGCTTxAT1G01020 . . .AT1G01030 . . .AT1G03993 . . .&gt; wang@meta.data[1:3,1:3] orig.ident nCount_RNA nFeature_RNAAAACCTGAGAATTCCC-1 zxz 3756 2158AAACCTGAGGGCACTA-1 zxz 2774 1669AAACCTGAGTAATCCC-1 zxz 2463 1290&gt; colnames(wt$spliced)&lt;-gsub(&quot;x&quot;,&quot;-1&quot;,colnames(wt$spliced))&gt; colnames(wt$spliced)&lt;-gsub(&quot;WANG:&quot;,&quot;&quot;,colnames(wt$spliced))&gt; colnames(wt$unspliced)&lt;-colnames(wt$spliced)&gt; colnames(wt$ambiguous)&lt;-colnames(wt$spliced) 计算velocity提取spliced与unspliced文件，并提取原有的Seurat的UAMP图 1234567891011## 由于Seurat的对象筛选了数据，所以两个文件细胞并不相同，以Seurat对象为准&gt; wt$spliced&lt;-wt$spliced[,rownames(wang@meta.data)]&gt; wt$unspliced&lt;-wt$unspliced[,rownames(wang@meta.data)]&gt; wt$ambiguous&lt;-wt$ambiguous[,rownames(wang@meta.data)]&gt; sp &lt;- wt$spliced&gt; unsp &lt;- wt$unspliced&gt; WTumap &lt;- wang@reductions$umap@cell.embeddings## 估计细胞和细胞的距离&gt; cell.dist &lt;- as.dist(1-armaCor(t(wang@reductions$umap@cell.embeddings)))&gt; fit.quantile &lt;- 0.02&gt; rvel.cd &lt;- gene.relative.velocity.estimates(sp,unsp,deltaT=2,kCells=10, cell.dist=cell.dist,fit.quantile=fit.quantile,n.cores=24) 在UMAP聚类图上绘制RNA velocity123456789library(ggplot2)pdf(&quot;cell_velocity.pdf&quot;,height=6,width=8)gg &lt;- UMAPPlot(wang)ggplot_build(gg)$datacolors &lt;- as.list(ggplot_build(gg)$data[[1]]$colour)names(colors) &lt;- rownames(WTumap)p1 &lt;- show.velocity.on.embedding.cor(WTumap,rvel.cd,n=30,scale=&#x27;sqrt&#x27;,cell.colors=ac(colors,alpha=0.5),cex=0.8,arrow.scale=2,show.grid.flow=T,min.grid.cell.mass=1.0,grid.n=50,arrow.lwd=1,do.par=F,cell.border.alpha =0.1,USE_OPENMP=1,n.cores=24,main=&quot;Cell Velocity&quot;)dev.off() 这结果根本看不出啥啊，我选RC试试 1234id&lt;-c(&#x27;2&#x27;,&#x27;3&#x27;,&#x27;19&#x27;,&#x27;20&#x27;)Cell.sub &lt;- subset(wang@meta.data,seurat_clusters==id)scRNAsub &lt;- subset(wang, cells=row.names(Cell.sub))##后续的操作相同 倒是有个轨迹，但是并不明显 换成cluster12.14.19试试 这一次就有一个明显的轨迹了 总体来讲，感觉植物做RNA velocity的结果并没有动物的那么好，是自己分析的问题还是其他原因有待商榷。","tags":"bioinformatics scrnaseq rna_velocity"},{"title":"RNA速率：数据读入","url":"/2020/11/12/2020-11-12-RNAvelocity(2)/","text":"参考链接:https://github.com/velocyto-team/velocyto.R http://velocyto.org/velocyto.py/index.html http://pklab.med.harvard.edu/velocyto/notebooks/R/chromaffin2.nb.html https://htmlpreview.github.io/?https://github.com/satijalab/seurat-wrappers/blob/master/docs/velocity.html https://github.com/velocyto-team/velocyto.R/issues/16 https://www.cnblogs.com/raisok/p/12425258.html 目录RNA速率:软件下载与loom文件准备 RNA速率：数据读入 RNA速率：使用Seurat的结果做RNA velocity velocyto.R的安装loom文件生成后，接下来将使用velocyto.R对loom文件进行分析 12library(devtools)install_github(&quot;velocyto-team/velocyto.R&quot;) 数据读入12345678910111213&gt;library(velocyto.R)&gt;setwd(&quot;/datadisk02/Jiawei_Wang_2019&quot;)&gt;wt&lt;-read.loom.matrices(&quot;WANG/velocyto/WANG.loom&quot;)reading loom file via hdf5r...&gt;str(wt1)List of 3 $ spliced :Formal class &#x27;dgCMatrix&#x27; [package &quot;Matrix&quot;] with 6 slots $ unspliced:Formal class &#x27;dgCMatrix&#x27; [package &quot;Matrix&quot;] with 6 slots $ ambiguous:Formal class &#x27;dgCMatrix&#x27; [package &quot;Matrix&quot;] with 6 slots&gt;save(wt,file=&quot;WT-loom.rds&quot;)&gt;emat&lt;-WT$spliced#做直方图查看数据分步&gt;hist(log10(colSums(emat)),col=&#x27;wheat&#x27;,xlab=&#x27;cell size&#x27;) 后续过程我想用Seurat的聚类进行分析，所以velocyto.R的聚类就不运行了","tags":"bioinformatics scrnaseq rna_velocity"},{"title":"RNA速率：软件下载与loom文件准备","url":"/2020/11/10/2020-11-10-RNAvelocity(1)/","text":"参考链接:https://github.com/velocyto-team/velocyto.R http://velocyto.org/velocyto.py/index.html http://pklab.med.harvard.edu/velocyto/notebooks/R/chromaffin2.nb.html https://htmlpreview.github.io/?https://github.com/satijalab/seurat-wrappers/blob/master/docs/velocity.html https://github.com/velocyto-team/velocyto.R/issues/16 https://www.jianshu.com/p/bce19672879e 目录RNA速率:软件下载与loom文件准备 RNA速率：数据读入 RNA速率：使用Seurat的结果做RNA velocity velocyto下载首先是下载velocyto生成loom文件 123456789101112131415161718192021## 1. 创建python&gt;3.6的环境conda create -n velocyto python=3.6## 2. 安装前置软件conda install numpy scipy cython numba matplotlib scikit-learn h5py clickpip install pysam## 3. 安装velocytopip install velocyto## 4. 测试velocyto --helpUsage: velocyto [OPTIONS] COMMAND [ARGS]...Options: --version Show the version and exit. --help Show this message and exit.Commands: run Runs the velocity analysis outputting a loom file run10x Runs the velocity analysis for a Chromium Sample run-dropest Runs the velocity analysis on DropEst preprocessed data run-smartseq2 Runs the velocity analysis on SmartSeq2 data (independent bam file per cell) tools helper tools for velocyto repeat_masker.gtf生成运行velocyto需要准备三个文件，单细胞数据分析的结果文件，基因组注释文件，重复序列注释文件，其中前两个在单细胞分析时就会得到，关键是这个repeat_masker.gtf 本人是做植物的，所以本次教程主要关注植物类repeat_masker.gtf的获得，人和小鼠的重复序列文件比较好得到，植物类首先可以看一下Phtozome数据库上想要研究的物种的注释文件夹下有没有reapeat.gtf，没有就要我们自己生成了 重复序列的注释文件我们一直没怎么关注过，对于做过基因组注释的童鞋来说，大家都忽略了一步，其实repeatmasker就可以生成重复序列的注释文件。 1RepeatMasker -e ncbi -species arabidopsis -pa 40 -gff TAIR10.fa 生成gff文件后，可以看到重复序列的点位以及属性，velocyto主要使用的就是位点 loom文件生成接下来是生成loom文件，运行velocyto需要准备三个文件，基因组注释文件(gtf)，repeat_masker.gtf(重复序列注释文件)，cellranger的结果文件夹(以样本名WT_1为例，里面包含cell matrix和bam文件) 1velocyto -m TAIR10_masked.gtf WANG/ TAIR10.gtf 运行结束后会在WANG文件夹下生成velocyto文件夹，里面有velocyto.loom的文件，可以用于下一步的分析","tags":"bioinformatics scrnaseq rna_velocity"},{"title":"生信技能树单细胞数据挖掘笔记(7)","url":"/2020/11/07/2020-11-07-ScRNAseq(13)/","text":"生信技能树单细胞数据挖掘笔记(1)：数据读入 生信技能树单细胞数据挖掘笔记(2)：创建Seurat对象并进行质控、筛选高变基因并可视化 生信技能树单细胞数据挖掘笔记(3)：降维与聚类 生信技能树单细胞数据挖掘笔记(4)：其他分析（周期判断、double诊断、细胞类型注释） 生信技能树单细胞数据挖掘笔记(5)：轨迹分析 生信技能树单细胞数据挖掘笔记(6)：差异分析(1) 生信技能树单细胞数据挖掘笔记(7)：差异分析(2) 3、根据count矩阵转换fpkm并完成差异分析3.1 导入count矩阵12345678910111213141516171819202122nm_COUNT &lt;- read.csv(&quot;GSE81861_CRC_NM_epithelial_cells_COUNT.csv/GSE81861_CRC_NM_epithelial_cells_COUNT.csv&quot;)nm_COUNT &lt;- data_input(nm_COUNT)nm_COUNT[1:4,1:4]dim(nm_COUNT)tumor_COUNT &lt;- read.csv(&quot;GSE81861_CRC_tumor_epithelial_cells_COUNT.csv/GSE81861_CRC_tumor_epithelial_cells_COUNT.csv&quot;)tumor_COUNT &lt;- data_input(tumor_COUNT)tumor_COUNT[1:4,1:4]dim(tumor_COUNT) RHC4104 RHC6087 RHL2880 RHC5949ENSG00000000003 0 428 66 141ENSG00000000005 0 0 0 0ENSG00000000419 0 179 0 1ENSG00000000457 465 0 0 0[1] 56380 160 RHC4075 RHC5563 RHC5552 RHC4874ENSG00000000003 0 0 0 0ENSG00000000005 0 0 0 0ENSG00000000419 0 0 0 0ENSG00000000457 0 133 0 0[1] 56380 272 3.2 计算fpkm矩阵123456789101112131415161718192021222324252627282930313233343536373839404142434445464748my_FPKM &lt;- function(counts,g_l)&#123; ####根据有基因长度的基因，筛选矩阵子集 #counts=nm_COUNT ng=intersect(rownames(counts),g_l$ensembl_id) length(ng) lengths=g_l[match(ng,g_l$ensembl_id),2] names(lengths) &lt;- g_l[match(ng,g_l$ensembl_id),1] head(lengths) #### 计算样本文库大小，以及最后的fpkm计算 counts &lt;- counts[names(lengths),] counts[1:4,1:4] total_count &lt;- colSums(counts) head(total_count) #根据counts、length、total_count计算fpkm FPKM &lt;- t(do.call( rbind, lapply(1:length(total_count), function(i)&#123; 10^9*counts[,i]/lengths/total_count[i] #lengths向量自动遍历 &#125;) )) FPKM[1:4,1:4] return(FPKM)&#125;nm_my_FPKM &lt;- my_FPKM(counts = nm_COUNT, g_l = g_l)colnames(nm_my_FPKM) &lt;- colnames(nm_COUNT)nm_my_FPKM[1:4,1:4]dim(nm_my_FPKM)tumor_my_FPKM &lt;- my_FPKM(counts = tumor_COUNT, g_l = g_l)dim(tumor_FPKM)colnames(tumor_my_FPKM) &lt;- colnames(tumor_COUNT)nm_my_FPKM[1:4,1:4] RHC4104 RHC6087 RHL2880 RHC5949ENSG00000000003 0.0000 160.5715 168.6839 22.7021034ENSG00000000005 0.0000 0.0000 0.0000 0.0000000ENSG00000000419 0.0000 219.5694 0.0000 0.5264304ENSG00000000457 124.2016 0.0000 0.0000 0.0000000[1] 50813 160[1] 56380 272 RHC4104 RHC6087 RHL2880 RHC5949ENSG00000000003 0.0000 160.5715 168.6839 22.7021034ENSG00000000005 0.0000 0.0000 0.0000 0.0000000ENSG00000000419 0.0000 219.5694 0.0000 0.5264304ENSG00000000457 124.2016 0.0000 0.0000 0.0000000 3.3 差异分析12345678910111213141516171819202122232425262728293031323334353637383940exp_my_FPKM &lt;- cbind(nm_my_FPKM,tumor_my_FPKM)dim(exp_my_FPKM) #转换id前exp_my_FPKM[1:4,1:4] #转换id前exp_my_FPKM &lt;- id_change(exp_my_FPKM)dim(exp_my_FPKM) #转换id后exp_my_FPKM[1:4,1:4] #转换id后my_FPKM_diff &lt;- scRNA_deg(exp=exp_my_FPKM, group=group_dat)head(my_FPKM_diff)dim(my_FPKM_diff)my_FPKM_diff &lt;- my_FPKM_diff[my_FPKM_diff$p_val&lt;0.01 &amp; abs(my_FPKM_diff$avg_logFC)&gt;0.8,]dim(my_FPKM_diff)exp_my_FPKM_diff &lt;- exp_my_FPKM[match(rownames(my_FPKM_diff),rownames(exp_my_FPKM)),][1] 50813 432 RHC4104 RHC6087 RHL2880 RHC5949ENSG00000000003 0.0000 160.5715 168.6839 22.7021034ENSG00000000005 0.0000 0.0000 0.0000 0.0000000ENSG00000000419 0.0000 219.5694 0.0000 0.5264304ENSG00000000457 124.2016 0.0000 0.0000 0.0000000[1] 50813 432[1] 24931 432[1] 24931 432 RHC4104 RHC6087 RHL2880 RHC5949TSPAN6 0.0000 160.5715 168.6839 22.7021034TNMD 0.0000 0.0000 0.0000 0.0000000DPM1 0.0000 219.5694 0.0000 0.5264304SCYL3 124.2016 0.0000 0.0000 0.0000000[1] &quot;创建seurat对象...&quot;[1] &quot;质控...&quot;[1] &quot;归一化...&quot;Performing log-normalization0% 10 20 30 40 50 60 70 80 90 100%[----|----|----|----|----|----|----|----|----|----|**************************************************|[1] &quot;差异分析...&quot; |++++++++++++++++++++++++++++++++++++++++++++++++++| 100% elapsed=04s [1] 1231 5[1] 112 5 3.4 可视化热图 1my_heatmap(exp_my_FPKM_diff) 箱图","tags":"bioinformatics scrnaseq"},{"title":"生信技能树单细胞数据挖掘笔记(6)","url":"/2020/11/05/2020-11-05-ScRNAseq(12)/","text":"生信技能树单细胞数据挖掘笔记(1)：数据读入 生信技能树单细胞数据挖掘笔记(2)：创建Seurat对象并进行质控、筛选高变基因并可视化 生信技能树单细胞数据挖掘笔记(3)：降维与聚类 生信技能树单细胞数据挖掘笔记(4)：其他分析（周期判断、double诊断、细胞类型注释） 生信技能树单细胞数据挖掘笔记(5)：轨迹分析 生信技能树单细胞数据挖掘笔记(6)：差异分析(1) 生信技能树单细胞数据挖掘笔记(7)：差异分析(2) 前言：使用GSE81861提供的数据，比较CRC肿瘤上皮细胞与正常上皮细胞的差异。GEO提供了count与fpkm两种数据。笔记内容先用官方的fpkm数据做差异分析，再利用counts数据手动计算fpkm矩阵，完成差异分析。最后比较两种方法的结果是否存在差异。 https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE81861 注：因为有不少重复的步骤，故设置较多的函数。 1、概述1.1 单细胞差异分析pipeline简单来说分为三步：首先导入、制备规范的表达矩阵以及分组信息；然后利用Seurat包构建seurat对象，归一化；最后进行差异分析，以及结果的可视化。 1.2 count标准化主要受测序文库(样本总read数)与基因长度的影响，测序的counts数据不能直接进行差异分析，需要进行标准化处理。常见的几种标准化方法简单介绍如下– rpkm：counts先对测序文库标准化，再对基因长度标准化； fpkm：FPKM同RPKM是一样的，只是RPKM用于单末端测序，而FPKM用于双末端测序； tpm：counts先对基因长度标准化，再对测序文库标准化； cpm：counts只对测序文库标准化。 测序文库相对容易计算，直接使用colSums()函数即可；而基因长度则比较难求，首先要了解基因长度有不同的定义标准，其次要知道哪些R包提供相关生物数据。目前有以下三种方法，以及根据与官方fpkm验证，最终选择第三种方法用于后续的分析。 计算基因长度(1)TxDb.Hsapiens.UCSC.hg19.knownGene包123456if (!require(&quot;TxDb.Hsapiens.UCSC.hg19.knownGene&quot;, quietly = TRUE)) BiocManager::install(&quot;TxDb.Hsapiens.UCSC.hg19.knownGene&quot;)library(TxDb.Hsapiens.UCSC.hg19.knownGene)txdb &lt;- TxDb.Hsapiens.UCSC.hg19.knownGeneexon_txdb=exons(txdb)genes_txdb=genes(txdb) g_l.1–根据非冗余外显子之和定义message123456789101112131415161718192021222324252627282930313233343536g_l_1 &lt;- function()&#123; o &lt;- findOverlaps(exon_txdb,genes_txdb) t1=exon_txdb[queryHits(o)] t2=genes_txdb[subjectHits(o)] t1=as.data.frame(t1) t1$geneid=mcols(t2)[,1] # 得到exon_id与geneid的对应关系 g_l.1 &lt;- lapply(split(t1,t1$geneid),function(x)&#123; #按gene id拆分表格 head(x) tmp=apply(x,1,function(y)&#123; y[2]:y[3] &#125;) #根据每一个gene所有exon的区间，生成区间内的整数，返回的为list。 length(unique(unlist(tmp))) #计算共有多少种整数，即为最终的非冗余exon长度之和 &#125;) head(g_l.1) #为一个list g_l.1=data.frame(gene_id=names(g_l.1),length=as.numeric(g_l.1)) dim(g_l.1) head(g_l.1) #为基因ID增添ENSEMBLE ID if (!require(&quot;org.Hs.eg.db&quot;, quietly = TRUE)) BiocManager::install(&quot;org.Hs.eg.db&quot;) library(org.Hs.eg.db) s2g=toTable(org.Hs.egENSEMBL) head(s2g) g_l.1=merge(g_l.1,s2g,by=&#x27;gene_id&#x27;) #把g_l,s2g两个数据框以&#x27;gene_id&#x27;为连接进行拼接 head(g_l.1) return(g_l.1)&#125;g_l.1 &lt;- g_l_1()head(g_l.1) g_l.2—-根据最长转录本定义12345678910111213141516171819g_l_2 &lt;- function()&#123; t_l=transcriptLengths(txdb) head(t_l) t_l=na.omit(t_l) #先按基因ID，再按转录本长度从大到小排序 t_l=t_l[order(t_l$gene_id,t_l$tx_len,decreasing = T),] head(t_l);dim(t_l) #根据gene_id去重，选择第一个，也就是最长的那个 t_l=t_l[!duplicated(t_l$gene_id),] head(t_l);dim(t_l) g_l.2=t_l[,c(3,5)] library(org.Hs.eg.db) s2g=toTable(org.Hs.egENSEMBL) g_l.2=merge(g_l.2,s2g,by=&#x27;gene_id&#x27;) head(g_l.2) return(g_l.2)&#125;g_l.2 &lt;- g_l_2()head(g_l.2) (2)biomaRt包g_l.3–根据最长转录本定义1234567891011121314151617181920212223g_l_3 &lt;- function()&#123; if (!require(&quot;biomaRt&quot;, quietly = TRUE)) BiocManager::install(&quot;biomaRt&quot;) library(biomaRt) ensembl &lt;- useMart(&quot;ensembl&quot;) #connect to a specified BioMart database ensembl = useDataset(&quot;hsapiens_gene_ensembl&quot;,mart=ensembl) #use the hsapiens(人类) dataset.或者直接如下设置 #ensembl = useMart(&quot;ensembl&quot;,dataset=&quot;hsapiens_gene_ensembl&quot;) #BiocManager::install(&#x27;grimbough/biomaRt&#x27;) #library(biomaRt) #packageVersion(&#x27;biomaRt&#x27;) test &lt;- getBM(attributes=c(&#x27;ensembl_gene_id&#x27;, &#x27;start_position&#x27;, &#x27;end_position&#x27;,&#x27;ensembl_transcript_id&#x27;, &#x27;transcript_length&#x27;), mart = ensembl) test &lt;- test[order(test$ensembl_gene_id,test$transcript_length, decreasing = T),] g_l.3 &lt;- test[!duplicated(test$ensembl_gene_id),] g_l.3 &lt;- g_l.3[,c(1,5)] head(g_l.3) return(g_l.3)&#125;g_l.3 &lt;- g_l_3() 比较三种结果的差异1234567891011121314dim(g_l.1);dim(g_l.2);dim(g_l.3)g_l.1 &lt;- g_l.1[,-1]colnames(g_l.1) &lt;- c(&quot;g_l.1&quot;,&quot;ensembl_id&quot;)g_l.2 &lt;- g_l.2[,-1]colnames(g_l.2) &lt;- c(&quot;g_l.2&quot;,&quot;ensembl_id&quot;)colnames(g_l.3) &lt;- c(&quot;ensembl_id&quot;,&quot;g_l.3&quot;)g_l_all &lt;- merge(g_l.1, g_l.2, by=&quot;ensembl_id&quot;)g_l_all &lt;- merge(g_l_all, g_l.3, by=&quot;ensembl_id&quot;)head(g_l_all,10)summary(g_l_all)#最终选择第三种结果，即biomaR包g_l &lt;- g_l.3 2.官方fpkm数据差异分析2.1 表达矩阵与分组信息12345678910111213141516171819202122232425262728293031323334353637383940414243#表达矩阵nm_FPKM &lt;- read.csv(&quot;GSE81861_CRC_NM_epithelial_cells_FPKM.csv/GSE81861_CRC_NM_epithelial_cells_FPKM.csv&quot;)data_input &lt;- function(data)&#123; #data &lt;- nm_FPKM row.names(data) &lt;- data[,1] data &lt;- data[,-1] data &lt;- as.matrix(data) rownames(data) &lt;- sapply(strsplit(rownames(data),&quot;_&quot;),&quot;[&quot;,3) rownames(data) &lt;- sapply(strsplit(rownames(data),&quot;[.]&quot;),&quot;[&quot;,1) colnames(data) &lt;- sapply(strsplit(colnames(data),&quot;_&quot;),&quot;[&quot;,1) data &lt;- data[grep(&quot;ENSG&quot;,rownames(data)),] return(data)&#125;nm_FPKM &lt;- data_input(nm_FPKM)dim(nm_FPKM) #56380个基因 #160个样本nm_FPKM[1:4,1:4]tumor_FPKM &lt;- read.csv(&quot;GSE81861_CRC_tumor_epithelial_cells_FPKM.csv/GSE81861_CRC_tumor_epithelial_cells_FPKM.csv&quot;)tumor_FPKM &lt;- data_input(tumor_FPKM)tumor_FPKM[1:4,1:4]dim(tumor_FPKM)#56380个基因 #272个样本exp_FPKM &lt;- cbind(nm_FPKM,tumor_FPKM)dim(exp_FPKM) # 56380个基因 432个样本#分组信息group_dat &lt;- data.frame(group=c(rep(&#x27;normal&#x27;,160), rep(&#x27;tumor&#x27;,272)), row.names = colnames(exp_FPKM))[1] 56380 160 RHC4104 RHC6087 RHL2880 RHC5949ENSG00000000003 0.000 185.315 323.203 22.311700ENSG00000000005 0.000 0.000 0.000 0.000000ENSG00000000419 0.000 231.756 0.000 0.851514ENSG00000000457 100.135 0.000 0.000 0.000000 RHC4075 RHC5563 RHC5552 RHC4874ENSG00000000003 0 0.000 0 0ENSG00000000005 0 0.000 0 0ENSG00000000419 0 0.000 0 0ENSG00000000457 0 193.167 0 0[1] 56380 272[1] 56380 432 2.2 ID转换因为seurat质控需要过滤线粒体基因，所以需要把ensembl ID转换为 symbol ID 12345678910111213141516exp_FPKM[1:4,1:4]id_change &lt;- function(data)&#123; print(dim(data)) library(org.Hs.eg.db) ids1 &lt;- data.frame(ID=c(1:nrow(data)), ensembl_id=rownames(data)) ids2 &lt;- merge(toTable(org.Hs.egENSEMBL), toTable(org.Hs.egSYMBOL),by=&quot;gene_id&quot;) ids &lt;- merge(ids1, ids2, by=&quot;ensembl_id&quot;) data &lt;- data[ids$ID,] rownames(data) &lt;- ids$symbol print(dim(data)) return(data)&#125;exp_FPKM &lt;- id_change(exp_FPKM) #有2w+个ensembl ID没配对到 symbolexp_FPKM[1:4,1:4] 2.3 创建seurat，质控，差异分析一键操作12345678910111213141516171819202122scRNA_deg &lt;- function(exp,group)&#123; library(Seurat) print(&quot;创建seurat对象...&quot;) scRNA &lt;- CreateSeuratObject(counts=exp, meta.data=group) print(&quot;质控...&quot;) scRNA[[&quot;percent.mt&quot;]] &lt;- PercentageFeatureSet(scRNA, pattern = &quot;^MT-&quot;) minGene=500;maxGene=4000;pctMT=15 scRNA &lt;- subset(scRNA, subset = nFeature_RNA &gt; minGene &amp; nFeature_RNA &lt; maxGene &amp; percent.mt &lt; pctMT) print(&quot;归一化...&quot;) scRNA &lt;- NormalizeData(scRNA, normalization.method = &quot;LogNormalize&quot;, scale.factor = 10000) print(&quot;差异分析...&quot;) diff_dat &lt;- FindMarkers(scRNA,ident.1=&quot;normal&quot;,ident.2=&quot;tumor&quot;, group.by=&#x27;group&#x27;)&#125;FPKM_diff &lt;- scRNA_deg(exp=exp_FPKM, group=group_dat)head(FPKM_diff)dim(FPKM_diff)FPKM_diff &lt;- FPKM_diff[FPKM_diff$p_val&lt;0.01 &amp; abs(FPKM_diff$avg_logFC)&gt;0.8,]dim(FPKM_diff)exp_FPKM_diff &lt;- exp_FPKM[match(rownames(FPKM_diff),rownames(exp_FPKM)),] 1234567891011[1] &quot;创建seurat对象...&quot;[1] &quot;质控...&quot;[1] &quot;归一化...&quot;Performing log-normalization0% 10 20 30 40 50 60 70 80 90 100%[----|----|----|----|----|----|----|----|----|----|**************************************************|[1] &quot;差异分析...&quot; |++++++++++++++++++++++++++++++++++++++++++++++++++| 100% elapsed=04s [1] 1455 5[1] 119 5 2.4 差异结果可视化热图 12345678910my_heatmap &lt;- function(exp_dat)&#123; n &lt;- t(scale(t(exp_dat))) n[n&gt;2]=2;n[n&lt; -2]= -2 library(pheatmap) pheatmap(n, show_rownames = F, show_colnames = F, annotation_col = group_dat)&#125;p.exp_FPKM_diff &lt;- my_heatmap(exp_FPKM_diff)p.exp_FPKM_diff 箱图","tags":"bioinformatics scrnaseq"},{"title":"生信技能树单细胞数据挖掘笔记(5)","url":"/2020/11/03/2020-11-03-ScRNAseq(11)/","text":"生信技能树单细胞数据挖掘笔记(1)：数据读入 生信技能树单细胞数据挖掘笔记(2)：创建Seurat对象并进行质控、筛选高变基因并可视化 生信技能树单细胞数据挖掘笔记(3)：降维与聚类 生信技能树单细胞数据挖掘笔记(4)：其他分析（周期判断、double诊断、细胞类型注释） 生信技能树单细胞数据挖掘笔记(5)：轨迹分析 生信技能树单细胞数据挖掘笔记(6)：差异分析(1) 生信技能树单细胞数据挖掘笔记(7)：差异分析(2) 轨迹分析通过构建细胞间的变化轨迹来重塑细胞随时间的变化过程。 1234567891011121314151617181920212223##4、拟时轨迹分析----library(monocle)data &lt;- as(as.matrix(scRNA@assays$RNA@counts), &#x27;sparseMatrix&#x27;)# count矩阵pd &lt;- new(&#x27;AnnotatedDataFrame&#x27;, data = scRNA@meta.data)# meta表转成特定格式fData &lt;- data.frame(gene_short_name = row.names(data), row.names = row.names(data))fd &lt;- new(&#x27;AnnotatedDataFrame&#x27;, data = fData)# 基因名表转成特定格式mycds &lt;- newCellDataSet(data, phenoData = pd, featureData = fd, expressionFamily = negbinomial.size())#expressionFamily参数用于指定表达矩阵的数据类型，有几个选项可以选择：#稀疏矩阵用negbinomial.size()，FPKM值用tobit()，logFPKM值用gaussianff()##save(mycds, file = &quot;../../tmp/mycds_raw.Rdata&quot;)##rm(list = ls())##load(&quot;../../tmp/mycds_raw.Rdata&quot;)#library(&quot;monocle&quot;)mycds &lt;- estimateSizeFactors(mycds)mycds &lt;- estimateDispersions(mycds, cores=4, relative_expr = TRUE) #!#完成数据导入和预处理后，就可以考虑选择特定基因代表细胞的发育特征 读入maker基因1234567891011mycds &lt;- estimateSizeFactors(mycds)mycds &lt;- estimateDispersions(mycds, cores=4, relative_expr = TRUE) #!#完成数据导入和预处理后，就可以考虑选择特定基因代表细胞的发育特征#这里可以选取我们之前挑选的marker geneload(&quot;../markergene.Rdata&quot;)markers.gene &lt;- all.markers$genemycds &lt;- setOrderingFilter(mycds, markers.gene)#降维mycds &lt;- reduceDimension(mycds, max_components = 2, method = &#x27;DDRTree&#x27;) #!#耗时，耗内存 细胞排序123456789101112#降维mycds &lt;- reduceDimension(mycds, max_components = 2, method = &#x27;DDRTree&#x27;) #!#耗时，耗内存#排序mycds &lt;- orderCells(mycds)#save(mycds,file = &quot;../../tmp/mycds_reduced.Rdata&quot;)load(&quot;../../tmp/mycds_reduced.Rdata&quot;)p1 &lt;- plot_cell_trajectory(mycds, color_by = &quot;seurat_clusters&quot;)ggsave(&quot;../../out/3.4trajectory_1.pdf&quot;, plot = p1)p2 &lt;- plot_cell_trajectory(mycds, color_by = &quot;State&quot;)ggsave(&quot;../../out/3.4trajectory_2.pdf&quot;, plot = p2) by_cluster by_state","tags":"bioinformatics scrnaseq"},{"title":"生信技能树单细胞数据挖掘笔记(4)","url":"/2020/10/31/2020-10-31-ScRNAseq(10)/","text":"生信技能树单细胞数据挖掘笔记(1)：数据读入 生信技能树单细胞数据挖掘笔记(2)：创建Seurat对象并进行质控、筛选高变基因并可视化 生信技能树单细胞数据挖掘笔记(3)：降维与聚类 生信技能树单细胞数据挖掘笔记(4)：其他分析（周期判断、double诊断、细胞类型注释） 生信技能树单细胞数据挖掘笔记(5)：轨迹分析 生信技能树单细胞数据挖掘笔记(6)：差异分析(1) 生信技能树单细胞数据挖掘笔记(7)：差异分析(2) QC之double droplet和周期判断12345678910111213141516171819202122232425262728load(&quot;../scRNA.Rdata&quot;)library(Seurat)##1、detect special cells----#empty droplet##BiocManager::install(&quot;DropletUtils&quot;)library(DropletUtils)e.out &lt;- emptyDrops(GetAssayData(scRNA,slot=&quot;counts&quot;,assay=&quot;RNA&quot;))#Error in testEmptyDrops(m, lower = lower, ...) :#no counts available to estimate the ambient profile##https://support.bioconductor.org/p/123554/#123562#如上回答所说，empty droplet往往在第一步就已经过滤掉了，而一般上传到GEO的也都是过滤掉空液滴的。#double droplet#https://osca.bioconductor.org/doublet-detection.html#BiocManager::install(&quot;scran&quot;)head(scRNA@meta.data)library(scran)#GetAssayData(scRNA,slot=&quot;counts&quot;,assay=&quot;RNA&quot;)[1:8,1:4]?doubletCluster #检查有无double droplet聚在一起的类db.test &lt;- doubletCluster(GetAssayData(scRNA,slot=&quot;counts&quot;,assay=&quot;RNA&quot;), clusters=scRNA@meta.data$seurat_clusters)head(db.test)table(scRNA@meta.data$seurat_clusters)library(scater)chosen.doublet &lt;- rownames(db.test)[isOutlier(db.test$N, type=&quot;lower&quot;, log=TRUE)]chosen.doublet #结果显示没有#还有其它多种方法 周期诊断123456789101112131415161718192021222324##2、周期判断----#在挑选hvg gene那一步因，可能会找到一些细胞周期相关基因；#它们会导致细胞聚类发生一定的偏移，即相同类型的细胞在聚类时会因为细胞周期的不同而分开。#因此有必要查看是否有细胞周期相关基因的存在；若有，则剔除#细胞周期有关基因?cc.geneshead(c(cc.genes$s.genes,cc.genes$g2m.genes))length(c(cc.genes$s.genes,cc.genes$g2m.genes))# [1] &quot;MCM5&quot; &quot;PCNA&quot; &quot;TYMS&quot; &quot;FEN1&quot; &quot;MCM2&quot; &quot;MCM4&quot;#查看我们选择的高变基因中有哪些细胞周期相关基因,及打分CaseMatch(c(cc.genes$s.genes,cc.genes$g2m.genes),VariableFeatures(scRNA))#在scRNA@meta.data中添加S.Score、G2M.Score和Phase三列有关细胞周期的信息。g2m_genes = cc.genes$g2m.genesg2m_genes = CaseMatch(search = g2m_genes, match = rownames(scRNA))s_genes = cc.genes$s.geness_genes = CaseMatch(search = s_genes, match = rownames(scRNA))scRNA &lt;- CellCycleScoring(object=scRNA, g2m.features=g2m_genes, s.features=s_genes)head(scRNA@meta.data)#观察细胞周期相关基因是否影响聚类scRNA &lt;- RunPCA(scRNA, features = c(s_genes, g2m_genes))p1 &lt;- DimPlot(scRNA, reduction = &quot;pca&quot;, group.by = &quot;Phase&quot;)ggsave(&quot;../../out/3.2cell-cycle.pdf&quot;, plot = p1)#影响不大，基本重合在一起了 周期的影响并不大 单细胞类型注释123456789101112131415161718192021222324252627282930313233##3、cell annotation-----# 对肿瘤细胞来说，分群后的细胞亚群注释是不可行的# 这里仅仅是演示 SingleR 做 cell annotation的流程library(SingleR)refdata &lt;- get(load(&quot;../../rawdata/HumanPrimaryCellAtlasData.Rdata&quot;))assay(refdata)[1:4,1:4]head(refdata@colData)head(refdata)ref &lt;- HumanPrimaryCellAtlasData()#参考数据库，等待时间较长。建议下载成功后，储存为Rdata，以后方便使用。testdata &lt;- GetAssayData(scRNA, slot=&quot;data&quot;)#参考数据库，等待时间较长。建议下载成功后，储存为Rdata，以后方便使用。testdata &lt;- GetAssayData(scRNA, slot=&quot;data&quot;)clusters &lt;- scRNA@meta.data$seurat_clusterscellpred &lt;- SingleR(test = testdata, ref = refdata, labels = refdata$label.fine, # label.fine耗时比较长一点 method = &quot;cluster&quot;, clusters = clusters, assay.type.test = &quot;logcounts&quot;, assay.type.ref = &quot;logcounts&quot;)save(cellpred,file = &quot;../../tmp/cellpred.Rdata&quot;)load(&quot;../../tmp/cellpred.Rdata&quot;)rm(refdata, HumanPrimaryCellAtlasData, testdata) #珍惜内存table(cellpred$labels)celltype = data.frame(ClusterID=rownames(cellpred), celltype=cellpred$labels, stringsAsFactors = F)table(celltype$ClusterID,celltype$celltype) #如下为singleR的细胞cluster鉴定结果。#结合上述结果，给scRNA增添celltype注释信息scRNA@meta.data$celltype = &quot;NA&quot;#先新增列celltype，值均为NA，然后利用下一行代码循环填充for(i in 1:nrow(celltype))&#123; scRNA@meta.data[which(scRNA@meta.data$seurat_clusters == celltype$ClusterID[i]),&#x27;celltype&#x27;] &lt;- celltype$celltype[i]&#125;p1 &lt;- DimPlot(scRNA, group.by=&quot;celltype&quot;, label=F , reduction=&#x27;tsne&#x27;)ggsave(&quot;../../out/3.3celltype_anno.pdf&quot;, plot = p1, width = 18, height = 12) 细胞类型注释","tags":"bioinformatics scrnaseq"},{"title":"生信技能树单细胞数据挖掘笔记(3)","url":"/2020/10/29/2020-10-29-ScRNAseq(9)/","text":"生信技能树单细胞数据挖掘笔记(1)：数据读入 生信技能树单细胞数据挖掘笔记(2)：创建Seurat对象并进行质控、筛选高变基因并可视化 生信技能树单细胞数据挖掘笔记(3)：降维与聚类 生信技能树单细胞数据挖掘笔记(4)：其他分析（周期判断、double诊断、细胞类型注释） 生信技能树单细胞数据挖掘笔记(5)：轨迹分析 生信技能树单细胞数据挖掘笔记(6)：差异分析(1) 生信技能树单细胞数据挖掘笔记(7)：差异分析(2) 降维，PCA分析1234567891011121314151617181920212223load(&quot;../2.3.Rdata&quot;)### 4、降维，PCA分析，可视化----#先进行归一化（正态分布）scRNA &lt;- ScaleData(scRNA, features = (rownames(scRNA)))#储存到&quot;scale.data&quot;的slot里GetAssayData(scRNA,slot=&quot;scale.data&quot;,assay=&quot;RNA&quot;)[1:8,1:4]#对比下原来的count矩阵GetAssayData(scRNA,slot=&quot;counts&quot;,assay=&quot;RNA&quot;)[1:8,1:4]#scRNA@assays$RNA@#PCA降维，利用之前挑选的hvg，可提高效率scRNA &lt;- RunPCA(scRNA, features = VariableFeatures(scRNA))#挑选第一，第二主成分对cell可视化DimPlot(scRNA, reduction = &quot;pca&quot;, group.by=&quot;Patient_ID&quot;)#发现与原文献中颠倒了#seed.use :Set a random seed. By default, sets the seed to 42.#Setting NULL will not set a seed.scRNA &lt;- RunPCA(scRNA, features = VariableFeatures(scRNA),seed.use=3)#尝试了seed.use的不同取值发现图形只有四种变化（四个拐角），其中以seed.use=3为代表的一类与原文文献一致DimPlot(scRNA, reduction = &quot;pca&quot;, group.by=&quot;Patient_ID&quot;)#与文献一致了。个人觉得颠倒与否如果只是随机种子的差别的话，对后续分析应该没影响p2_1 &lt;- DimPlot(scRNA, reduction = &quot;pca&quot;, group.by=&quot;Patient_ID&quot;)+ labs(tag = &quot;D&quot;)p2_1 原图 seed.use=3后的PCA图 12345678910#挑选主成分，RunPCA默认保留了前50个scRNA &lt;- JackStraw(scRNA,reduction = &quot;pca&quot;, dims=20)scRNA &lt;- ScoreJackStraw(scRNA,dims = 1:20)p2_2 &lt;- JackStrawPlot(scRNA,dims = 1:20, reduction = &quot;pca&quot;) + theme(legend.position=&quot;bottom&quot;) + labs(tag = &quot;E&quot;)p2_2p2_3 &lt;- ElbowPlot(scRNA, ndims=20, reduction=&quot;pca&quot;)p2_2 | p2_3 E图 D图与E图 聚类、筛选maker基因并可视化聚类123456789101112pc.num=1:20#基于PCA数据scRNA &lt;- FindNeighbors(scRNA, dims = pc.num)# dims参数，需要指定哪些pc轴用于分析；这里利用上面的分析，选择20scRNA &lt;- FindClusters(scRNA, resolution = 0.5)table(scRNA@meta.data$seurat_clusters)scRNA = RunTSNE(scRNA, dims = pc.num)DimPlot(scRNA, reduction = &quot;tsne&quot;,label=T)p3_1 &lt;- DimPlot(scRNA, reduction = &quot;tsne&quot;,label=T) + labs(tag = &quot;E&quot;)p3_1 F图 筛选maker基因123456789101112131415161718192021222324252627282930#5.2 marker gene#进行差异分析，一般使用标准化数据scRNA &lt;- NormalizeData(scRNA, normalization.method = &quot;LogNormalize&quot;)#结果储存在&quot;data&quot;slot里GetAssayData(scRNA,slot=&quot;data&quot;,assay=&quot;RNA&quot;)[1:8,1:4]#if test.use is &quot;negbinom&quot;, &quot;poisson&quot;, or &quot;DESeq2&quot;, slot will be set to &quot;countsdiff.wilcox = FindAllMarkers(scRNA)##默认使用wilcox方法挑选差异基因，大概4-5minload(&quot;../diff.wilcox.Rdata&quot;)head(diff.wilcox)dim(diff.wilcox)library(tidyverse)all.markers = diff.wilcox %&gt;% select(gene, everything()) %&gt;% subset(p_val&lt;0.05 &amp; abs(diff.wilcox$avg_logFC) &gt; 0.5)#An adjusted P value &lt; 0.05and | log 2 [fold change (FC)] | &gt; 0.5#were considered the 2 cutoff criteria for identifying marker genes.dim(all.markers)summary(all.markers)save(all.markers,file = &quot;../markergene.Rdata&quot;)top10 = all.markers %&gt;% group_by(cluster) %&gt;% top_n(n = 10, wt = avg_logFC)top10top10 = CaseMatch(search = as.vector(top10$gene), match = rownames(scRNA))top10length(top10)length(unique(sort(top10)))p3_2 &lt;- DoHeatmap(scRNA, features = top10, group.by = &quot;seurat_clusters&quot;)p3_2p3_1 | p3_2 #下图 G图 图片合并 目前，图一的图片已经全部完成，接下来将进行拼图 拼图1234567### 6、拼图，比较----p &lt;- (p1_1 | p1_2 | p1_3 ) / ((p2_1| p2_2 | p2_3) / (p3_1 | p3_2))ggsave(&quot;../.my_try.pdf&quot;, plot = p, width = 15, height = 18)save(scRNA,file = &quot;scRNA.Rdata&quot;)","tags":"bioinformatics scrnaseq"},{"title":"生信技能树单细胞数据挖掘笔记(2)","url":"/2020/10/27/2020-10-27-ScRNAseq(8)/","text":"生信技能树单细胞数据挖掘笔记(1)：数据读入 生信技能树单细胞数据挖掘笔记(2)：创建Seurat对象并进行质控、筛选高变基因并可视化 生信技能树单细胞数据挖掘笔记(3)：降维与聚类 生信技能树单细胞数据挖掘笔记(4)：其他分析（周期判断、double诊断、细胞类型注释） 生信技能树单细胞数据挖掘笔记(5)：轨迹分析 生信技能树单细胞数据挖掘笔记(6)：差异分析(1) 生信技能树单细胞数据挖掘笔记(7)：差异分析(2) 创建Seurat对象并质控创建Seurat对象，然后过滤掉表达量过低的基因、表达基因过少的细胞以及线粒体基因过多的细胞 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576### 2、构建seurat对象，质控绘图----# 2.1 构建seurat对象，质控#In total, 2,343 cells from tumor cores were included in this analysis.#quality controlstandards:#1) genes detected in &lt; 3 cells were excluded; 筛选基因#2) cells with &lt; 50 total detected genes were excluded; 筛选细胞#3) cells with ≥ 5% of mitochondria-expressed genes were excluded. 筛选细胞library(&quot;Seurat&quot;)sce.meta &lt;- data.frame(Patient_ID=group$Patient_ID, row.names = group$sample)head(sce.meta)table(sce.meta$Patient_ID)# 这个函数 CreateSeuratObject 有多种多样的执行方式scRNA = CreateSeuratObject(counts=a.filt, meta.data = sce.meta, min.cells = 3, min.features = 50)#counts:a matrix-like object with unnormalized data with cells as columns and features as rows#meta.data:Additional cell-level metadata to add to the Seurat object#min.cells: features detected in at least this many cells.#min.features:cells where at least this many features are detected.head(scRNA@meta.data)#nCount_RNA：the number of cell total counts#nFeature_RNA：the number of cell&#x27;s detected genesummary(scRNA@meta.data)scRNA@assays$RNA@counts[1:4,1:4]# 可以看到，之前的counts矩阵存储格式发生了变化：4 x 4 sparse Matrix of class &quot;dgCMatrix&quot;dim(scRNA)# 20047 2342 仅过滤掉一个细胞#接下来根据线粒体基因表达筛选低质量细胞#Calculate the proportion of transcripts mapping to mitochondrial genestable(grepl(&quot;^MT-&quot;,rownames(scRNA)))#FALSE#20050 没有染色体基因scRNA[[&quot;percent.mt&quot;]] &lt;- PercentageFeatureSet(scRNA, pattern = &quot;^MT-&quot;)head(scRNA@meta.data)summary(scRNA@meta.data)#结果显示没有线粒体基因，因此这里过滤也就没有意义，但是代码留在这里# 万一大家的数据里面有线粒体基因，就可以如此这般进行过滤啦。pctMT=5 #≥ 5% of mitochondria-expressed genesscRNA &lt;- subset(scRNA, subset = percent.mt &lt; pctMT)dim(scRNA)table(grepl(&quot;^ERCC-&quot;,rownames(scRNA)))#FALSE TRUE#19961 86 发现是有ERCC基因#External RNA Control Consortium，是常见的已知浓度的外源RNA分子spike-in的一种#指标含义类似线粒体含量，ERCC含量大，则说明total sum变小scRNA[[&quot;percent.ERCC&quot;]] &lt;- PercentageFeatureSet(scRNA, pattern = &quot;^ERCC-&quot;)head(scRNA@meta.data)summary(scRNA@meta.data)rownames(scRNA)[grep(&quot;^ERCC-&quot;,rownames(scRNA))][1] &quot;ERCC-00002&quot; &quot;ERCC-00003&quot; &quot;ERCC-00004&quot; &quot;ERCC-00009&quot; &quot;ERCC-00012&quot; &quot;ERCC-00013&quot; &quot;ERCC-00014&quot; &quot;ERCC-00017&quot; &quot;ERCC-00019&quot; &quot;ERCC-00022&quot; &quot;ERCC-00024&quot; &quot;ERCC-00025&quot;[13] &quot;ERCC-00028&quot; &quot;ERCC-00031&quot; &quot;ERCC-00033&quot; &quot;ERCC-00034&quot; &quot;ERCC-00035&quot; &quot;ERCC-00039&quot; &quot;ERCC-00040&quot; &quot;ERCC-00041&quot; &quot;ERCC-00042&quot; &quot;ERCC-00043&quot; &quot;ERCC-00044&quot; &quot;ERCC-00046&quot;[25] &quot;ERCC-00051&quot; &quot;ERCC-00053&quot; &quot;ERCC-00054&quot; &quot;ERCC-00058&quot; &quot;ERCC-00059&quot; &quot;ERCC-00060&quot; &quot;ERCC-00062&quot; &quot;ERCC-00067&quot; &quot;ERCC-00069&quot; &quot;ERCC-00071&quot; &quot;ERCC-00073&quot; &quot;ERCC-00074&quot;[37] &quot;ERCC-00076&quot; &quot;ERCC-00077&quot; &quot;ERCC-00078&quot; &quot;ERCC-00079&quot; &quot;ERCC-00081&quot; &quot;ERCC-00083&quot; &quot;ERCC-00084&quot; &quot;ERCC-00085&quot; &quot;ERCC-00086&quot; &quot;ERCC-00092&quot; &quot;ERCC-00095&quot; &quot;ERCC-00096&quot;[49] &quot;ERCC-00097&quot; &quot;ERCC-00098&quot; &quot;ERCC-00099&quot; &quot;ERCC-00104&quot; &quot;ERCC-00108&quot; &quot;ERCC-00109&quot; &quot;ERCC-00111&quot; &quot;ERCC-00112&quot; &quot;ERCC-00113&quot; &quot;ERCC-00116&quot; &quot;ERCC-00120&quot; &quot;ERCC-00123&quot;[61] &quot;ERCC-00126&quot; &quot;ERCC-00130&quot; &quot;ERCC-00131&quot; &quot;ERCC-00134&quot; &quot;ERCC-00136&quot; &quot;ERCC-00137&quot; &quot;ERCC-00138&quot; &quot;ERCC-00142&quot; &quot;ERCC-00143&quot; &quot;ERCC-00144&quot; &quot;ERCC-00145&quot; &quot;ERCC-00147&quot;[73] &quot;ERCC-00148&quot; &quot;ERCC-00150&quot; &quot;ERCC-00154&quot; &quot;ERCC-00156&quot; &quot;ERCC-00157&quot; &quot;ERCC-00158&quot; &quot;ERCC-00160&quot; &quot;ERCC-00162&quot; &quot;ERCC-00163&quot; &quot;ERCC-00164&quot; &quot;ERCC-00165&quot; &quot;ERCC-00168&quot;[85] &quot;ERCC-00170&quot; &quot;ERCC-00171&quot;#可以看到有不少ERCC基因sum(scRNA$percent.ERCC&lt; 40)#较接近原文过滤数量2149，但感觉条件有点宽松了，先做下去看看#网上看了相关教程，一般ERCC占比不高于10%sum(scRNA$percent.ERCC&lt; 10) #就只剩下460个cell，明显低于文献中的数量pctERCC=40scRNA &lt;- subset(scRNA, subset = percent.ERCC &lt; pctERCC)dim(scRNA)# 20047 2142 原文为19752 2149dim(a.filt)#23460 2343 未过滤前 质控绘图12345678910111213141516171819202122232425262728# 2.2 可视化#图A：观察不同组cell的counts、feature分布col.num &lt;- length(unique(scRNA@meta.data$Patient_ID))library(ggplot2)p1_1.1 &lt;- VlnPlot(scRNA, features = c(&quot;nFeature_RNA&quot;), group.by = &quot;Patient_ID&quot;, cols =rainbow(col.num)) + theme(legend.position = &quot;none&quot;) + labs(tag = &quot;A&quot;)p1_1.1p1_1.2 &lt;- VlnPlot(scRNA, features = c(&quot;nCount_RNA&quot;), group.by = &quot;Patient_ID&quot;, cols =rainbow(col.num)) + theme(legend.position = &quot;none&quot;)p1_1.2p1_1 &lt;- p1_1.1 | p1_1.2p1_1VlnPlot(scRNA, features = c(&quot;nFeature_RNA&quot;,&quot;nCount_RNA&quot;,&quot;percent.ERCC&quot;))#图B：nCount_RNA与对应的nFeature_RNA关系p1_2 &lt;- FeatureScatter(scRNA, feature1 = &quot;nCount_RNA&quot;, feature2 = &quot;nFeature_RNA&quot;, group.by = &quot;Patient_ID&quot;,pt.size = 1.3) + labs(tag = &quot;B&quot;)p1_2FeatureScatter(scRNA, feature1 = &quot;nCount_RNA&quot;, feature2 = &quot;percent.ERCC&quot;) p1_1 ![image-20201107134732184](/img/posts/2020.10.27/image-20201107134732184.png) p1_2 目前已经完成了文献中的fig1A、B 挑选高变基因12345678910111213### 3、挑选hvg基因，可视化----#highly Variable gene:简单理解sd大的scRNA &lt;- FindVariableFeatures(scRNA, selection.method = &quot;vst&quot;, nfeatures = 1500)#根据文献原图，挑选变化最大的1500个hvgtop10 &lt;- head(VariableFeatures(scRNA), 10)top10plot1 &lt;- VariableFeaturePlot(scRNA)#标记top10 hvgp1_3 &lt;- LabelPoints(plot = plot1, points = top10, repel = TRUE, size=2.5) + theme(legend.position = c(0.1,0.8)) + labs(tag = &quot;C&quot;)p1_3save(scRNA, file=&quot;2.3.Rdata&quot;) p1_3 目前已复现文献中的图1A到C。","tags":"bioinformatics scrnaseq"},{"title":"生信技能树单细胞数据挖掘笔记(1)","url":"/2020/10/24/2020-10-24-ScRNAseq(7)/","text":"前言最近有幸加入生信技能树的单细胞数据挖掘尝鲜群,借此机会给大家分享一下 生信技能树单细胞数据挖掘笔记(1)：数据读入 生信技能树单细胞数据挖掘笔记(2)：创建Seurat对象并进行质控、筛选高变基因并可视化 生信技能树单细胞数据挖掘笔记(3)：降维与聚类 生信技能树单细胞数据挖掘笔记(4)：其他分析（周期判断、double诊断、细胞类型注释） 生信技能树单细胞数据挖掘笔记(5)：轨迹分析 生信技能树单细胞数据挖掘笔记(6)：差异分析(1) 生信技能树单细胞数据挖掘笔记(7)：差异分析(2) 课程大纲 入门基础知识 所需R包 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263getOption(&quot;BioC_mirror&quot;)getOption(&quot;CRAN&quot;)#CRAN基础包options(CRAN=&quot;https://mirrors.ustc.edu.cn/CRAN/&quot;)## 设置镜像cran_packages &lt;- c(&#x27;tidyverse&#x27;, &#x27;ggplot2&#x27; )for (pkg in cran_packages)&#123; if (! require(pkg,character.only=T) ) &#123; install.packages(pkg,ask = F,update = F) require(pkg,character.only=T) &#125;&#125;if(!require(&quot;BiocManager&quot;)) install.packages(&quot;BiocManager&quot;,update = F,ask = F)#Bio分析包Biocductor_packages &lt;- c(&quot;Seurat&quot;, &quot;scran&quot;, &quot;scater&quot;, &quot;monocle&quot;, &quot;DropletUtils&quot;, &quot;SingleR&quot; )options(BioC_mirror=&quot;https://mirrors.ustc.edu.cn/bioc/&quot;)#options(BioC_mirror=&quot;https://mirrors.tuna.tsinghua.edu.cn/bioconductor&quot;)# use BiocManager to installfor (pkg in Biocductor_packages)&#123; if (! require(pkg,character.only=T) ) &#123; BiocManager::install(pkg,ask = F,update = F) require(pkg,character.only=T) &#125;&#125;#最后检查下成功与否for (pkg in c(Biocductor_packages,cran_packages))&#123; require(pkg,character.only=T)&#125;### GEO## GEO Platform (GPL)# GEO Sample (GSM)# GEO Series (GSE)# GEO Dataset (GDS)#一篇文章可以有一个或者多个GSE数据集，一个GSE里面可以有一个或者多个GSM样本。#多个研究的GSM样本可以根据研究目的整合为一个GDS，不过GDS本身用的很少。#而每个数据集都有着自己对应的芯片平台，就是GPL。(芯片名与基因名ID转换)#https://blog.csdn.net/weixin_43569478/article/details/108079337# https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=BiocManager::install(&quot;GEOquery&quot;)library(GEOquery)gse1009 &lt;- getGEO(&#x27;GSE1009&#x27;, destdir=&quot;.&quot;)class(gse1009)length(gse1009)a &lt;- gse1009[[1]]class(gse1009[1])ab &lt;- exprs(a)c &lt;- pData(a)a$platform_id 下载、探索、数据整理本次数据采用《Glioblastoma cell differentiation trajectory predicts the immunotherapy response and overall survival of patients》中的单细胞数据进行分析（GSE号：84465） 1234### 1、下载、探索、整理数据----## 1.1 下载、探索数据#https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE84465 ## 数据来源sessionInfo() 读取数据12345678910111213141516171819202122232425a &lt;- read.table(&quot;../rawdata/GSE84465_GBM_All_data.csv.gz&quot;)a[1:4,1:4]#行名为symbol ID#列名为sample，看上去像是两个元素的组合。summary(a[,1:4])boxplot(a[,1:4])head(rownames(a))tail(rownames(a),10)# 可以看到原文的counts矩阵来源于htseq这个计数软件，所以有一些不是基因的行需要剔除：# &quot;no_feature&quot; &quot;ambiguous&quot; &quot;too_low_aQual&quot; &quot;not_aligned&quot; &quot;alignment_not_unique&quot;tail(a[,1:4],10)a=a[1:(nrow(a)-5),]#原始counts数据#3,589 cells of 4 human primary GBM samples, accession number GSE84465#2,343 cells from tumor cores and 1,246 cells from peripheral regionsb &lt;- read.table(&quot;../rawdata/SraRunTable.txt&quot;, sep = &quot;,&quot;, header = T)b[1:4,1:4]table(b$Patient_ID) # 4 human primary GBM samplestable(b$TISSUE) # tumor cores and peripheral regionstable(b$TISSUE,b$Patient_ID) 整理数据可以发现两个数据不对应，a矩阵行名（sample）并非为GSM编号，而主要是由相应的plate_id与Well组合而成 1234567891011121314151617181920212223242526272829303132## 1.2 整理数据# tumor and peripheral 分组信息head(colnames(a))[1] &quot;X1001000173.G8&quot; &quot;X1001000173.D4&quot; &quot;X1001000173.B4&quot; &quot;X1001000173.A2&quot; &quot;X1001000173.E2&quot; &quot;X1001000173.F6&quot;head(b$plate_id)[1] 1001000173 1001000173 1001000173 1001000173 1001000173 1001000173head(b$Well)#a矩阵行名（sample）并非为GSM编号，而主要是由相应的plate_id与Well组合而成b.group &lt;- b[,c(&quot;plate_id&quot;,&quot;Well&quot;,&quot;TISSUE&quot;,&quot;Patient_ID&quot;)]b.group$sample &lt;- paste0(&quot;X&quot;,b.group$plate_id,&quot;.&quot;,b.group$Well)head(b.group) plate_id Well TISSUE Patient_ID sample1 1001000173 G8 Tumor BT_S2 X1001000173.G82 1001000173 D4 Tumor BT_S2 X1001000173.D43 1001000173 B4 Tumor BT_S2 X1001000173.B44 1001000173 A2 Tumor BT_S2 X1001000173.A25 1001000173 E2 Tumor BT_S2 X1001000173.E26 1001000173 F6 Tumor BT_S2 X1001000173.F6identical(colnames(a),b.group$sample)# 筛选tumor cellindex &lt;- which(b.group$TISSUE==&quot;Tumor&quot;)length(index)group &lt;- b.group[index,] #筛选的是行head(group)a.filt &lt;- a[,index] #筛选的是列dim(a.filt)identical(colnames(a.filt),group$sample) 经过筛选之后得到所有的肿瘤细胞的表达矩阵","tags":"bioinformatics scrnaseq"},{"title":"单细胞实战(5)：复现文章中的聚类图（2）","url":"/2020/10/13/2020-10-13-ScRNAseq(6)/","text":"前言之前对拟南芥单细胞测序的文献数据进行复现，数据结果有点微妙，接下来进行拟时间分析 分生组织伪时间分析作者首先查看了分生组织相关基因（WOX5,PIN1,RGF3,PLT1）在聚类中的表达情况，WOX5和PIN1主要在cluster12中表达，RGF3以及PLT1主要在cluster19中表达，对应到自己的数据中查看效果 1234pdf(&quot;cell_identify/meristematic.pdf&quot;,height = 14,width = 14)FeaturePlot(wang,features=c(&#x27;AT3G11260&#x27;,&#x27;AT1G73590&#x27;,&#x27;AT2G04025&#x27;,&#x27;AT3G20840&#x27;),cols=c(&quot;grey&quot;,&quot;yellow&quot;,&quot;red&quot;,&quot;brown&quot;) ,reduction = &#x27;umap&#x27;,pt.size = 1,label.size = 4)dev.off() 可以看到对应效果还是不错的，接下来选择cluster12.14.19进行伪时间分析 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849id&lt;-c(&quot;12&quot;,&quot;14&quot;,&quot;19&quot;)cell.sub &lt;- subset(wang@meta.data,seurat_clusters==id)scRNAsub &lt;- subset(wang, cells=row.names(cell.sub))dim(scRNAsub)library(monocle)dir.create(&quot;pseudotime121419&quot;)data &lt;- as(as.matrix(scRNAsub@assays$RNA@counts), &#x27;sparseMatrix&#x27;)pd &lt;- new(&#x27;AnnotatedDataFrame&#x27;, data = scRNAsub@meta.data)fData &lt;- data.frame(gene_short_name = row.names(data), row.names = row.names(data))fd &lt;- new(&#x27;AnnotatedDataFrame&#x27;, data = fData)mycds &lt;- newCellDataSet(data, phenoData = pd, featureData = fd, expressionFamily = negbinomial.size())mycds &lt;- estimateSizeFactors(mycds)mycds &lt;- estimateDispersions(mycds, cores=4, relative_expr = TRUE)## 选择代表性基因##使用monocle选择的高变基因disp_table &lt;- dispersionTable(mycds)disp.genes &lt;- subset(disp_table, mean_expression &gt;= 0.1 &amp; dispersion_empirical &gt;= 1 * dispersion_fit)$gene_idmycds &lt;- setOrderingFilter(mycds, disp.genes)## 降维以及细胞排序#降维mycds &lt;- reduceDimension(mycds, max_components = 2, method = &#x27;DDRTree&#x27;)#排序mycds &lt;- orderCells(mycds)#State轨迹分布图plot1 &lt;- plot_cell_trajectory(mycds, color_by = &quot;State&quot;)ggsave(&quot;pseudotime121419/State.pdf&quot;, plot = plot1, width = 6, height = 5)ggsave(&quot;pseudotime121419/State.png&quot;, plot = plot1, width = 6, height = 5)##Cluster轨迹分布图plot2 &lt;- plot_cell_trajectory(mycds, color_by = &quot;seurat_clusters&quot;)ggsave(&quot;pseudotime121419/Cluster.pdf&quot;, plot = plot2, width = 6, height = 5)ggsave(&quot;pseudotime121419/Cluster.png&quot;, plot = plot2, width = 6, height = 5)##Pseudotime轨迹图plot3 &lt;- plot_cell_trajectory(mycds, color_by = &quot;Pseudotime&quot;)ggsave(&quot;pseudotime121419/Pseudotime.pdf&quot;, plot = plot3, width = 6, height = 5)ggsave(&quot;pseudotime121419/Pseudotime.png&quot;, plot = plot3, width = 6, height = 5)##合并作图plotc &lt;- plot1|plot2|plot3ggsave(&quot;pseudotime121419/Combination.pdf&quot;, plot = plotc, width = 10, height = 3.5)ggsave(&quot;pseudotime121419/Combination.png&quot;, plot = plotc, width = 10, height = 3.5)##保存结果write.csv(pData(mycds), &quot;pseudotime121419/pseudotime.csv&quot;)p1 &lt;- plot_cell_trajectory(mycds, color_by = &quot;State&quot;) + facet_wrap(~State, nrow = 1)p2 &lt;- plot_cell_trajectory(mycds, color_by = &quot;seurat_clusters&quot;) + facet_wrap(~seurat_clusters, nrow = 1)plotc &lt;- p1/p2ggsave(&quot;pseudotime121419/trajectory_facet.png&quot;, plot = plotc, width = 6, height = 5) 结果也与文献中的有点出入，接下来查看一下BEAM热图和一些基因在轨迹中的表达情况 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061##BEAM分析disp_table &lt;- dispersionTable(mycds)disp.genes &lt;- subset(disp_table, mean_expression &gt;= 0.5&amp;dispersion_empirical &gt;= 1*dispersion_fit)disp.genes &lt;- as.character(disp.genes$gene_id)mycds_sub &lt;- mycds[disp.genes,]#State轨迹分布图plot1 &lt;- plot_cell_trajectory(mycds_sub, color_by = &quot;State&quot;)ggsave(&quot;pseudotime121419/BEAM_State.pdf&quot;, plot = plot1, width = 6, height = 5)ggsave(&quot;pseudotime121419/BEAM_State.png&quot;, plot = plot1, width = 6, height = 5)##Cluster轨迹分布图plot2 &lt;- plot_cell_trajectory(mycds_sub, color_by = &quot;seurat_clusters&quot;)ggsave(&quot;pseudotime121419/BEAM_Cluster.pdf&quot;, plot = plot2, width = 6, height = 5)ggsave(&quot;pseudotime121419/BEAM_Cluster.png&quot;, plot = plot2, width = 6, height = 5)##Pseudotime轨迹图plot3 &lt;- plot_cell_trajectory(mycds_sub, color_by = &quot;Pseudotime&quot;)ggsave(&quot;pseudotime121419/BEAM_Pseudotime.pdf&quot;, plot = plot3, width = 6, height = 5)ggsave(&quot;pseudotime121419/BEAM_Pseudotime.png&quot;, plot = plot3, width = 6, height = 5)##合并作图plotc &lt;- plot1|plot2|plot3ggsave(&quot;pseudotime121419/BEAM_Combination.pdf&quot;, plot = plotc, width = 10, height = 3.5)ggsave(&quot;pseudotime121419/BEAM_Combination.png&quot;, plot = plotc, width = 10, height = 3.5)##保存结果beam_res &lt;- BEAM(mycds_sub, branch_point = 1, cores = 8)beam_res &lt;- beam_res[order(beam_res$qval),]beam_res &lt;- beam_res[,c(&quot;gene_short_name&quot;, &quot;pval&quot;, &quot;qval&quot;)]mycds_sub_beam &lt;- mycds_sub[row.names(subset(beam_res, qval &lt; 1e-4)),]pdf(&quot;pseudotime121419/BEAM_pseudotime_heatmap2.pdf&quot;,width = 10, height = 10)plot_genes_branched_heatmap(mycds_sub_beam, branch_point = 1, num_clusters = 5, show_rownames = F)dev.off()##寻找相应的基因绘制轨迹图matrix_dir=&quot;filtered_gene_bc_matrices/ref/&quot;barcode.path &lt;- paste0(matrix_dir,&quot;barcodes.tsv&quot;)features.path &lt;- paste0(matrix_dir,&quot;genes.tsv&quot;)matrix.path &lt;- paste0(matrix_dir, &quot;matrix.mtx&quot;)mat1 &lt;- readMM(file = matrix.path)feature.names = read.delim(features.path, header = FALSE, stringsAsFactors = FALSE)barcode.names = read.delim(barcode.path, header = FALSE, stringsAsFactors = FALSE)colnames(mat1) = barcode.names$V1rownames(mat1) = feature.names$V1mat1&lt;-as.matrix(mat1)gene&lt;-t(as.matrix(mat1[c(&#x27;AT3G11260&#x27;,&#x27;AT1G73590&#x27;, &#x27;AT2G04025&#x27;,&#x27;AT3G20840&#x27;,&#x27;AT1G50490&#x27;), colnames(scRNAsub@assays$RNA@counts)]))colnames(gene)&lt;-c(&quot;WOX5&quot;,&quot;PIN1&quot;,&quot;RGF3&quot;,&quot;PLT1&quot;,&quot;UBC20&quot;)mycds_sub@phenoData@data&lt;-cbind(mycds_sub@phenoData@data,gene)mycds_sub@phenoData@data[mycds_sub@phenoData@data == 0] &lt;- NAp1&lt;-plot_cell_trajectory(mycds_sub, color_by = &quot;WOX5&quot;)+scale_color_gradient(na.value = &quot;grey&quot;,low=&quot;yellow&quot;,high=&quot;red&quot;)p2&lt;-plot_cell_trajectory(mycds_sub, color_by = &quot;PIN1&quot;)+scale_color_gradient(na.value = &quot;grey&quot;,low=&quot;yellow&quot;,high=&quot;red&quot;)p3&lt;-plot_cell_trajectory(mycds_sub, color_by = &quot;RGF3&quot;)+scale_color_gradient(na.value = &quot;grey&quot;,low=&quot;yellow&quot;,high=&quot;red&quot;)p4&lt;-plot_cell_trajectory(mycds_sub, color_by = &quot;PLT1&quot;)+scale_color_gradient(na.value = &quot;grey&quot;,low=&quot;yellow&quot;,high=&quot;red&quot;)p5&lt;-plot_cell_trajectory(mycds_sub, color_by = &quot;UBC20&quot;)+scale_color_gradient(na.value = &quot;grey&quot;,low=&quot;yellow&quot;,high=&quot;red&quot;)plotc &lt;- p1|p2|p3|p4|p5ggsave(&quot;pseudotime121419/meristematic.pdf&quot;, plot = plotc, width = 18, height = 5)ggsave(&quot;pseudotime121419/meristematic.png&quot;, plot = plotc, width = 18, height = 5) 文献中没有给出相应的参数，结果还是与文献的结果有点差距 root cap伪时间分析按照相同的方式对root cap组织进行伪时间分析 结语对于此次的数据复现，前面的聚类步骤还是能与文献对应，但是后续的伪时间分析差距就有点大了，主要是因为拟时间分析我才刚刚入门学习，对一些分析过程中的参数不太了解，目前的数据与代码我已上传github ，欢迎大家批评指正","tags":"bioinformatics scrnaseq"},{"title":"单细胞实战(5)：复现文章中的聚类图（1）","url":"/2020/10/10/2020-10-10-ScRNAseq(5)/","text":"前言目前我的课题是植物方面的单细胞测序，所以打算选择植物类的单细胞测序数据进行复现，目前选择了王佳伟老师的《A Single-Cell RNA Sequencing Profiles the Developmental Landscape of Arabidopsis Root》，希望能够得到好的结果 原始数据的下载首先下载测序数据 12345prefetch SRR8485805 -O wang/fastq-dump --split-files SRR8485805mv SRR8485805_1.fastq data/WT_S1_L001_I1_001.fastqmv SRR8485805_2.fastq data/WT_S1_L001_R1_001.fastqmv SRR8485805_3.fastq data/WT_S1_L001_R2_001.fastq 下载基因组与注释文件，需要注意文献中基因组使用的是TAIR10，注释文件是Araport11。 将gff转为gtf文件 1gffread Araport11.gff3 -T -o Araport11.gtf cellranger进行比对下载cellranger2.2版本 12curl -o cellranger-2.2.0.tar.gz &quot;https://cf.10xgenomics.com/releases/cell-exp/cellranger-2.2.0.tar.gz?Expires=1603141363&amp;Policy=eyJTdGF0ZW1lbnQiOlt7IlJlc291cmNlIjoiaHR0cHM6Ly9jZi4xMHhnZW5vbWljcy5jb20vcmVsZWFzZXMvY2VsbC1leHAvY2VsbHJhbmdlci0yLjIuMC50YXIuZ3oiLCJDb25kaXRpb24iOnsiRGF0ZUxlc3NUaGFuIjp7IkFXUzpFcG9jaFRpbWUiOjE2MDMxNDEzNjN9fX1dfQ__&amp;Signature=en6P4Wedmwc2aSEitfKsQp2PITVYKgRPZdzR-fEmjBl4R9yQY5QBQY05--1v8AzRD9WqfoCnddSzFvngrlwxzeCJtFyfHLa2a7ONnUT6NtrzU6RkIj1jwXpaN4NpixnCbEF-Ubj9UZX63W1rEreM0AMNdWiVneGx4bcTajl1KRWaoTNS970DSJ1wrw0g70JFQ0BAltou-qPAeZpD9Xe9EM35EdWRT6eFq~zOaCMRLTxlBjZaMItyDRH~Qecz-B5tLWcAjCKfy4o2hAWTopRRpy93LVV-x1ykxCiHpej5AuAODvUx0V73rZOkRlijcpA5d1rHV~eEdPiM1uoCOJMiSw__&amp;Key-Pair-Id=APKAI7S6A5RYOXBWRPDA&quot;tar -zxvf cellranger-2.2.0.tar.gz 建立索引并比对 123/datadisk02/ScRNAseq_data/cellranger-2.2.0/cellranger mkref --genome=ref --fasta=TAIR10.fa --genes=Araport11.gtf/datadisk02/ScRNAseq_data/cellranger-2.2.0/cellranger count --id=WANG --transcriptome=ref --fastqs=data/ --sample=WT --force-cells=8000 比对结果还是可以的，与原文献中差距很小 使用Seurat对数据进行分析文献中使用到的Seurat为V3版本，要注意cellrangeV2在filtered_gene_bc_matrices生成的文件是genes、barcodes以及matrix，但Seurat识别的是features，我们需要自行对genes文件改名 12345cd WANG/outs/filtered_gene_bc_matrices/refgzip genes.tsvgzip matrix.mtxgzip barcodes.tsvmv genes.tsv.gz features.tsv.gz 创建Seurat对象12345678910111213141516library(Seurat)library(dplyr)library(ggplot2)library(magrittr)library(gtools)library(stringr)library(Matrix)library(tidyverse)library(patchwork)setwd(&quot;D://data/ScRNAcode/wang/&quot;)##=======================1.创建Seurat对象========================dir &lt;- &#x27;filtered_gene_bc_matrices/ref/&#x27;counts &lt;- Read10X(dir)wang = CreateSeuratObject(counts, project = &quot;zxz&quot;, min.cells=3, min.features = 200)dim(wang)[1] 23228 8000 数据质控与标准化123456789101112131415161718192021222324252627282930##=======================2.数据质控与标准化================================##dir.create(&#x27;QC&#x27;)##提取线粒体基因wang[[&quot;percent.mt&quot;]] &lt;- PercentageFeatureSet(wang, pattern=&#x27;^ATMG&#x27;)violin &lt;- VlnPlot(wang, features = c(&quot;nFeature_RNA&quot;, &quot;nCount_RNA&quot;, &quot;percent.mt&quot;), pt.size = 0.1, #不需要显示点，可以设置pt.size = 0 ncol = 3)ggsave(&quot;QC/vlnplot-before-qc.pdf&quot;, plot = violin, width = 15, height = 6)ggsave(&quot;QC/vlnplot-before-qc.png&quot;, plot = violin, width = 15, height = 6)plot1 &lt;- FeatureScatter(wang, feature1 = &quot;nCount_RNA&quot;, feature2 = &quot;percent.mt&quot;)plot2 &lt;- FeatureScatter(wang, feature1 = &quot;nCount_RNA&quot;, feature2 = &quot;nFeature_RNA&quot;)pearplot &lt;- CombinePlots(plots = list(plot1, plot2), nrow=1, legend=&quot;none&quot;)ggsave(&quot;QC/pearplot-before-qc.pdf&quot;, plot = pearplot, width = 12, height = 5)ggsave(&quot;QC/pearplot-before-qc.png&quot;, plot = pearplot, width = 12, height = 5)##设置质控标准wang&lt;-subset(wang,subset=nFeature_RNA&gt;500 &amp; nFeature_RNA&lt;5000 &amp;percent.mt&lt;0.5)dim(wang)[1] 23228 7626## 绘制质量控制后的图violin &lt;-VlnPlot(wang, features = c(&quot;nFeature_RNA&quot;, &quot;nCount_RNA&quot;, &quot;percent.mt&quot;), pt.size = 0.1, ncol = 3)ggsave(&quot;QC/vlnplot-after-qc.pdf&quot;, plot = violin, width = 15, height = 6)ggsave(&quot;QC/vlnplot-after-qc.png&quot;, plot = violin, width = 15, height = 6)## 基因表达量标准化## 它的作用是让测序数据量不同的细胞的基因表达量具有可比性。计算公式如下：## 标准化后基因表达量 = log1p（10000*基因counts/细胞总counts）wang &lt;- NormalizeData(wang, normalization.method = &quot;LogNormalize&quot;, scale.factor = 10000) 质控后细胞数目为7626，基因数为23228，原文献中两者的数据分别是7695与23161 数据降维与聚类12345678910111213141516171819202122232425262728293031323334353637383940414243444546##=======================3.数据降维与聚类==================================## 寻找高变基因## dir.create(&quot;cluster&quot;)wang &lt;- FindVariableFeatures(wang,mean.cutoff=c(0.0125,3),dispersion.cutoff =c(1.5,Inf) )top10 &lt;- head(VariableFeatures(wang), 10)plot1 &lt;- VariableFeaturePlot(wang)plot2 &lt;- LabelPoints(plot = plot1, points = top10, repel = TRUE, size=2.5)plot &lt;- CombinePlots(plots = list(plot1, plot2),legend=&quot;bottom&quot;)## 横坐标是某基因在所有细胞中的平均表达值，纵坐标是此基因的方差。## 红色的点是被选中的高变基因，黑色的点是未被选中的基因，变异程度最高的10个基因在如图中标注了基因名称。ggsave(&quot;cluster/VariableFeatures.pdf&quot;, plot = plot, width = 8, height = 6)ggsave(&quot;cluster/VariableFeatures.png&quot;, plot = plot, width = 8, height = 6)## 数据缩放scale.genes &lt;- rownames(wang)wang &lt;- ScaleData(wang, features = scale.genes)## PCA降维并提取主成分wang &lt;- RunPCA(wang, features = VariableFeatures(wang),npcs = 100)plot1 &lt;- DimPlot(wang, reduction = &quot;pca&quot;)plot2 &lt;- ElbowPlot(wang, ndims=40, reduction=&quot;pca&quot;)plotc &lt;- plot1+plot2ggsave(&quot;cluster/pca.pdf&quot;, plot = plotc, width = 8, height = 4)ggsave(&quot;cluster/pca.png&quot;, plot = plotc, width = 8, height = 4)## 细胞聚类## 此步利用 细胞-PC值 矩阵计算细胞之间的距离，## 然后利用距离矩阵来聚类。其中有两个参数需要人工选择，## 第一个是FindNeighbors()函数中的dims参数，需要指定哪些pc轴用于分析，选择依据是之前介绍的cluster/pca.png文件中的右图。## 第二个是FindClusters()函数中的resolution参数，需要指定0.1-1.0之间的一个数值，用于决定clusters的相对数量，数值越大cluters越多。wang &lt;- FindNeighbors(object = wang, dims = 1:100)wang &lt;- FindClusters(object = wang, resolution = 1.0)table(wang@meta.data$seurat_clusters)## 非线性降维## tsnewang &lt;- RunTSNE(wang, dims =1:40)embed_tsne &lt;- Embeddings(wang, &#x27;tsne&#x27;)write.csv(embed_tsne,&#x27;cluster/embed_tsne_new.csv&#x27;)plot1 = DimPlot(wang, reduction = &quot;tsne&quot; ,label = &quot;T&quot;, pt.size = 1,label.size = 4)ggsave(&quot;cluster/tSNE_cluster.pdf&quot;, plot = plot1, width = 8, height = 7)ggsave(&quot;cluster/tSNE_cluster.png&quot;, plot = plot1, width = 8, height = 7)## UMAP&#x27;wang &lt;- RunUMAP(wang,n.neighbors = 30,metric = &#x27;correlation&#x27;,min.dist = 0.3,dims = 1:40)embed_umap &lt;- Embeddings(wang, &#x27;umap&#x27;)write.csv(embed_umap,&#x27;cluster/embed_umap_new.csv&#x27;)plot2 = DimPlot(wang, reduction = &quot;umap&quot;,label = &quot;T&quot;, pt.size = 1,label.size = 4)ggsave(&quot;cluster/UMAP_cluster_new.pdf&quot;, plot = plot2, width = 8, height = 7)ggsave(&quot;cluster/UMAP_cluster_new.png&quot;, plot = plot2, width = 8, height = 7) 结果是有区别的，我的聚类比原文献中要多一个，而且数字不对应，所以我要用文献中列出的某些基因的小提琴图确定我的聚类 根据文献对应自己数据聚类原文献中有所有聚类的特异基因，所以我根据列出的基因去匹配我的聚类结果 12345678910111213141516171819202122##==============================5.修改聚类标号=====================##修改聚类号重新做图new.cluster.ids&lt;-c(&quot;2&quot;,&#x27;1&#x27;,&#x27;4&#x27;,&#x27;5&#x27;,&#x27;13&#x27;,&#x27;3&#x27;,&#x27;12&#x27;,&#x27;21&#x27;,&#x27;8&#x27;,&#x27;6&#x27;,&#x27;11&#x27;, &#x27;9&#x27;,&#x27;7&#x27;,&#x27;10&#x27;,&#x27;6&#x27;,&#x27;15&#x27;,&#x27;22&#x27;,&#x27;14&#x27;,&#x27;17&#x27;,&#x27;19&#x27;,&#x27;16&#x27;, &#x27;20&#x27;,&#x27;18&#x27;,&#x27;23&#x27;,&#x27;24&#x27;)names(new.cluster.ids) &lt;- levels(wang)wang &lt;- RenameIdents(wang, new.cluster.ids)Idents(wang)&lt;-factor(Idents(wang),levels=mixedsort(levels(Idents(wang))))wang &lt;- RunTSNE(wang, dims =1:40)embed_tsne &lt;- Embeddings(wang, &#x27;tsne&#x27;)write.csv(embed_tsne,&#x27;cluster/embed_tsne-new.csv&#x27;)plot1 = DimPlot(wang, reduction = &quot;tsne&quot; ,label = &quot;T&quot;, pt.size = 1,label.size = 4)ggsave(&quot;cluster/tSNE_cluster-new.pdf&quot;, plot = plot1, width = 8, height = 7)ggsave(&quot;cluster/tSNE_cluster-new.png&quot;, plot = plot1, width = 8, height = 7)## UMAPwang &lt;- RunUMAP(wang,n.neighbors = 30,metric = &#x27;correlation&#x27;,min.dist = 0.3,dims = 1:40)embed_umap &lt;- Embeddings(wang, &#x27;umap&#x27;)write.csv(embed_umap,&#x27;cluster/embed_umap-new.csv&#x27;)plot2 = DimPlot(wang, reduction = &quot;umap&quot;,label = &quot;T&quot;, pt.size = 1,label.size = 4)ggsave(&quot;cluster/UMAP_cluster.pdf&quot;, plot = plot2, width = 8, height = 7)ggsave(&quot;cluster/UMAP_cluster.png&quot;, plot = plot2, width = 8, height = 7) 修改之后的聚类结果 一些基因的小提琴图对应效果 结语对于这次的数据重复，基本符合预期结果，和文章的结果有点差距，需要自己进一步研究问题出在哪里，下一次将继续这篇文献的数据复现，主要是伪时间分析，目前的数据与代码我已上传github","tags":"bioinformatics scrnaseq"},{"title":"文献导读：CLAVATA在小立碗藓3D生长中的作用","url":"/2020/10/08/2020-10-08-2Dto3D/","text":"前言小立碗藓登陆后从二维到三维生长决定了陆地植物的生长状态，在这个过程中涉及很多基因的调控，这篇2018年发表在《Current Biology》的文献中具体讲述了CLAVATA在小立碗藓3D生长中的作用。 introduction 土地的征服是通过一系列的创新来实现的，这些创新允许植物形态在环境中辐射并占据新的空间。其中，将器官径向定位在直立茎周围的创新是大幅提高植物生产力和多样性的一个前提。这种三维的生长形式首先是陆生植物获得的一种新的干细胞功能的结果，即干细胞分裂可通过多个平面方向旋转。藻类谱系不能通过多个平面旋转干细胞分裂，因此通常局限于较小的丝状生长形式。在现代苔藓发育过程中，当分枝的丝状（原丝体）前体组织产生配子体的叶状芽（配子体）时，出现了从2D到3D生长的进化过程。以前的研究表明，配子体起始是一种半球形扩展，并且它们的2D或3D的发散命运是由APETALA2型（APB）转录因子活性随机决定的。在生长发育的单细胞阶段，持续的APB活性和细胞扩展标志着向配子体命运（3D）的转变，而APB活性的丧失标志着丝状生长的命运（2D）。强烈斜向细胞分裂是配子体发育的第一个可靠的形态学标记。接下来是第二个斜向的顶端细胞分裂，它大约垂直于第一个，之后分裂平面在两个连续的分裂过程中旋转以建立四面体的顶端干细胞。 四面体顶端细胞在螺旋面上分裂以取代自身并产生子细胞，形成3D配子体轴和叶。在进化和发育向3D生长的转变过程中，调控这种旋转干细胞分裂平面方向的机制尚不清楚。 (F):蓝点显示了不规则分裂的起始点 (G):芽细胞（配丝体初始，左侧）和顶端细胞（轴丝体末端，右侧） (H-K):顶端芽最初分裂四次，形成四面体形状。黄色箭头表示芽组织的最近的分裂，分裂形式为顶端-基部形式（a-b）和中-外侧形式（m-l），数字表示分裂次数 (L):图（H-K）中所示的浓密枝条的分区的表示法。阴影区域表示（G）（K）中用蓝点标记的初始单元格，数字表示（I）（K）中所示的域。 在拟南芥中，CLAVATA（CLV）和WUSCHEL（WUS）通路在反馈回路中起作用，调节干细胞功能的许多方面，包括细胞命运、增殖和生长。CLV3编码一种小的分泌肽，在中央区的上层细胞中表达，可以在分生组织中移动。CLV1在中央区的底层细胞层中表达，编码一种激酶，它与CLV2、CORYNE（CRN）、RECEPTOR-LIKE PROTEIN KINASE 2（RPK2）和BARELY ANY MERISTEM（BAM）一起作为CLV3的受体。WusA活性促进分生组织细胞增殖，而CLV信号则限制WUS表达域的大小。WUS的作用是非细胞自主的，从组织中心移动到最上层的分生组织细胞层，在那里它促进CLV3的表达，从而关闭维持分生组织大小的反馈回路。 resultsCLAVATA路径起源于陆地植物的最后一个共同祖先为了确定CLV途径是如何进化的，并确定CLV在小立碗藓干细胞功能中的潜在作用，首先从大量绿藻和陆地植物中查询了CLV3-like（CLE）、CLV1/BAM、RPK2、CLV2和CRN同源物。绿藻或轮藻中未发现CLV途径同源物，但在每个早期苔藓植物谱系和所有其他陆地植物中至少发现一个CLE同源物和一个CLV1/BAM同源物，这表明CLV的核心信号模块至少包含一个CLE肽和一个CLV/BAM受体样激酶。RPK2同源基因存在于所有的陆生植物中，除了角苔中的Anthoceros agrestis。在小立碗藓中，鉴定出7个基因具有保守的CLE结构域，编码一个类似于CLV3的12个氨基酸肽基序，但是保守的CLE结构域之外的序列是不同的。基因组编码四种CLV3-like肽段：PpCLE1、2和3编码肽段基序RMVPTGPNPLHN；PpCLE4编码基序RMVPSGPNPLHN；PpCEL5和6编码基序RLVPTGPNPLHN；PpCLE7编码基序RVVPTGPNPLHN。利用保守激酶结构域中的氨基酸进行最大似然分析重建激酶系统发育树。对包含每个陆生植物谱系的CLV1/BAM-like序列或包含每个谱系的RPK2-like序列的分支进行了解析，CLV1/BAM和RPK2的系统发育与目前陆地植物进化的假设基本一致。在CLV1/BAM分支中有两个小立碗藓的基因，CLAVATA1a和1b（PpCLV1a和PpCLV1b）。发现一个RPK2同源物，命名为PpRPK2，但未发现CLV2或CRN同源物。这些序列数据表明，CLV途径的核心成分首先出现在陆地植物的最后一个共同祖先，伴随着3D生长的进化而创新。 CLV通路起源于陆生植物的最后一个共同祖先，与三维生长(A)的谱系同时发生，绿藻类和轮藻类的细胞分裂是单向的，而陆生植物的细胞分裂是多向的，从而产生复杂的三位生长，通过BLAST比对基因组或草图基因组(G)和转录组(T)数据库确定CLV通路同源物的数量。chl：绿藻，cha：轮藻，H：角苔类，M：藓类，L：苔类，VP：维管植物 CLAVATA通路成分在3D生长阶段表达为了研究小立碗藓CLV的活性，首先分析了与2D丝状体和3D配子体转换期相关的基因表达模式，通过RT-PCR，检测到PpCLE1、2和7肽编码基因在配子体中的表达，PpCLE3、4、5的基因检测不到表达，PpCLE6在原丝体中表达。受体编码基因PpRPK2、PpCLV1a和PpCLV1b在配子体中共表达，尽管在第10天丝状组织中PpRPK2的表达明显早于PpCLV1a和PpCLV1b，这些结果与来自转录组数据的报告大体一致。接下来，为PpCLE1、2、7、PpCLV1a、PpCLV1b和PpRPK2构建了启动子。在3周左右时，PpCLE1、PpCLE2、PpCLE7和PpCLV1a株在芽周围的各种原丝体细胞类型中积累了局部信号，PpCLV1b和PpRPK2在芽中积累信号，且信号向顶端最强。虽然所有的基因在配子体轴和叶中积累了信号，但不同基因之间信号积累的模式、时间和强度存在差异。而且PpCLE1、PpCLE2、PpCLE7和PpCLV1a在配子体中的信号积累与PpCLV1b和PpRPK2不相同。GUS结果表明，在小立碗藓中，PpCLE1、PpCLE2、PpCLE7、PpCLV1a、PpCLV1b和PpRPK2表达具有高度动态性。来自顶端细胞的第二轮细胞分裂也有不同的分裂平面，这些平面通常与第一分裂平面平行而不是垂直。 (A-D')中的所有组织在含有0.5mMFeCN的溶液中染色，染色时间在(A-F)中规定，(E-J')中的配子体在含有2 mMFeCN的溶液中染色时间延长了3倍。 CLAVATA的突变体影响小立碗藓从二维到三维的转变为了确定CLV途径成分的功能，构建了上述基因的敲除突变体，PpcleAmiR1-3、PpcleAmiR4-7、Ppclv1a1b和Pprpk2株系能够形成致密的原丝体组织，因此具有相对正常的2D生长期，然而，在3D生长阶段，所有四个突变体都有发育缺陷，成熟配子体总数减少，配子体发育缺陷。一步的研究发现，在ppclemir1-3、ppclemir4-7和Pprpk2突变体中，与野生型（WT）相比，具有1片或更少叶的配子体芽更多，并且Ppclv1a1b突变体在发育后期有许多小配子体停滞。这些数据表明配子体发育早期存在缺陷，可能反馈到配子体起始过程。为了确定WT和突变表型在发育过程中是如何分化的，我们对2细胞阶段、4细胞阶段和芽发育后期的配子体芽进行了成像，虽然野生型配子体启动正常，并表现出典型的斜向细胞分裂平面方向，但在PpcleAmiR1-3和PpcleAmiR4-7突变体中，第一次分裂平面被严重破坏，并且相对于生长主轴的角度较小，在顶端细胞四面体形状正常形成的发育阶段，突变体也有缺陷，表明生长和细胞命运规范存在问题，似乎重复了第一个配子体最初的正常分裂特征。Ppclv1a1b突变体表型在2细胞阶段期之后与WT不同，随后显示出与ppclemir1-3和ppclemir4-7突变体相似的分裂模式，并且一些细胞恢复为原丝体特性。Pprpk2突变体缺陷在发育初期不如Ppcle和Ppclv1a1b缺陷严重，在发育后期，细胞形态肿胀表明了生长缺陷和分裂面缺陷。上述突变表型表明，Physocmitrella CLV通路在调节细胞分裂平面、细胞命运、生长和增殖过程中的关键作用。第一次分裂中平面定向缺陷的表现表明，WT和突变配子体的发育在细胞命运确定后的单细胞阶段发生分化。 在小立碗藓和拟南芥中，CLAVATA在调节细胞分裂平面方向中的作用是保守的由于CLV在细胞分裂平面定位中的作用以前未被报道，作者又试图在拟南芥中鉴定其功能的保守性。为此，检测了拟南芥clv1/bam1/bam2/bam3四重突变体分生组织，其中CLV/BAM基因的整个分支功能缺失。尽管分裂平面方向在根分生组织中通常是定型的，但在clv1/bam1/bam2/bam3突变体根的干细胞生态位和基础组织层中发现了严重的无序平面。 CLAVATA的突变体的配子体发育有缺陷在拟南芥和其他开花植物中，CLV途径主要作用是维持分生组织干细胞池大小，在clv1和clv3 (cle)突变体中，干细胞数量的增加导致分生组织面积相应增加。但是小立碗藓不适合拟南芥分生组织功能的范式，因为茎尖由一个单一的顶端干细胞组成。顶端细胞以螺旋状分裂生产生子细胞，然后分裂产生叶母细胞和茎组织。为了研究CLV在调节干细胞功能中的作用在小立碗藓和拟南芥之间是否是保守的，对1个月大的WT和突变体的最大配子体进行成像，发现突变体配子体高度降低，并有发育缺陷。PpcleAmiR1-3、PpcleAmiR4-7、Ppclv1a1b和Pprpk2突变体叶片发育缺陷，而Ppclv1b、Ppclv1a1b和Pprpk2突变体也存在强烈的细胞增殖缺陷，在配子体基部形成愈伤组织样块（粉色箭头）。进一步的检查显示，这些团块是由配子体基部许多异位顶端细胞的活性引起的。这些功能缺失数据表明，CLV在调节干细胞功能方面发挥了作用，而这一功能在小立碗藓和拟南芥中保存下来。 (A-E)突变体配子体形态的光显微图显示，配子体(B)停止生长，(C和E)发育多个轴(粉色箭头)，(C E)相对于(A)野生型植株有显著的横向扩张。(H)小立碗藓配子体顶端组织，顶端细胞(淡黄色)和旋转分裂平面方向的示意图。(I-K) PpcleAmiR1-3突变配子体形态，(I)配子体基部过度增殖(J和K)顶端分生组织紊乱生长。(L- N) PpcleAmiR4-7突变体配子体形态具有(L)叶片分裂表型和(M和N)分生组织过度增殖和终止。（O-Q）Ppclv1a1b突变体配子体形态（O），在配子体基部有多个生长轴和多个分生组织（P和Q）。（R-T）Pprpk2突变体配子体形态，在配子体基部（S和T）具有多个生长轴（R）和多个分生组织。黄色箭头表示过度增殖或异位分生组织区域。 CLE能抑制小立碗藓配子体细胞的增殖为了进一步分析CLV功能的保守性，用人工合成的CLE肽段处理。在生长4周后，发现用1-mM浓度的CLE处理对植株的扩散或配子体启动的数量没有明显的影响，表明原丝体发育正常。尽管所有的肽段对配子体发育没有明显的影响，但拟南芥的CLV3和所有的PpCLE均会导致配子体矮化和叶片大小的显著变小，并与叶片细胞数量减少相关。虽然这种表型在表面上类似于PpcleAmiR1-3和PpcleAmiR4-7突变体发育不良的配子体表型，但我们没有发现CLE处理后发育阻滞或分生组织过度增殖的迹象，而且在CLE处理后也没有检测到配子体起始数量的差异(数据未显示)。这些数据表明，CLE通过一个保守的信号模块调控小立碗藓的3D生长阶段的细胞增殖。 CLE肽可通过在小立碗藓和拟南芥中保存的受体成分发挥作用以前对拟南芥的研究表明，在根上施用CLEs可以阻止分生组织的功能。为了检测肽功能的保存，将拟南芥种子在含有1uM浓度溶质或肽的MS培养基上。尽管溶质对照、随机肽和TDIF没有导致根发育停滞，但CLV3和所有PpCLEs导致拟南芥的长度显著变短，这是由于根分生组织的塌陷造成的。虽然用CLE肽段处理野生拟南芥植株强烈抑制根系生长，但当用拟南芥和小立碗藓肽段处理时，rpk2突变体的表型变化不如野生型显著。这些数据与先前发表的结果一致，这些结果表明RPK2在其他受体中起作用以促进拟南芥中的CLV信号，并且表明PpCLEs也可以通过RPK2在拟南芥中起作用。 为了确定PpCLEs是否通过PpRPK2起作用，在WT、Ppcle和PpRPK2突变背景下进行了类似的实验。Ppcle突变配子体大小与Pprpk2突变配子体大小大致相同，如果Ppcle通过Pprpk2起作用，应该在Ppcle突变体中检测到反应，而不是Pprpk2突变体。与之前的实验一样，野生植物配子体发育受到强烈的抑制。可能由于缺乏位置信息，用CLE肽处理Ppcle突变体并不能挽救发育缺陷，但仍然诱导配子体矮化反应，与完整的受体机制一致。相比之下，Pprpk2突变体对CLE应用没有形态反应，这表明PPCLE通过Pprpk2调节3D生长。 讨论CLV模式细胞分裂平面方向如何CLV通路通过定向配子体细胞分裂平面、调控生长和命运来调控小立碗藓的2D到3D发育转变。配体和受体如何共同作用来完成这一过程还不清楚。一种可能是CLE配体的扩散产生了一个浓度梯度，使分裂面形成图案。拟南芥中CLE模式的形成层分生组织也有类似的机制，CLE41在韧皮部合成并扩散与邻近原形成层细胞中的PXY受体结合，而为斜周分裂提供空间信息。CLE41的结构性或异位表达扰乱了这种位置信息，导致形成层分裂面紊乱。在小立碗藓中，相似的模式化可以通过受体的亚细胞定位来实现，在芽的初始阶段，也可以通过在芽的不同部分表达受体来实现。 也有可能CLV信号不直接影响晚期细胞分裂平面，但CLV通过激素信号、细胞几何学和/或细胞力学来影响细胞分裂平面。生长素信号和微管相互作用蛋白的活性，如CLIP-associated proteins（claps），已知在拟南芥胚胎中指定细胞分裂平面，并且生长素信号调节先前确定的在小立碗藓芽中正确的分裂平面定向所必需的因子的活性，包括DEK1和NOG1。在小立碗藓中，生长素和细胞分裂素之间似乎存在着复杂的相互作用，一些表型表明这种相互作用在Ppcle、Ppclv和Pprpk2突变体中被破坏。例如，在用CLEs处理的植物中，配子体基部的细胞命运和增殖受到干扰，叶细胞的增殖受到干扰，这些发育方面受到生长素和细胞分裂素的调控。将CLV信号与调节生长和命运的激素途径联系起来，对于揭示3D生长过程中细胞分裂平面规范的机制具有重要意义。 CLV调控的干细胞功能是陆地植物的祖先特征CLV途径起源于陆生植物，CLV调节干细胞的增殖和功能可能是陆生植物的祖先特征。陆生植物获得了干细胞在多个平面分裂的定向能力，这使得植物能够发展出器官在多个方向排列的直立轴，从而实现了细胞的多样化，这是茎部进化的关键一步。Ppcle突变体的干细胞分裂平面缺陷特异性地影响了3D生长阶段的过渡。因此，在一个古老的陆地植物群中，CLV调节了反映进化过渡的发育过渡。结果表明，CLV是陆生植物重要形态创新的一个遗传新颖性。 CLV调控的分生组织功能早于WOX和KNOX调控的分生组织功能第一批陆地植物分生组织由一个配子体干细胞组成，而维管植物的多细胞孢子体分生组织结合了干细胞和更普遍的增殖能力。Ⅰ类KNOX基因调控维管植物分生组织增殖，但这些作用在苔藓植物和维管植物之间并不相同。Moss-KNOX（MKN）基因主要在孢子体组织中表达，虽然功能缺失的mkn2突变体在孢子体中存在伸长缺陷，但它们具有正常的配子体。WOX基因是拟南芥干细胞增殖的关键调控因子。然而，这一功能是由新近衍生的WUSgene分支获得的，并且由于Ppwox13L突变配子体发育正常，在Physocmitrela中CLV调控的下游通路可能与拟南芥中的不同。因此，Ⅰ类KNOX和WOX调控的分生组织功能都是在苔藓维管植物分化后获得的。CLV在陆生植物生命周期配子体阶段分生组织功能的起源中起重要作用，我们推测CLV在KNOX和WOX调节分生组织功能起源之前被招募来调节生活周期孢子体阶段的干细胞功能。","tags":"literature_reading"},{"title":"单细胞实战(4)：STAR与cellranger结果比较","url":"/2020/10/06/2020-10-06-ScRNAseq(4)/","text":"前言本次主要使用Seurat比较STAR与Cellranger的输出结果，只会进行简单的聚类工作。 数据读入123456789101112131415161718192021222324252627282930313233&gt; library(Seurat)&gt; library(dplyr)&gt; library(magrittr)&gt; library(gtools)&gt; library(stringr)&gt; library(Matrix)&gt; setwd(&quot;D://data/ScRNAcode&quot;)##读入STAR数据&gt; matrix.dir=&quot;STAR/&quot;&gt; barcode.path &lt;- paste0(matrix.dir,&quot;barcodes.tsv&quot;)&gt; features.path &lt;- paste0(matrix.dir,&quot;features.tsv&quot;)&gt; matrix.path &lt;- paste0(matrix.dir, &quot;matrix.mtx&quot;)&gt; STARmatrix &lt;- readMM(file = matrix.path)&gt; feature.names = read.delim(features.path,+ header = FALSE,+ stringsAsFactors = FALSE)&gt; barcode.names = read.delim(barcode.path,+ header = FALSE,+ stringsAsFactors = FALSE)&gt; colnames(STARmatrix) = barcode.names$V1&gt; rownames(STARmatrix) = feature.names$V2&gt; STARmatrix&lt;-as.matrix(STARmatrix)&gt; STARmatrix[1:6,1:6]##创建seurat对象##创建STAR的Seurat对象&gt; STAR &lt;- CreateSeuratObject(STARmatrix,project = &quot;zsz&quot;, min.cells = 3, min.features = 200)##创建Cellranger的Seurat对象&gt; dir=&quot;cellranger/&quot;&gt; counts &lt;- Read10X(data.dir = dir)&gt; RANGER &lt;- CreateSeuratObject(counts, project = &quot;zsz&quot;, min.cells=3, min.features = 200) 数据比较123456789101112131415161718192021222324252627282930313233&gt; ##数据比较&gt; dim(STARmatrix)[1] 33538 2048&gt; dim(counts)[1] 33538 2112&gt; dim(STAR)[1] 13350 2046&gt; dim(RANGER)[1] 13314 2105&gt; fivenum(apply(STARmatrix,1,function(x) sum(x&gt;0)))MIR1302-2HG IGFBPL1 AL008723.2 FXYD7 MT-CO1 0 0 0 29 2047&gt; fivenum(apply(counts,1,function(x) sum(x&gt;0)))MIR1302-2HG FAM221B LINC01638 DGKE MT-CO1 0 0 0 29 2108&gt; pdf(&quot;box.pdf&quot;,height = 9,width = 9)&gt; boxplot(apply(STARmatrix,1,function(x) sum(x&gt;0) ),main = &quot;STAR&quot;,col = &quot;lightgray&quot;)&gt; boxplot(apply(counts,1,function(x) sum(x&gt;0) ),main = &quot;Cellranger&quot;,col = &quot;lightgray&quot;)&gt; dev.off()RStudioGD 2&gt; pdf(&quot;hist.pdf&quot;,height = 9,width = 9)&gt; hist(apply(STARmatrix,2,function(x) sum(x&gt;0) ),col = &quot;lightgray&quot;,+ breaks=20,xlim=c(0,4000),ylim=c(0,800),+ labels=F,main=&quot;STAR&quot;,+ xlab=&quot;genes&quot;,ylab=&quot;cells&quot;)&gt; abline(v=median(apply(STARmatrix,2,function(x) sum(x&gt;0))),col=&#x27;red&#x27;)&gt; hist(apply(counts,2,function(x) sum(x&gt;0) ),col = &quot;lightgray&quot;,+ breaks=20,xlim=c(0,4000),ylim=c(0,800),+ labels=F,main=&quot;Cellranger&quot;,+ xlab=&quot;genes&quot;,ylab=&quot;cells&quot;)&gt; abline(v=median(apply(counts,2,function(x) sum(x&gt;0))),col=&#x27;red&#x27;)&gt; dev.off() 根据箱线图，直方图和矩阵的基本信息，可以看到STAR与cellranger的结果差距很小 质量控制与聚类比较123456789101112&gt; pdf(&quot;qc.pdf&quot;,height = 9,width = 9)&gt; VlnPlot(STAR,+ features = c(&quot;nFeature_RNA&quot;, &quot;nCount_RNA&quot;),+ pt.size = 0.1,+ ncol = 2)&gt; VlnPlot(RANGER,+ features = c(&quot;nFeature_RNA&quot;, &quot;nCount_RNA&quot;),+ pt.size = 0.1,+ ncol = 2)&gt; dev.off()RStudioGD 2 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&gt; STAR&lt;-subset(STAR,subset=nFeature_RNA&gt;500 &amp; nFeature_RNA&lt;2000)&gt; STAR &lt;- NormalizeData(STAR, normalization.method = &quot;LogNormalize&quot;, scale.factor = 10000)Performing log-normalization0% 10 20 30 40 50 60 70 80 90 100%[----|----|----|----|----|----|----|----|----|----|**************************************************|&gt; table(STAR@meta.data$orig.ident) zsz1896&gt; STAR &lt;- FindVariableFeatures(STAR, selection.method = &quot;vst&quot;, nfeatures = 2000)Calculating gene variances0% 10 20 30 40 50 60 70 80 90 100%[----|----|----|----|----|----|----|----|----|----|**************************************************|Calculating feature variances of standardized and clipped values0% 10 20 30 40 50 60 70 80 90 100%[----|----|----|----|----|----|----|----|----|----|**************************************************|&gt; top10 &lt;- head(VariableFeatures(STAR), 10)&gt; top10 [1] &quot;S100A9&quot; &quot;S100A8&quot; &quot;IGLC2&quot; &quot;IGKC&quot; &quot;LYZ&quot; &quot;IGLC3&quot; &quot;CCL3&quot; &quot;NFKBIA&quot; &quot;PTGDS&quot; &quot;S100A12&quot; &gt; RANGER&lt;-subset(RANGER,subset=nFeature_RNA&gt;500 &amp; nFeature_RNA&lt;2000)&gt; RANGER&lt;- NormalizeData(RANGER, normalization.method = &quot;LogNormalize&quot;, scale.factor = 10000)Performing log-normalization0% 10 20 30 40 50 60 70 80 90 100%[----|----|----|----|----|----|----|----|----|----|**************************************************|&gt; table(RANGER@meta.data$orig.ident) zsz1895&gt; RANGER &lt;- FindVariableFeatures(RANGER, selection.method = &quot;vst&quot;, nfeatures = 2000)Calculating gene variances0% 10 20 30 40 50 60 70 80 90 100%[----|----|----|----|----|----|----|----|----|----|**************************************************|Calculating feature variances of standardized and clipped values0% 10 20 30 40 50 60 70 80 90 100%[----|----|----|----|----|----|----|----|----|----|**************************************************|&gt; top10 &lt;- head(VariableFeatures(RANGER), 10)&gt; top10 [1] &quot;S100A9&quot; &quot;S100A8&quot; &quot;IGLC2&quot; &quot;IGKC&quot; &quot;LYZ&quot; &quot;CCL3&quot; &quot;NFKBIA&quot; &quot;IGLC3&quot; &quot;PTGDS&quot; &quot;S100A12&quot;&gt; scale.genes &lt;- rownames(STAR)&gt; STAR &lt;- ScaleData(STAR, features = scale.genes)&gt; STAR &lt;- RunPCA(STAR, features = VariableFeatures(STAR))&gt; plot1 &lt;- ElbowPlot(STAR, ndims=30, reduction=&quot;pca&quot;)&gt; scale.genes &lt;- rownames(RANGER)&gt; RANGER &lt;- ScaleData(RANGER, features = scale.genes)&gt; RANGER &lt;- RunPCA(RANGER, features = VariableFeatures(RANGER))&gt; plot2 &lt;- ElbowPlot(RANGER, ndims=30, reduction=&quot;pca&quot;)&gt; plotc &lt;- plot1+plot2&gt; ggsave(&quot;pca.pdf&quot;, plot = plotc, width = 8, height = 4) 1234567891011121314151617181920212223&gt; STAR &lt;- FindNeighbors(STAR, dims = 1:10)&gt; STAR &lt;- FindClusters(STAR, resolution = 0.8)&gt; table(STAR@meta.data$seurat_clusters) 0 1 2 3 4 5 6 7 8 9368 310 290 217 184 129 119 112 92 75&gt; metadata &lt;- STAR@meta.data&gt; cell_cluster &lt;-data.frame(cell_ID=rownames(metadata),cluster_ID=metadata$seurat_clusters)&gt; STAR &lt;- RunUMAP(STAR, dims = 1:20)&gt; embed_tsne &lt;- Embeddings(STAR, &#x27;umap&#x27;)&gt; plot1 = DimPlot(STAR, reduction = &quot;umap&quot; ,label = &quot;T&quot;, pt.size = 1,label.size = 4)&gt; RANGER &lt;- FindNeighbors(RANGER, dims = 1:10)&gt; RANGER &lt;- FindClusters(RANGER, resolution = 0.8)&gt; table(RANGER@meta.data$seurat_clusters) 0 1 2 3 4 5 6 7 8 9375 300 290 212 195 128 122 108 91 74&gt; metadata &lt;- RANGER@meta.data&gt; cell_cluster &lt;- data.frame(cell_ID=rownames(metadata), cluster_ID=metadata$seurat_clusters)&gt; RANGER &lt;- RunUMAP(RANGER,n.neighbors = 30,dims = 1:20)&gt; embed_umap &lt;- Embeddings(RANGER, &#x27;umap&#x27;)&gt; plot2 = DimPlot(RANGER, reduction = &quot;umap&quot; ,label = &quot;T&quot;, pt.size = 1,label.size = 4)&gt; plotc &lt;- plot1+plot2&gt; ggsave(&quot;umap.pdf&quot;, plot = plotc, width = 8, height = 4) 可以看到两种分析方法umap与tsne聚类效果不太相同，但是基本的聚类与分群是一致的 结语就结果而言，两种分析方法的结果不完全相同，但也基本一致，本次笔记中用到的数据和代码已上传github，在ScRNAseq_code/compare文件夹下，大家需要的可以下载试试","tags":"bioinformatics scrnaseq"},{"title":"单细胞实战(3)：STAR分析单细胞数据","url":"/2020/10/03/2020-10-03-ScRNAseq(3)/","text":"前言在利用cellranger比对单细胞reads时，可以发现有STAR的进程夹杂在里面，那么STAR可以用来比对单细胞数据吗？在STAR的2.7版本中（2.7.6a）出现了STARsolo，可以进行单细胞数据的比对，由此可见STAR的强大 Cellranger输出结果在使用STAR之前，先看一下cellranger的输出结果 123456789101112131415161718192021222324.├── analysis│ ├── clustering│ ├── diffexp│ ├── pca│ ├── tsne│ └── umap├── cloupe.cloupe├── filtered_feature_bc_matrix│ ├── barcodes.tsv.gz│ ├── features.tsv.gz│ └── matrix.mtx.gz├── filtered_feature_bc_matrix.h5├── metrics_summary.csv├── molecule_info.h5├── possorted_genome_bam.bam├── possorted_genome_bam.bam.bai├── raw_feature_bc_matrix│ ├── barcodes.tsv.gz│ ├── features.tsv.gz│ └── matrix.mtx.gz├── raw_feature_bc_matrix.h5└── web_summary.html 为方便查看，cellranger提供了一个网页端的结果，我们主要观察细胞和基因数目的评估即可，后续的聚类工作由seurat完成 在结果目录，可以看到如下两个目录 raw_feature_bc_matrix filtered_gene_bc_matrices raw目录下是所有的barcode信息，包含了细胞相关的barcoed和背景barcode,而filter目录下只包含细胞相关的barcode信息，内容如下 123│ ├── barcodes.tsv.gz│ ├── features.tsv.gz│ └── matrix.mtx.gz 后缀为mtx的文件记录的就是基因的表达量信息，可以导入R或者python中查看，barcodes相当于一个细胞，features代表不同的基因，barcodes文件在STARsolo中会用到，这就是为什么我要先说明一下cellranger的输出结果 利用STAR分析10X数据STARsolo被设计为替代10X CellRanger基因定量比对软件。而且STARsolo的速度是cellranger的十倍（具体怎么样我也不知道） 建立索引： 1STAR --runMode genomeGenerate --genomeDir ghg38/ --genomeFastaFiles Homo_sapiens.GRCh38.dna.primary_assembly.fa --sjdbGTFfile Homo_sapiens.GRCh38.93.filtered.gtf 其实利用cellranger构建的索引原则上也能用，在GRCh38/star/下，但是由于STAR版本问题可能会导致无法识别，因为cellranger用的STAR构建的索引和我们自己用的STAR版本是不一致的。 STARsolo与普通的转录组比对区别在于你需要在比对时加上whitelist，whitelist文件格式在10X官网有写,我们可以利用cellranger的barcodes.tsv.gz文件获得 12zcat barcodes.tsv.gz&gt;whitelistsed -i &quot;s\\-1\\\\g&quot; whitelist 需要注意ReadFilesIn先读入测序数据，再读入barcode+UMI文件,即先读入R2再读入R1 1STAR --genomeDir ghg38/ --readFilesCommand zcat --readFilesIn SRR7722939/SRR7722939_S1_L001_R2_001.fastq.gz SRR7722939/SRR7722939_S1_L001_R1_001.fastq.gz --soloType CB_UMI_Simple --soloCBwhitelist whitelist --runThreadN 8 结果默认保存在Solo.out文件中，8线程只用了10min左右，确实要快一点 12345678910111213├── Barcodes.stats└── Gene ├── Features.stats ├── filtered │ ├── barcodes.tsv │ ├── features.tsv │ └── matrix.mtx ├── raw │ ├── barcodes.tsv │ ├── features.tsv │ └── matrix.mtx ├── Summary.csv └── UMIperCellSorted.txt 看一下Summary里是啥 1234567891011121314151617181920Number of Reads,23095815Reads With Valid Barcodes,0.979732Sequencing Saturation,0.529367Q30 Bases in CB+UMI,0.991351Q30 Bases in RNA read,0.842989Reads Mapped to Genome: Unique+Multiple,0.959769Reads Mapped to Genome: Unique,0.874368Reads Mapped to Transcriptome: Unique+Multipe Genes,0.63797Reads Mapped to Transcriptome: Unique Genes,0.613655Estimated Number of Cells,2048Reads in Cells Mapped to Unique Genes,12815372Fraction of Reads in Cells,0.904219Mean Reads per Cell,6257Median Reads per Cell,5544UMIs in Cells,5978718Mean UMI per Cell,2919Median UMI per Cell,2577Mean Genes per Cell,915Median Genes per Cell,873Total Genes Detected,16265 可以看到比起cellranger，STAR捕获到的细胞数少一点，而且每个细胞的reads要低一点，其他差不多，后续将使用Seurat包对两组数据进行比较 STARsolo其他命令–soloTypedefault: Nonestring(s): type of single-cell RNA-seqCB_UMI_Simple(a.k.a. Droplet) one UMI and one Cell Barcode of xed length inread2, e.g. Drop-seq and 10X Chromium.CB_UMI_Complexone UMI of xed length, but multiple Cell Barcodes of varying length,as well as adapters sequences are allowed in read2 only, e.g. inDrop.CB_samTagOutoutput Cell Barcode as CR and/or CB SAm tag. No UMI counting.{readFilesIn cDNA read1 [cDNA read2 if paired-end]CellBarcode read . Requires {outSAMtype BAM Unsorted [and/orSortedByCoordinate]SmartSeqSmart-seq: each cell in a separate FASTQ (paired- or single-end),barcodes are corresponding read-groups, no UMI sequences,alignments deduplicated according to alignment start and end (afterextending soft-clipped bases) –soloCBwhitelistdefault: -string(s): le(s) with whitelist(s) of cell barcodes. Only {soloTypeCB UMI Complex allows more than one whitelist le.Noneno whitelist: all cell barcodes are allowed –soloCBstartdefault: 1int&gt;0: cell barcode start base –soloCBlendefault: 16int&gt;0: cell barcode length–soloUMIstartdefault: 17int&gt;0: UMI start base –soloUMIlendefault: 10int&gt;0: UMI length –soloBarcodeReadLengthdefault: 1int: length of the barcode read1equal to sum of soloCBlen+soloUMIlen0not de ned, do not check–soloCBpositiondefault: -strings(s) position of Cell Barcode(s) on the barcode read.Presently only works with {soloType CB UMI Complex, and barcodes areassumed to be on Read2.Format for each barcode: startAnchor startPosition endAnchor endPositionstart(end)Anchor de nes the Anchor Base for the CB: 0: read start; 1: readend; 2: adapter start; 3: adapter endstart(end)Position is the 0-based position with of the CB start(end) withrespect to the Anchor BaseString for di erent barcodes are separated by space.Example: inDrop (Zilionis et al, Nat. Protocols, 2017):{soloCBposition 0 0 2 -1 3 1 3 8–soloUMIpositiondefault: -string position of the UMI on the barcode read, same as soloCBposition–soloAdapterSequencedefault: -string: adapter sequence to anchor barcodes.–soloAdapterMismatchesNmax default: 1int&gt;0: maximum number of mismatches allowed in adapter sequence.–soloCBmatchWLtypedefault: 1MM multistring: matching the Cell Barcodes to the WhiteListExactonly exact matches allowed1MMonly one match in whitelist with 1 mismatched base allowed. AllowedCBs have to have at least one read with exact match.1MM_multimultiple matches in whitelist with 1 mismatched base allowed,posterior probability calculation is used choose one of the matches.Allowed CBs have to have at least one read with exact match. Similar toCellRanger 2.2.01MM_multi_pseudocountssame as 1MM Multi, but pseudocounts of 1 are added to all whitelistbarcodes.Similar to CellRanger 3.x.x–soloStranddefault: Forwardstring: strandedness of the solo libraries:Unstrandedno strand informationForwardread strand same as the original RNA moleculeReverseread strand opposite to the original RNA molecule–soloFeaturesdefault: Genestring(s): genomic features for which the UMI counts per Cell Barcode arecollected Genegenes: reads match the gene transcriptSJsplice junctions: reported in SJ.out.tabGeneFullfull genes: count all reads overlapping genes’ exons and introns–soloUMIdedupdefault: 1MM_Allstring(s): type of UMI deduplication (collapsing) algorithm1MM_Allall UMIs with 1 mismatch distance to each other are collapsed (i.e.counted once)1MM_Directionalfollows the “directional” method from the UMI-tools by Smith, Hegerand Sudbery (Genome Research 2017).Exactonly exactly matching UMIs are collapsedNoDedupno deduplication of UMIs, count all reads. Allowed for –soloTypeSmartSeq –soloUMIfilteringdefault: -string(s) type of UMI ltering- basic ltering: remove UMIs with N and homopolymers (similar toCellRanger 2.2.0)MultiGeneUMIremove lower-count UMIs that map to more than one gene(introduced in CellRanger 3.x.x) –soloOutFileNamesdefault: Solo.out/ features.tsv barcodes.tsv matrix.mtxstring(s) le names for STARsolo output: le name pre x gene names barcode sequences cell feature count matrix –soloCellFilterdefault: CellRanger2.2 3000 0.99 10 string(s): cell ltering type and parametersCellRanger2.2simple ltering of CellRanger 2.2, followed by three numbers: numberof expected cells, robust maximum percentile for UMI count,maximum to minimum ratio for UMI countTopCellsonly report top cells by UMI count, followed by the exact number ofcellsNonedo not output ltered cells –soloOutFormatFeaturesGeneField3default: “Gene Expression”string(s): eld 3 in the Gene features.tsv le. If “-“, then no 3rd ld is output.","tags":"bioinformatics scrnaseq"},{"title":"单细胞实战(2)：cellranger使用","url":"/2020/10/01/2020-10-01-ScRNAseq(2)/","text":"将SRA转为fastq数据下载好之后，我们得到的是SRR文件，需要将其转换为fastq格式才能使用 123456wkd=/home/project/single-cell/MCCcat SRR_Acc_List-2586-4.txt |while read idofastq-dump --gzip --split-files $&#123;i&#125;.sradone 结束之后每个SRR文件会变成解压出三个文件 为什么会有三个文件，这个需要去查一下10X的官方说明 可以看到Read1是26bp，主要是16bp的barcode和10bp的UMI，Read2的长度不固定，所以不一定是98bp，视情况而定，还有一个I7 index长度是8bp 接下来就按照10X的标准去对文件进行改名 123456cat SRR_Acc_List-9245-3.txt | while read idomv $&#123;i&#125;_1*.gz$&#123;i&#125;_S1_L001_I1_001.fastq.gzmv $&#123;i&#125;_2*.gz $&#123;i&#125;_S1_L001_R1_001.fastq.gzmv $&#123;i&#125;_3*.gz $&#123;i&#125;_S1_L001_R2_001.fastq.gzdone 之后我创建了文件夹将每个SRR数据的三个fastq文件放到一个文件夹下 12345SRR7722937├── SRR7722937_S1_L001_I1_001.fastq.gz├── SRR7722937_S1_L001_R1_001.fastq.gz└── SRR7722937_S1_L001_R2_001.fastq.gz cellranger使用下载cellranger3.1版本（目前cellranger已经支持4.0版本）并添加至环境变量 123curl -o cellranger-3.1.0.tar.gz &quot;https://cf.10xgenomics.com/releases/cell-exp/cellranger-3.1.0.tar.gz?Expires=1601922176&amp;Policy=eyJTdGF0ZW1lbnQiOlt7IlJlc291cmNlIjoiaHR0cHM6Ly9jZi4xMHhnZW5vbWljcy5jb20vcmVsZWFzZXMvY2VsbC1leHAvY2VsbHJhbmdlci0zLjEuMC50YXIuZ3oiLCJDb25kaXRpb24iOnsiRGF0ZUxlc3NUaGFuIjp7IkFXUzpFcG9jaFRpbWUiOjE2MDE5MjIxNzZ9fX1dfQ__&amp;Signature=mCC-emSQTqWg3i6Rm23lkuccNRI4z7xf-8bJ-O5gHqsYFJHDPZN9MeUZW5vhRZvmZhiGK7EDL4y~3xPtQbS6JtfUL9EFsoUxMywyF7tGN2ZlU2pbb2EVpmhKjmDWPVmvurDb~ZlHVYZCYcOc6gEHVtFRre-ICa7-nccVtnUJA-HvxNrZMs5mlQaUG9E-ngtbLi86gvIYlMHYnFRieZYpMA-kmUKrHGG8MhiuBGR96AWOrsVdTyMjD-BJOurGYvZGddWAF5uVXNPJs47FqF4fNCSQw71WOSRx4bQGdfb-jrOFp-NDSYFhkY1-gigku8VCx9phFCtyTAVM9yHeGN1oMQ__&amp;Key-Pair-Id=APKAI7S6A5RYOXBWRPDA&quot;tar -zxvf cellranger-3.1.0.tar.gzexport PATH=/datadisk02/ScRNAseq/cellranger-3.1.0:$PATH 构建注释 123456789101112131415161718192021222324252627282930313233wget ftp://ftp.ensembl.org/pub/release-93/fasta/homo_sapiens/dna/Homo_sapiens.GRCh38.dna.primary_assembly.fa.gzgunzip Homo_sapiens.GRCh38.dna.primary_assembly.fa.gzwget ftp://ftp.ensembl.org/pub/release-93/gtf/homo_sapiens/Homo_sapiens.GRCh38.93.gtf.gzgunzip Homo_sapiens.GRCh38.93.gtf.gzcellranger mkgtf Homo_sapiens.GRCh38.93.gtf Homo_sapiens.GRCh38.93.filtered.gtf \\ --attribute=gene_biotype:protein_coding \\ --attribute=gene_biotype:lincRNA \\ --attribute=gene_biotype:antisense \\ --attribute=gene_biotype:IG_LV_gene \\ --attribute=gene_biotype:IG_V_gene \\ --attribute=gene_biotype:IG_V_pseudogene \\ --attribute=gene_biotype:IG_D_gene \\ --attribute=gene_biotype:IG_J_gene \\ --attribute=gene_biotype:IG_J_pseudogene \\ --attribute=gene_biotype:IG_C_gene \\ --attribute=gene_biotype:IG_C_pseudogene \\ --attribute=gene_biotype:TR_V_gene \\ --attribute=gene_biotype:TR_V_pseudogene \\ --attribute=gene_biotype:TR_D_gene \\ --attribute=gene_biotype:TR_J_gene \\ --attribute=gene_biotype:TR_J_pseudogene \\ --attribute=gene_biotype:TR_C_genecellranger mkref --genome=GRCh38 \\ --fasta=Homo_sapiens.GRCh38.dna.primary_assembly.fa \\ --genes=Homo_sapiens.GRCh38.93.filtered.gtf \\ --ref-version=3.0.0 也可以下载构建好的注释 1curl -O https://cf.10xgenomics.com/supp/cell-exp/refdata-cellranger-GRCh38-3.0.0.tar.gz 然后进行比对即可 1cellranger count --id=SRR937 --transcriptome=GRCh38 --fastqs=SRR7722937/ --sample=SRR7722937 在分析过程中可以发现有些命令比较眼熟，不难发现cellranger的比对还是构建索引其实都有STAR的影子，后续的话我将STARsolo（利用STAR分析单细胞数据）的流程再整理一下。 12345Generating STAR genome index (may take over 8 core hours for a 3Gb genome)...15:12:38 ..... Started STAR run15:12:38 ... Starting to generate Genome files15:14:31 ... starting to sort Suffix Array. This may take a long time...15:14:41 ... sorting Suffix Array chunks and saving them to disk... 参考链接https://support.10xgenomics.com/single-cell-gene-expression/software/release-notes/build#grch38_3.0.0 10x_Technical_Note_Base_Composition_SC3_v2_RevB.pdf 【生信技能树】使用10X单细胞转录组数据探索免疫治疗 单细胞实战(三) Cell Ranger使用初探 单细胞实战(二) cell ranger使用前注意事项","tags":"bioinformatics scrnaseq"},{"title":"单细胞实战(1)：原始测序数据下载","url":"/2020/09/29/2020-09-29-ScRNAseq(1)/","text":"前言目前的课题是10X单细胞测序(植物方面)，之前已经把所有的流程基本走过一遍，现在就将自己的学习过程整理成笔记给大家分享一下，我在学习单细胞分析的时候主要跟着单细胞天地的公众号和jimmy老师在B站上上传的单细胞分析视频进行学习的，在前期的数据下载过程中也参考了刘小泽的文章，希望对大家能有所帮助。 数据来源：《Acquired cancer resistance to combination immunotherapy from transcriptional loss of class I HLA》文章中的部分数据 ID Description SRR_ID GSM3330559 Tumor Disc Pre SRR7722937 GSM3330560 Tumor Disc AR SRR7722938 GSM3330561 PBMC Pre SRR7722939 GSM3330562 PBMC Disc Early SRR7722940 GSM3330563 PBMC Disc Resp SRR7722941 GSM3330564 PBMC Disc AR SRR7722942 数据下载两种方法 1.使用sratools 123456789101112131415161718192021conda install -c daler sratoolkit##sra数据下载加速wget https://download.asperasoft.com/download/sw/connect/3.8.1/ibm-aspera-connect-3.8.1.161274-linux-g2.12-64.tar.gz# 小心版本号有变动，不要直接复制上面的命令tar zxvf ibm-aspera-connect-3.8.1.161274-linux-g2.12-64.tar.gzbash ibm-aspera-connect-3.8.1.161274-linux-g2.12-64.sh# 默认安装路径 /home/user/.asperacat &gt;SRR_Acc_List-2586-4.txtSRR7722937SRR7722938SRR7722939SRR7722940SRR7722941SRR7722942cat SRR_Acc_List-2586-4.txt |while read ido prefetch $i -O `pwd` &amp;&amp; echo &quot;** $&#123;i&#125;.sra done **&quot;done 2.利用ascp由ftp.ncbi下载测序数据 第一种情况下有的数据可能无法下载，也可以直接利用ascp下载，速度也很快 在EBI上搜索想要的SRR号，复制连接地址 ftp://ftp.sra.ebi.ac.uk/vol1/srr/SRR772/007/SRR7722937 然后将地址按照如下格式修改 123456ascp -QT -l 300m -i ~/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/srr/SRR772/007/SRR7722937 ./ascp -QT -l 300m -i ~/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/srr/SRR772/008/SRR7722938 ./ascp -QT -l 300m -i ~/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/srr/SRR772/009/SRR7722939 ./ascp -QT -l 300m -i ~/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/srr/SRR772/000/SRR7722940 ./ascp -QT -l 300m -i ~/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/srr/SRR772/001/SRR7722941 ./ascp -QT -l 300m -i ~/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/srr/SRR772/002/SRR7722942 ./ 参考链接单细胞实战(一)：数据下载 【生信技能树】使用10X单细胞转录组数据探索免疫治疗","tags":"bioinformatics scrnaseq"},{"title":"炫酷你的Github主页","url":"/2020/09/22/2020-09-22-Cool_your_github/","text":"1.在github上新建一个仓库并clone到本地注意： 新仓库的名字要与你的登录账号名保持一致（我这里已经创建过所以有重名警告） 我比较喜欢使用atom来进行clone，所以我选择了添加README文件，如果喜欢用git可以不添加README文件，按照如下命令执行 12345678进入一个文件夹git clone git@github.com:你的用户名/你的用户名.gitecho &quot;# 主页展示的内容&quot; &gt;&gt;README.mdgit initgit add .git commit -m &quot;first commit&quot;git remote add origin git@github.com:你的用户名/你的用户名.gitgit push -u origin master 使用atom进行clone，ctrl+shift+p输入github clone，将主页网址clone到本地 此时你的主页也出现了一个界面，个性化设置主要是修改这个README来使的主页显示相应的内容 修改README文件其实接下来的步骤就因人而异了，修改自己的README文件，变成自己想要的模式吧，分享一下自己的界面https://github.com/Bioinformatics-rookie 再给大家推荐一个Github的主页，我个人感觉挺好看的，原文件在我的项目里example.md","tags":"github"},{"title":"文献导读：小立碗藓三维发育的细胞特异性转录组分析","url":"/2020/09/19/2020-09-19-three-dimensional_shoot_development/","text":"在上一篇导读中提到，目前在做小立碗藓的单细胞测序，相关的maker gene已经能发掘到很多，还缺少转型期相关的maker gene，看到了2015年发表在《The Plant Journal》的文章，使用了激光切割法取特定组织进行转录组分析，区分了tip-cell（最终发育绿丝体）和bud-cell（最终发育为配子体），希望能对我寻找转型期相关基因有所帮助。 Summary 单倍体苔藓配子体具有不同的干细胞类型，包括叶尖细胞分裂成单平面产生丝状原丝体，芽（bud）细胞分裂成三个平面产生轴向配子体芽。这种从丝状生长到三维生长的转变是在苔藓生命周期中逐渐发生的，被认为是从轮藻绿藻祖先进化而来的第一批陆生植物。形态复杂的植物体计划的创新促进了垂直景观的定殖，使复杂的营养和生殖植物形态得以发展。尽管它有着深刻的进化意义，但参与从原丝体组织向三平面分生组织转变的分子程序却鲜为人知。在这项研究中，利用单细胞型转录组学鉴定了4000多个差异表达的基因，这些差异表达基因区分了单面原丝体顶端细胞和多平面配子体芽细胞。虽然叶尖细胞和芽细胞的转录体都显示增殖细胞的分子特征，但是芽细胞转录组表现出更广泛的基因种类，转录丰度显著增加。我们的数据表明，在苔藓植物中，与芽模式和不对称细胞分裂有关的基因的联合表达伴随着从平面到三维分生组织生长的转变。 introduction 陆地植物（胚胎植物）形态复杂的体形图的发育需要分生组织细胞在三维平面分裂。与胚胎植物不同的是，陆生植物轮藻绿藻近亲的分枝丝状生长完全是通过二维的细胞分裂进行的，其中丝状分枝是由斜向扩展的藻丝平面的细胞分裂开始的。最有可能的是，向三维分裂分生组织细胞的转变，能够产生形态上复杂的胚胎植物体形，发生在胚胎植物的一个未知的水生祖先身上。 在苔藓发育的单倍体配子体阶段，这一关键的进化创新从丝状体到直立形态被复现。与维管植物不同，无核无维管苔藓的萌发孢子进行单平面分裂，形成由叶绿体丰富的细胞组成的丝状原丝体，称为绿线体。当原丝体顶端细胞通过单平面分裂延伸纤维时，双平面细胞分裂发生在离尖端更远的地方，从而产生分枝状的原丝体。当暴露于诱导的环境刺激和/或生长素的存在下，绿丝状体可能会单面分裂，并转变为第二种丝状细胞类型，称为芽，其中含有倾斜的细胞壁和很少的叶绿体，虽然约有5%的芽细胞转化为三维分裂的干细胞（SCs），称为配子体芽。芽细胞是分生组织，形成复杂的芽轴，称为配子体，其中包含称为叶状体的光合侧生器官。为了收集足够的芽材料，用萘乙酸和激动素(kinetin)处理，使茎基分枝点的芽（诱导芽）比未处理的对照植株多12倍。 配子体由一个分生组织细胞发育而来，同时具有不确定性和器官发生的功能。在种子植物中，茎分生组织被分成功能上不同的多细胞区。分生组织中央区分裂不频繁，维持着不确定的干细胞生态位，而外围区分裂迅速，启动侧器官。植物发育中的一个基本问题是藓类单细胞分生组织芽细胞如何发挥SC不确定性和器官发生的综合功能，这些功能在维管植物茎分生组织中被赋予不同的多细胞区。 已知调节苔藓SC特性的关键遗传因子包括平行的小RNA途径、染色质重塑、转录因子、激素信号传导和转运基因以及细胞分裂的调节因子。在已知的SC调节因子列表中，显著缺失的是KNOTTED 1-like (class I KNOX)基因，它们在被子植物的茎分生组织中起着不可或缺的作用。尽管转录组学证据表明I类KNOX基因MKN2确实在苔藓的分生组织芽细胞中表达，但小立碗藓 KNOX基因的靶向敲除没有产生配子体表型。 激光显微切割和下一代测序技术的结合使单个细胞的转录组分析成为可能。在这里，我微切单平面原丝体顶端细胞和芽细胞产生了细胞特异性的小立碗藓转录组。的目标有两个：（i）探索被子植物茎分生组织在单细胞顶端和诱导苔藓芽细胞中的遗传程序的程度，（ii）发现在苔藓配子体二维单面和三维平面SCs的分子结构。 转录组比较显示，成千上万的基因转录本区分了叶尖细胞和诱导芽细胞。虽然这两种SC类型的转录本都在多能干细胞类型中得到了丰富的功能，但是诱导的芽细胞转录组显示出在被子植物中调节芽模式和不对称细胞分裂的同源基因的积累显著增加。从这些数据中，提出了一个通过茎分生功能和不对称细胞分裂相结合的复杂身体计划进化模型。 RESULTS AND DISCUSSION成千上万的基因转录本区分芽细胞和顶端细胞配子体的发育经历了从单面分裂形成不分枝细丝，到形成分枝细丝的双面分裂，最后发展到形成配子体复杂体形的三维分裂。由于平面和三维生长模式都来自于单个分生组织细胞，激光显微切割和转录组学分析这两种不同的SC类型是直接的。在顶端细胞和芽细胞群体之间发现了6957个显著差异表达的基因。其中4472个差异表达基因表现出双重差异表达：1043个在单平面叶尖细胞中上调，3429个在三维生长诱导的芽细胞中上调。数据表明，与顶端细胞相比，芽细胞处于转录活跃状态。 原丝体尖端和配子体芽样本的转录组比较揭示了数千个分离这两种SC类型的基因。(a)激光显微分离使尖端细胞和芽细胞特异分离。(b, c) 10至2000万reads生成每个样本类型(b),和超过10000个基因被发现差异表达(c)。(d) k - means聚类之间的差异表达基因的SC和全植物(WP)转录组显示离散独立分组在三种样本类型。(e) WP、芽、尖转录组间差异表达基因的热图。层次聚类形成的主要基因簇以紫色、黄色、蓝色、橙色和绿色块表示。在heatmap的左侧显示缩放后的基因表达水平值条，红色和蓝色分别表示上调和下调。 GO富集分类在芽细胞中丰富，而在尖端细胞中不丰富对尖端细胞和芽细胞中转录物积累的分析表明，与整个植物转录组相比，有数千个上调转录物（1382个）和下调转录物（2135个）。real-time PCR进一步验证了上调诱导芽和叶尖基因的表达模式。GO富集分析确定在诱导芽和叶尖转录组数据集中显著富集的预测基因功能。芽细胞GO预测主要参与分子模式和发育。这些包括转录因子，蛋白激酶，细胞命运决定和形态发生，以及跨膜外排转运。一些与尖端细胞生长相关的GO类也富集在芽细胞，如顶端生长和花粉管生长。原丝体被认为是苔藓尖端生长的主要细胞；转录组数据表明，诱导的配子体发育的某些基因也出现在尖端细胞中。 Real-time quantitative PCR validation of transcripts enriched in bud SCs and tip SCs. 与芽转录组中发现的大量发育模式相关的GO类别不同，在尖端细胞转录组中富集的GO类别大多数与光合功能有关。在尖端细胞转录组中发现了大量与光合作用相关的GO类别，表明固碳是顶端细胞的主要功能之一。根毛发育过程中GO的富集也被发现，这进一步证明了苔藓原丝体和被子植物根毛之间有共同的生长策略。 令人惊讶的是，在尖端细胞中显著富集的GO类没有涉及转录调控、激素反应或表观遗传修饰。先前对原丝体细胞重编程的转录组学研究显示，发育基因的缺失与此类似。 涉及茎分生组织模式和细胞不对称分裂的基因在芽细胞中上调为了确定差异表达的候选基因，从组织特异性转录组中提取了具有所述发育功能的被子植物基因同源物。转录本选自八个功能类别：细胞壁生物发生、细胞骨架和不对称细胞分裂、一般发育、光合作用、细胞周期调节、激素信号、茎尖分生组织发育和表观遗传修饰。下图显示了在尖端细胞转录组（75个基因）和芽细胞转录组（100）中上调的特定基因转录本的比较。然而，数百个功能未知的差异表达基因在芽或尖端细胞转录体中特异性上调。 尖端细胞转录组包含大量参与细胞壁生物发生和光合作用的基因，而芽细胞转录组的特征是调控激素信号，表观遗传修饰，芽顶端分生组织发育，细胞周期调节，细胞骨架和不对称细胞分裂的基因。 在诱导芽细胞转录组中，表达上调的基因可以指导芽分生组织模式的形成和不对称的细胞分裂。例如，拟南芥受体信号转导基因的同源物，这些基因调节茎的分生组织大小和模式，包括CLAVATA 1和2（CLV1和CLV2）、MERISTEMATIC RECEPTOR-LIKE KINASE（MRLK）、丝裂原活化蛋白激酶激酶YODA（YDA）、ERECTA-LIKE，CRINKLY4（CR4）和calpain编码的信号基因DEFECTIVE KERNEL1（DEK1）。 在被子植物茎分生组织的中心区和外围区，多种染色质重塑复合物调控着细胞命运的转变。在bud细胞中，包括拟南芥SWI/SNF复合物同源基因在内的多种染色质重塑基因也上调，但在tip细胞中没有上调。先前的研究表明，原丝体和配子体具有不同的染色质状态；这些上调的染色质重塑因子可能参与了染色质状态的改变。此外，显示与染色质重塑复合物相互作用的细胞周期同源物在诱导芽细胞转录组中特别上调，例如直接SWI/SNF相互作用因子E2F转录因子（E2F），以及一些周期蛋白（CDC/CYC）和细胞周期蛋白依赖激酶（CDK）。 bud细胞富含参与控制细胞不对称分裂的特定细胞周期调节因子，包括CYCB1;1，CDKA1;1和E2F的同源物，对分化组织和复杂植物结构的发育至关重要。一种由不对称细胞分裂引起的预测功能是配子体芽细胞中不均匀的细胞分裂形叶状体前体细胞。与含有10多种细胞周期调控因子的诱导芽细胞转录组相比，尖端细胞转录组只有两个显著上调的细胞周期基因（STRUBBELIG和CYCLOPHILIN 38） 。 在bud细胞中特异性上调的其他bud预测的25个基因控制植物激素生长素、细胞分裂素和油菜素甾体的生物合成和信号转导的基因。最有趣的是，在bud细胞中发现了两个PIN基因的同源物。此外，在bud细胞中，一种参与PIN蛋白极性定位的蛋白激酶PINOID的同源物也上调。最近的一项研究表明，在苔藓配子体中，质膜相关的PIN蛋白是正常芽发育所必需的。 在被子植物中，大量的转录因子网络参与了对细胞特异性命运和发育模式的控制。值得注意的是，在tip细胞中表达上调的转录因子基因不包括模式植物同源的基因。相比之下，bud细胞中上调的转录物包括与芽图案有关的几种被子植物转录物的同源物，如DORNROSCHEN-LIKE（DRN-LIKE）和LEAFY（LFY），表皮PROTODERMAL FACTOR 2（PDF2）和SCREAM2（SCRM），以及I类KNOX基因MOSSKNOTTED-RELATED HOMEOBOX 2（MKN2）。bud细胞中发现MKN2上调表达是出乎意料的，因为先前的遗传分析表明，KNOX基因的功能仅限于孢子体世代。 两种类型的干细胞都是由一个不可区分的单细胞分支点和一个平面细胞分裂产生的。在这一阶段，bud和tip的干细胞在形态上相似，但面临着截然不同的发展命运，这可能是由仅仅两次细胞分裂后数千个差异表达的基因所决定的。在单细胞阶段分离bud和tip细胞在形态学上是不可行的；然而，这项研究可能有助于识别在tip和bud细胞命运形态表现之前的分子标记。 CONCLUSION被子植物模式植物基因同源物和不对称细胞分裂调控因子的协同上调启发了一个模型，其中这些遗传途径的协同作用有助于在形态复杂的配子体中发现新的发育创新。从这个观点来看，这些组合的发育功能所赋予的特性可以使bud细胞出现新的干细胞功能，以及由覆盖侧器官启动程序的不对称分裂程序所赋予的器官发生。分生组织母细胞的不对称分裂产生了包括气孔复合体的多种细胞类型；然而，分生组织母细胞的这种多能性是短暂的。气孔的最早古植物学证据与苔藓植物的出现相吻合。推测苔藓配子体分生组织功能发育途径的出现，可能在气孔演化过程中起到了类似的作用。","tags":"literature_reading"},{"title":"文献导读：小立碗藓组织特异转录组","url":"/2020/09/17/2020-09-17-specific_transcriptome/","text":"最近在做小立碗藓的10X转录组，最大的问题就是maker gene，所以要从文献中发掘maker gene，将其用于自己的细胞注释中，目前选择了2016年发表在《Molecular Plant》的一篇文章，主要做了小立碗藓各个组织的转录组，找到一些组织特异性基因，希望对我的注释工作能有帮助。 摘要本研究主要制作了小立碗藓的转录组图谱，涵盖了苔藓植物的生命周期的大部分阶段，包括了孢子体发育的详细进展。研究鉴定了一套完整的孢子体特异性的转录因子，并发现许多这些基因在被子植物中具有同源性，在发育过程中起很多作用，比如开花和分枝。 引言在适应陆地生活的过程中，早期陆地植物的配子体和孢子体世代经历了相当大的形态变化，导致了今天苔藓植物和维管植物典型的世代交替。例如，人们认为孢子体从一个小而简单的结构，在生理上依赖于配子体，进化成复杂的，自由生活的，有时是巨大的生物，支配着今天大多数陆地生态系统。这种转变涉及到新器官和组织系统的产生。目前，有几个转录因子已经被鉴定可能是实现这种转化的关键：例如，class I KNOTTED-LIKE HOMEOBOX（KNOX1）基因主要在开花植物中负责调节顶端分生组织的生长，在P.patens中局限在孢子体中，可能具有调节孢子体分生组织生长的作用。其他可能在陆地植物进化过程中发挥重要作用的调节孢子体发育的重要家族有BELLRINGER 1-LIKE HOMEOBOX (BELL1), MADS-box, GRAS以及TEOSINTE BRANCHED1/CYCLOIDEA/PROLIFERATING CELL FACTOR1 (TCP). 大规模的比较转录组分析已经被成功地用于根据它们的时间和空间表达谱来确定候选基因。通过识别早期陆地植物的基因调控网络并评估它们在进化过程中是如何变化的，这可以应用到进化研究中。在拟南芥中，已经有大量的转录组数据可供参考。在小立碗藓中目前也在尝试类似的工作，例如，在几种发育条件条件下的原丝体的转录组，配子体和原丝体在几种生物和非生物胁迫下的转录组反应，但是关于孢子体发育进展的详细信息仍然缺失，此外，目前还没有对根茎类或单个生殖器官的转录组数据进行研究，也没有对P.patens生命周期的大部分组织的转录组数据进行全面的分析。在识别差异基因时，这是一个问题，因为缺乏相应组织和发育阶段的转录组数据将对后续的研究有巨大的影响。 在本研究中，描述了大部分P.patens的生活史阶段的转录数据，包括绿丝体、轴丝体、假根、配子体、孢子、颈卵器和四个不同的孢子体发育阶段。并创建了一个数据集http://bar.utoronto.ca/efp_physcomitrella/cgi-bin/efpWeb.cgi。将*P.patens*转录组数据与现有的拟南芥的数据进行比较，以提取早期分化的陆地植物类群中具有进化保守性的基因表达特征。结果发现被子植物的孢子体中也有一些重要的同源基因，如与芽器官形态发生和花器官发育有关的基因。此外，通过对孢子体特异性TCP转录因子PpTCP5的功能表征，推测该基因在控制孢子体结构方面具有进化保守功能，因此，该基因可能在陆地植物进化过程中获得孢子体复杂性方面发挥了重要作用。关于配子体的产生，分析表明，拟南芥和小立碗藓的尖端生长有一个相似的核心转录因子，这些转录因子表达模式的特定修饰可以解释这些远缘物种尖端生长细胞之间的发育差异。 结果与讨论生成一个P. patens转录组图谱和eFP浏览器集成制作小立碗藓的转录组图谱，选取了大量的组织生长时期，分析的组织包括绿丝体、轴丝体、配子体、假根、原生质体、颈卵器以及四个不同的孢子生长阶段。以孢子体为例，根据形态特征(如大小、形状和成熟程度)将发育分为不同阶段。作为指导，根据受精事件的假定时间确定孢子体收集的日期如下:S1：受精后5-6天，S2：受精后9-11天，S3：受精后18-20天，S4：受精后28-33天。在所有被分析的组织中，都达到了预期的结果，此外，还可以确定与孢子体密切相关的组织/阶段（如轴丝体和绿丝体）或不同孢子体阶段之间的差异。研究还对在多个组织中筛选出的优先表达的基因进行了qRT PCR检测，发现转录组结果与qRT PCR表达数据高度相关。最后，比较了我们的芯片预测的几个基因家族的表达谱，并将其与已发表的实验数据进行了比较，发现它们之间存在高度相关性。总的来说，这些观察结果验证了转录组的结果。 在植物生物学生物分析资源(BAR)中显示了整合到Physcomitrella eFP浏览器中的P. patens组织的卡通形象。在孢子体发育阶段，用于mRNA分离的组织的代表性图像包括(底部)。根据受精事件发生后的天数(d.AF，受精后的天数)，分期被称为孢子体1 (S1)、孢子体2 (S2)、孢子体3 (S3)和成熟(棕色)孢子体(SM)。 使用标记基因进行qRT-PCR检测组织 (A)检测PIP2;1水通道蛋白(Pp1s8_151V6.1)，结果与之相反。在本例中，配子体和孢子体组织均有表达，而在原丝体组织中未检测到转录本。(B)检测原体组织中有报道的RM09基因(Pp1s407_31V6.1)的表达。原体根(轴丝体、绿丝体、原生质体和假根)中表达丰富，在这些组织中也可以观察到表达水平的差异。(C)选择组织优先表达的基因进行qRT-PCR模式确证。(D)报告的基因表达值与PpMKN转录因子家族转录本存在的实验证据的相关性。组织图上方的圆圈表示了文献中PpMKN基因在各自阶段的表达。 整体转录趋势与主要发育转变和生理功能相对应通过主成分分析(PCA)和层次聚类(HC)来分析数据集之间的相关关系。在对所有样本的主成分分析中，观察到与发育或生理功能相关的优先分组于配子体或孢子体的身份。HC dendogram确认了之前在PCA中观察到的样本分离。重要的是，相同的生物复制被分组在一起，表明本次研究成功分离了发育阶段，特别是孢子体发育阶段。 小立碗藓中的基因表达表明，与在拟南芥中观察到的相比，小立碗藓具有较低的世代偏向化为了获得所有组织间转录多样性的概述，确定了每个组织中表达、富集和只在特定组织中表达，而在其他组织中没有表达的基因数量。为了计算表达阈值，对一组低表达值的基因进行qRT PCR实验。检测与相应基因的转录表达价值报告的数组,建立最小值调用一个基因。发现有一个高和常数被表达的基因数量在所有组织。因此，根据先前在Funaria hygrometrica中观察到的，P. patens中两代基因表达的分化要弱于被子植物A. thaliana，后者配子体表达的基因数量只有孢子体表达的一半。此外还进行了额外的分析，以确定每一代优先表达基因的数量。发现P. patens中配子体的唯一表达基因数量是孢子体的两倍多。在这种情况下，这一观察结果与苔藓中组成配子体世代的较高的组织多样性及其在孢子体中的优势地位是一致的。 (A) PCA应用于每个组织三个重复的平均基因表达值。(B)利用Pearson s相关系数进行层次聚类。(C)组织表达基因相对于基因总数的百分比(黑色)，以及组织富集基因相对于被检测到的富集基因总数的百分比(红色)。(D)维恩图，显示配子体和孢子体世代之间共同和唯一表达的基因数目。 出现的、富集的和优先表达的每个组织表达转录本 在被子植物中，控制二倍体发育和一般植物结构的转录因子在孢子体的几个阶段都有表达在维管植物中，孢子体生命周期的优势表现为体计划结构的复杂性增加，这是由一组转录因子控制的，其中KNOX、BELL1和TCP家族尤为重要。例如，KNOX2转录因子在苔藓的世代交替中被证明是必不可少的，因为它们阻止了单倍体遗传程序的表达。此外，在维管植物的孢子体中，KNOX和BELL1之间的相互作用是已知的。这种相互作用改变了这些转录因子控制SAM活性和维持的方式，最终产生了植物体形态和大小的巨大多样性。表达数据表明，在P. patens孢子体发育过程中，KNOX2类蛋白MKN1、MKN6和一个bell -like同源物(Pp1s258_6v6)表达水平相似，这与这些蛋白在苔藓中相互作用的假设一致。此外，还发现两个TCP同源物(Pp1s332_35v6和Pp1s207_110v6)在孢子体各发育阶段均有很高的表达水平，在SM中表达达到峰值。在被子植物中，TCP基因也是孢子体结构的重要调节器，因为它们控制腋芽的发育、分枝和芽的对称。 基因标识符(左)和基因描述(右)，包括家族、基因名称和拟南芥同源性。转录因子从S1, S2, S3, SM的丰富基因列表中选择。寻找至少在三个孢子体发育阶段富集的基因，并与非孢子体组织进行比较。红色代表高表达，黄色代表低表达值。从这个列表中选择了两个TCP基因进行进一步分析。 大量表达的TCP家族成员抑制孢子体分枝在孢子体中，PpTCP转录本的丰度高于其他转录因子的表达;它们几乎和组成性表达的微管蛋白一样丰富。系统发育分析表明，TCP基因既存在于基底层植物类群的基因组中，也存在于它们的藻类亲缘物种中。它们被分为两个主要亚科:第一类，也被称为TCP-P，第二类，也被称为TCP-C。在南芥中，I类基因促进一般细胞的生长和增殖，II类基因通过调节组织增殖模式来控制茎的分枝、侧器官的发育和花的对称。利用A. thaliana和P. patens的TCP氨基酸序列进行进一步的系统发育分析，发现P. patens有两个TCP II类同源物和四个I类同源物。II类基因PpTCP5和PpTCP6在孢子体中有明显的富集。 为了研究P. patens中II类基因的功能，通过同源重组生成了5个独立的敲除突变株PpTCP5 (Pp1s332_35V6)。选择3个株系进行进一步表型分析(指定为PpTCP5(5)、PpTCP5(8)和PpTCP5(27))。在WT孢子体中扩增出PpTCP5和PpTCP6转录本，但在突变株中未检测到PpTCP5转录本。重要的是，与转录组结果PpTCP6转录本水平大致相同。热图显示了在孢子体中丰富的转录因子的表达动态。寻找至少在三个孢子体发育阶段富集的基因，并与非孢子体组织进行比较。红色代表高表达，黄色代表低表达值。PpTCP6转录水平在突变系中并没有增加来弥补Pptcp5功能的缺失。 将Pptcp5突变体转移到孢子体诱导条件下，与WT进行表型比较。比较了Pptcp5突变体和WT的孢子体数量和分枝孢子体的百分比。所有突变系的分枝孢子体数量都是WT的两倍多。WT的分枝频率约为5%，而Pptcp5(27)的分枝频率接近15%。此外，具有两个或更多分枝的孢子体在Pptcp5株系中比野生型更常见，有些个体在一个结构上可产生多达5个蒴果。 (A)6个PpTCP基因同源物的归一化芯片强度值，以可视化其在不同组织分析中的表达模式。(B) PpTCP5基因敲除突变显示，在不同发育阶段，出现数个蒴果(箭头)。(C) RT - PCR扩增显示突变株和WT系中TCP II类和I类(PpTCPI)基因的表达情况。(D) WT和敲除株系的孢子体分枝平均百分比。 孢子体发育的GO分析反映了导致孢子成熟的主要转变使用DAVID功能注释工具进行GO富集分析,在S1阶段，转录调控是唯一确定的功能类别。这是由于在这个阶段只有17个基因表达丰富;然而，它们中的大多数是转录因子，它们可能负责启动孢子体转录程序。在S2阶段,相关功能类别是脂质分解代谢、形态发生,以及少部分的转录因子的活动。在S3和SM阶段,基因的数量和功能类别的多样性大幅增加，由于两个最丰富的分类是配子体发育和减数分裂，这一发现是相关的，并表明在这个特定的阶段，孢子开始发生。此外,脂质生物合成的过程是在S3中高度富集,表明脂质代谢对孢子生物起源也很重要，这一发育阶段似乎与能量储备的运输和储存以及孢子的生长和成熟有关。 控制春化和气孔发育的转录因子的同源性在孢子体发育的早期得到表达在S1期间，所有被鉴定的注释基因都与转录调控有关。特别值得注意的是，有一种转录因子与A. thaliana REDUCED VERNALIZATION RESPONSE 1 (VRN1)基因同源(Pp1s434_19V6)。拟南芥的VRN基因主要负责调节春化作用，植物暴露在寒冷环境中一段时间后加速开花的过程。然而，在谷物中，VRN1的表达可以在没有春化的情况下增加，这意味着它可以调节分生组织而并不局限于春化。同源基因在P. patens孢子体早期阶段的表达表明，它对维持该物种分生组织的活性/同一性也很重要。 其他转录因子在这个阶段富集似乎参与水运特殊细胞的分化,如PpVNS6和PpVNS4,此外，在S2期，发现bHLH FAMA的同源基因PpSMF1高表达。在A. thaliana中，FAMA和MUTE转录因子主要负责控制保护细胞的分化。 花粉发育相关的同源基因的表达标志着S3期孢子发生的开始植物的有性生殖依赖于减数分裂细胞产生单倍体细胞，单倍体细胞产生配子体。在P. patens中，减数分裂发生在孢子体发育的某个阶段，之后产生孢子。鉴定了一个与MALE MEIOTIC DEATH 1(MMD1)同源的转录因子(Pp1s271_42V6)，该转录因子在孢子体发育的S2和S3阶段优先表达。在A. thaliana中，MMD1突变体表现出减数分裂的改变，导致雄性减数细胞停止和细胞死亡。该转录因子表达在S2和S3期间达到一个非常高的表达水平，而且在SM阶段之后的其他组织中不会表达。此外，减数分裂重组蛋白DOSAGE SUPPRESSOR OF MCK1(DMC1) 的同源基因、SPORULATION 11（SPO11）也优先表达在S3阶段。最后，还发现MALE STERILITY 1 (MS1)也在S3阶段富集。在A. thaliana中，MS1控制着花粉质组分的形成，与MMD1属于同一转录因子家族。这些观察结果为减数分裂控制提供了有力的证据，因此表明孢子发生开始于S3发育阶段。此外，花粉母细胞控制减数分裂的基因似乎与花粉母细胞控制减数分裂的基因是同源的。 顶端生长细胞的转录组揭示了配子体的发育过程由于顶端生长细胞代表了单倍体产生的一个主要阶段，分析了它们的转录组，以提供重要的配子体发育过程的见解。该研究确定了在每一种末端生长细胞类型中单独富集的一组基因，以评估是否可以识别与特定功能相关的类。假根的GO注释都与离子运输相关，包括阳离子和阴离子转运、钾转运和磷代谢,这表明假根参与不同离子的吸收和交换,与提供配子托与无机营养来维持生长相关。与钾、磷和铁转运相关的基因转录本尤其丰富。而绿丝体注释最多的是乙烯介导的信号通路、四吡啶结合、金属离子结合和对光反应，反映了该组织通过光合作用和碳同化产生能量的作用。根据这一分析,乙烯信号可能参与绿丝体的生长与发展。最后，在轴丝体细胞中，发现了叶尖生长相关的生理过程更加活跃；最丰富的分类是细胞壁修饰，细胞大小的调节，葡聚糖代谢过程，碳水化合物分解代谢。根据这一观察，可以发现轴丝体的生长速度明显高于绿丝体。 在尖端生长细胞中高表达的基因变成了花粉管或根毛特异性基因为了确定在P. patens中控制一般尖端生长功能的候选转录因子，搜索了在三种尖端生长细胞中高表达的基因:轴丝体，绿丝体和假根。大多数的tip- growth cell enrichment (TGE)转录因子属于bHLH或MIKC MADS-box亚家族的MIKC类。已知这些家族的几个成员分别控制根毛和花粉管的发展。在P. patens中发现的属于bHLH家族的TGE转录因子分别有PpRSL1和PpRSL2、RHD6和RSL1以及LRL-like转录因子的两个同源基因。这些基因在P. patens和A. thaliana中的表达模式是不同的，因为在后者中它们的表达仅限于一种顶端生长细胞:根毛。从生物学功能上看，PpRSL1和PpRSL2是P. patens植物茎和根茎发育所必需的，而A. thaliana的同源基因则是根毛发育所必需的，对花粉管的生长没有作用，也就是说它们的活性仅局限于一种顶端生长细胞。 类似的例子可以在MIKC转录因子中找到，因为在A. thaliana中，除了一个基因外，所有的MIKC基因都只在一种顶端生长细胞中表达:花粉管。同样，发现P. patens基因组编码的11个MIKC蛋白中有10个在所有的端生长细胞中表达。尽管有3个基因在轴丝体、绿丝体和假根中优先表达，其余8个基因在孢子和成熟孢子体中表达的水平也较低。因此，MIKC* mRNA在成熟的孢子体样本中的存在，可能是分离出RNA的孢子囊中含有大量孢子的结果。 综上所述，这些观察结果表明轴丝体、绿丝体和假根的转录组比被子植物顶端生长的细胞更相似。在P. patens中，发现142个基因转录在所有的顶端生长细胞中同时表达和富集，而在A.thaliana中总共发现49个。 后者的TGE基因数量较少，这可以解释为花粉和根毛没有P. patens顶端生长细胞那样表达许多共同基因，然而，在拟南芥中，组织多样性较高，这也会影响TGE基因的最终数量。 另一方面，当花粉和根毛分别与其他组织进行比较时，可以获得大量丰富的基因。控制根毛生长的部分基因网络的表达是从配子体世代通过进化而来的，所以可以想象一个可以解释我们观察到的情况，其中根毛仅部分获得祖先顶端生长细胞发育基因网络的表达。这就解释了为什么它们不表达与花粉相同的基因。另一方面，花粉管中可能有几个基因的表达中断，这些基因包括前面提到的bHLH转录因子PpRSL1和PpRSL2（假设这些基因也在祖先苔藓植物的所有叶尖生长细胞中表达）。这些观察结果是相关的，因为它们支持陆地植物进化的对立理论。 孢子的转录组表明广泛的转录和表观遗传重编程孢子和花粉在萌发时能产生顶端生长的细胞，在某种程度上可以认为是类似的结构。然而，虽然花粉粒和花粉管的转录组仅显示出中等程度的变化，但成熟孢子的转录组与小立碗藓顶端生长细胞的转录组有很大不同。事实上，孢子在转录上是独一无二的，因为有几个转录因子家族在这个阶段特别丰富。孢子中高度富集的基因转录物主要参与RNA代谢。一些相关的分类包括非编码RNA（ncRNA）加工、ATP依赖性解旋酶活性、RNA剪接和DNA修复。特别是，一些涉及mRNA和sRNA处理的基因被高度富集。其中包括一个HEN1抑制子1（HESO1）（Pp1s131 v6）的同源物，此外，还发现了编码与DNA染色质修饰和甲基化有关的蛋白质的转录物，这表明这些过程在孢子中是活跃的。综上所述，这些观察结果表明，基因表达修饰所涉及的过程是高度活跃和动态的，包括表观遗传修饰。令人费解的是，在成熟孢子中观察到这种基因表达模式，而不是在任何其他组织或花粉转录组中观察到。一种假设可能是转录程序的广泛变化是实现活跃和休眠代谢状态之间的转换所必需的。在被子植物中，种子也必须经历一个类似的转变，并且已经确定参与染色质重塑过程的基因，包括甲基化，在这种重排中起作用。 从每代富集的转录因子基因总数中，计算属于特定转录因子家族的基因百分比。有几个转录因子家族在孢子中专一富集。 Summary本文献做了相当大量的工作，可以说为我们以后小立碗藓组织特异性的基因研究提供了一个大纲，该研究中缺乏动态的研究，比如小立碗藓从横向生长转变为立体生长的过程没有涉及，主要的侧重点在孢子体与配子体的比较，如果对转型期（bud-cell）细胞在进行更加深入的研究将更全面。而且文献中并没有所谓的summary，对一些信息没有汇总。 总之，篇文献对于我目前的细胞类型注释还是很有帮助的，根据文献中的一些组织特异性基因我可以将自己的细胞聚类大体分为了想要的几种，对于转型期的细胞还需要查询相关文献","tags":"literature_reading"},{"title":"进化树在线制作工具iTOL教程（4）：添加点图","url":"/2020/09/08/2020-09-08-iTOL4/","text":"添加点图依然去找示例文本dataset_external_shapes_template.txt 前面部分依旧不更改，只修改DATA 可以看到输入不同的value可能会使点的属性发生变化，为了防止出错，推荐一个表型（一列value）用一个dataset，最后挨个拖进去即可，这里只展示一组 点击shape type可以修改形状，点击rawdata可以局部修改 点击legend可以添加图例 刚刚是利用iTOL加的数量性状，接下来加质量性状，还是去找示例数据 不多说，只编辑DATA然后拖到网页 然后更改 看一下最终成品图","tags":"bioinformatics phylogenetic_tree itol"},{"title":"进化树在线制作工具iTOL教程（3）：添加图片","url":"/2020/09/06/2020-09-06-iTOL3/","text":"添加图片依然是寻找示例文本 上面的不作任何修改，只修改最后的DATA 需要注意，图片添加的是网址，而不是本地的图片，我们可以把想上传的图片写到简书上发表后在复制图片地址即可。 直接拖到网页，看一下效果 图片是没有办法单独设置的，如果感觉效果不太好，就在datasets调一下参数 最后导出文件即可","tags":"bioinformatics phylogenetic_tree itol"},{"title":"进化树在线制作工具iTOL教程（2）：添加文本","url":"/2020/09/03/2020-09-03-iTOL2/","text":"添加文本利用iTOL，我将进化树分为三个群体，接下来就是添加文本 与evolview一样，添加文本需要datasets，依然可以去参考help页面 这里我放上了官网中所有参考格式模板的压缩包，需要可以下载 每个参数都作了说明，可以根据需要修改，有一些可以在网页更改，所以建议上面不做修改，只在DATA部分修改，根据示例修改即可 修改之后 可以直接将该文件拖到网页上，查看效果 此时datasets界面出现了我们上传文件的信息 如果想要修改一些属性，你会发现这是对三个文本同时修改，想要单独修改就点击raw data&gt;edit using the web interface 这样就可以单独修改了","tags":"bioinformatics phylogenetic_tree itol"},{"title":"进化树在线制作工具iTOL教程（1）：基本操作","url":"/2020/09/01/2020-09-01-iTOL1/","text":"使用界面与Evolview一样，可以注册后使用，也可以白嫖，点击upload即可上传树文件 基本操作右侧controls负责对进化树进行修改： basic主要负责修改树的造型、分支、标签，还有标签的字体、字号是否加粗等 advance主要负责展示bootstrap的特征 iTOL最好用的一个功能是能修改局部的label和leaf 当我们鼠标悬停在某个位置时，我们可到这个局部数据的信息 鼠标点击即可修改局部node的属性，比如我改一下颜色和风格，可以看到局部的node被改为红色虚线，局部的label也可以更改 在选好节点后，再点击color&gt;new color range,我们可以把一部分label和branch加入背景色 然后我再将S26添加到h1中，点击相应的node，选择color&gt;add to existing即可，去掉的话选择remove from即可 点击h1的cover，可以选择背景色出现在label、clade、full上，也可以关闭，我选一下full border负责加边框，0就是不加，在这里我加一个1px的边框展示下 鼠标悬停在label上时，我们也可以修改局部label的属性，我在这里修改了label的名字 导出点击export，可以看到支持不同类型文件的导出 当colored ranges lenged点击on时，会出现图例 以上便是利用iTOL进行进化树美化的一些基本操作，相比起evolview，iTOL使用起来更加方便。","tags":"bioinformatics phylogenetic_tree itol"},{"title":"进化树+蛋白结构域","url":"/2020/08/30/2020-08-30-evolview3/","text":"目标 数据准备依然查看help界面的Protein domains 在上传数据的时候我们发现多了按钮，可以从PFAM上上传数据，evolview使用的标签名必须与PFAM的URL API 是一样的 手动上传示例数据 1KLF9_HUMAN 244 189,212,zf-H2C2_2,Pfam-A,,,PF13465,5.4e-05,32.80 159,186,zf-H2C2_2,Pfam-A,,,PF13465,0.0036,27.00 tab分割 第一列，基因名，第二列，长度，第三列（189,212,zf-H2C2_2,Pfam-A,,,PF13465,5.4e-05,32.80），结构域信息，用逗号分割，一共有八个内容，如果有多个结构域，就用空格添加多个 其实结构与信息也不用全部加上，这样的例子也可以 1234567159,186159,186,WD40159,186,WD40,Pfam-A159,186,,Pfam-A159,186,zf-H2C2_2,Pfam-A,,,PF13465 中间有内容缺失要补上逗号159,186,zf-H2C2_2,Pfam-A,,,,0.0036,27.00159,186,zf-H2C2_2,Pfam-A,,,PF13465,0.0036,27.00 还有一些对输出图形的属性更改 使用示例数据作图 成品图 可以看到我没有添加group和color，系统会自动给我分类并用不同的颜色显示 还有个方法，我们可以去看示例数据的图比如DEMOS下的protein domains 查看该进化树的protein domain信息，可以为我们的作图提供帮助 其他的进化树美化方法可以自己去参考help界面寻找帮助","tags":"bioinformatics evolview phylogenetic_tree"},{"title":"进化树美化之Evolview--热图（2）","url":"/2020/08/28/2020-08-28-evolview/","text":"上个教程中已经修改了进化树的分支颜色和标签颜色，接下来进行热图绘制 数据准备我们可以从help界面查看我们需要输入的数据类型 123456789101112131415161718#heatmap!title Example of heatmap 图例标题!showLegends 1 是否显示图例，1：显示，0：不显示!defaultStrokeColor gold!defaultStrokeWidth 2!colorgradient blue, yellow,red 热图配色!colorgradientMarkLabel 0,5,10,15,20,25 颜色梯度值# -- heatmap column labels --!showHeatMapColumnLabel 1 热图表头显示!heatmapColumnLabels e1,e2,e3,control 表头内容# -- heatmap --!heatmap margin=2,colwidth=30,roundedcorner=2 热图内部信息# -- show data value!showdataValue show=1,fontsize=12A -2,3,5,0B 7,9,10,23C 13,15,19,8D 20,22,25,4 根据示例数据将我们的数据修改好 123456789101112131415161718192021222324252627282930313233343536373839404142#heatmap!title Expression of heatmap!showLegends 0#!defaultStrokeColor gold#!defaultStrokeWidth 2!colorgradient red,white,blue!showHeatMapColumnLabel 1# -- heatmap column labels --!showHeatMapColumnLabel 1!heatmapColumnLabels HS1,HS2,HS3,HS4# -- heatmap --!heatmap margin=1,colwidth=30,roundedcorner=5# -- show data value!showdataValue show=0,fontsize=12,fontitalic=0,fontbold=1,textangle=-60,fontcolor=redAT1G03160.1 138.2662,119.4188,117.5653,131.9267AT4G17540.1 190.04398,130.73198,140.72378,150.41085Os06t0247800-01 22.3589,20.9118,19.7673,25.1028Os02t0738900-01 93.544,21.6591,18.8547,31.3205Os03t0732200-01 5.52722,4.83038,4.29929,3.81299Os10t0185200-00 83.1737,83.2791,71.5573,69.86103AT1G59610.1 40.8104,19.7877,21.998,34.7177AT1G10290.1 140.8104,119.7877,121.998,134.7177Os08t0425100-01 20.41115,39.6234,47.14298,63.02084Os12t0178700-01 48.51467,52.1542,52.7949,62.7378AT3G19720.1 124.4894,129.6265,127.352,132.6961Os01t0748000-00 103.341,352.318,236.861,293.542Os04t0129900-01 1.89585,8.67967,6.65843,2.84205Os03t0260000-01 131.2451,61.22141,49.86475,97.78848AT1G60500.1 29.84108,119.9479,125.1772,140.0944Os01t0920400-01 152.695,113.472,74.9321,61.9664AT2G14120.3 118.5393,229.62,230.3712,223.395AT4G33650.2 15.4361,255.7039,138.4035,133.0883Os04t0381000-01 1.81532,2.71541,4.09116,7.76133Os05t0556100-01 322.122,217.55541,18.8402,15.2791Os01t0681100-01 229.41612,249.59223,245.90516,125.5316AT3G61760.1 232.8752,251.1922,136.812,117.087AT5G42080.1 7.60426,3.105,8.66416,6.68762Os09t0572900-01 27.5529,94.32025,40.786299,40.476955AT1G14830.1 233.5316,235.4096,155.9334,164.4508Os03t0713100-01 5.59436,3.86999,5.44011,4.85916Os10t0567800-01 213.2103,218.9935,290.9288,225.216AT2G44590.3 29.6786,52.4297,272.53,278.289 成品图： 可以看到三个dataset已经在右边显示了，可以选择是否显示或者删除，也可以点笔的形状进行修改 结果导出 在上方有三个按钮，可以保存为png格式、pdf格式以及nwk格式 左侧也有一个按钮，可以保存为多种格式 将png格式保存到本地，可以看看效果 fine！！！","tags":"bioinformatics evolview phylogenetic_tree"},{"title":"进化树美化之Evolview--热图（1）","url":"/2020/08/25/2020-08-25-evolview1/","text":"目标达成以下效果 Evolview介绍在线的进化树美化工具，可直接在搜索引擎找到，可以注册账号也可以直接点击Try me白嫖 数据上传点击uploadtree，选择nwk文件上传 该按钮可以选择树的整体布局 该按钮可以控制显示节点和分支的数值以及字体的样式和线的宽度 局部标签加背景色 该按钮主要负责上传树的一些控制文件 可以看到有不同的类型，根据图片指示就能看出是怎样改变树的。 一般来讲，我们可以去help界面去寻找我们想要的美化树的方法，然后根据提示创建文件即可。 准备好的表格文件,可以看到我已经把需求体现在表格中，下一步要按照标准格式进行修改上传 可以看到背景色已经变化 分支颜色更改与标签颜色一样，按照相同的操作进行即可 目前已完成对标签和分支的颜色更改，下一步将加入右边的热图","tags":"bioinformatics evolview phylogenetic_tree"},{"title":"使用IGV简单绘制甲基化分布图","url":"/2020/08/23/2020-08-23-IGV/","text":"废话不多说，直接简单粗暴的开始吧 导入基因组导入基因组文件：Genomes→load geome from file→选择”reference.fa”文件 导入注释文件：file →load geome from file →选择om”reference.gff”，由于gff文件已经是按坐标顺序排列的，因此不需要重新排序。 导入甲基化数据文件这是拿到的结果，标注了甲基化的类型以及所在位点。 IGV导入的数据需要改为IGV格式，建议先学习下IGV文件的格式 可以看到，官网中给了我们IGV文件的格式例子，patient就可以改为不同的甲基化类型，由于IGV格式的文件不支持正负链的标注，所以在转换成IGV格式文件时，我把负链的甲基化值变为负值 最后修改的IGV文件如下（tab分割）： 然后通过file→load from file导入，结果如下图： 接下来，我们可以修改图片的颜色和字体大小，右键点击相应的行即可 点击file→save image即可保存最终图片","tags":"bioinformatics methylation"},{"title":"使用本地nt数据库对reads和Trinity结果进行blast","url":"/2020/08/20/2020-08-20-nt/","text":"上个笔记中，进行了共生物种的确定，由于地下部位的转录组还有一部分reads没有比对上，可能是样品污染问题，也可能含有其他的物种，所以，想使用Trinity和为比对上的reads去比对到nt数据库查看结果 nt数据库下载和构建12345wget https://ftp.ncbi.nih.gov/blast/db/FASTA/nt.gzwget https://ftp.ncbi.nih.gov/blast/db/FASTA/nr.gz.md5md5sum nt.gzgunzip nt.gznohup makeblastdb -in nt -parse_seqids -hash_index -dbtype nucl -logfile nt_logfile &amp; 这样，nt数据库就构建好了，后续的话利用这个数据库去确定物种 下载数据库和构建时间有点长，需要耐心等待 使用未比对的reads进行blast在运行STAR时，加入–outReadsUnmapped Fastx参数会将未比对的reads输出到文件，双端测序会生成mate1和mate2两个文件，利用该reads去blast 123456$cat S1-1Ufli.left.fa S1-1Ufli.right.fa&gt;S1-1.reads.fa$cat S3-1fli.left.fa S3-1fli.right.fa&gt;S3-1.reads.fa$nohup blastn -query S1-1.reads.fa -out S1-1.reads.blast -db /datadisk02/data/nt -outfmt 6 -evalue 1e-10 -num_threads 8 -qcov_hsp_perc 50.0 -num_alignments 5 2&gt; blastn1-1.log &amp;$nohup blastn -query S3-1.reads.fa -out S3-1.reads.blast -db /datadisk02/data/nt -outfmt 6 -evalue 1e-10 -num_threads 8 -qcov_hsp_perc 50.0 -num_alignments 5 2&gt; blastn3-1.log &amp; 使用Trinity组装未比对的reads后进行blast在把未比对的reads进行blast之后，我又试着把未比对的reads用Trinity进行组装，并进行blast 1234567$nohup Trinity --seqType fa --max_memory 50G --left S1-1Ufli.left.fa --right S1-1Ufli.right.fa --CPU 16 --output S1-1Ufli_trinity &amp;$nohup Trinity --seqType fa --max_memory 50G --left S3-1fli.left.fa --right S3-1fli.right.fa --CPU 16 --output S3-1fli_trinity &amp;$nohup blastn -query S1-1Ufli_trinity/Trinity.fasta -out S1-1.trinity.blast -db /datadisk02/data/nt -outfmt 6 -evalue 1e-10 -num_threads 8 -qcov_hsp_perc 50.0 -num_alignments 5 2&gt; blastn1-1t.log &amp;$nohup blastn -query S3-1fli_trinity/Trinity.fasta -out S3-1.trinity.blast -db /datadisk02/data/nt -outfmt 6 -evalue 1e-10 -num_threads 8 -qcov_hsp_perc 50.0 -num_alignments 5 2&gt; blastn3-1t.log &amp; 查看blast结果对于blast结果，主要是对比对到的基因进行汇总，去找哪个物种比对到的基因最多，涉及课题原因比对到的物种我就不在这里展示了。","tags":"bioinformatics transcriptome"},{"title":"根据转录组数据鉴定共生物种","url":"/2020/08/18/2020-08-18-sys/","text":"最近做的项目是关于地衣的转录组和基因组，拿到的结果是真菌部位的基因组以及不同时期和部位的转录组，地下部位的藻类部由于太复杂而且杂质过多不好分离就没有测基因组，目前想知道地下部位的藻类到底是什么？根据之前的观察，推测是Coccomyxa subellipsoidea，想要具体确定的话还需要进一步证明。 可以看到该地衣的地上部位是一种担子菌，地下部位不仅有藻类还有其他的物种。 转录组比对到真菌参考基因组目前有真菌的测序基因组，第一步就是想把转录组数据比对到真菌的参考基因组上 比对工具我选择STAR，使用地上部位（真菌部_Lh3-1）和地下部位（藻类部 _Lh1-1）的转录组比对到基因组上 建立索引 1S$ATR --runMode genomeGenerate --genomeDir /datadisk02/mpoly/hun_db/ --genomeFastaFiles /datadisk02/mpoly/hudsoiana.fa 比对 123$STAR --runThreadN 20 --genomeDir /datadisk02/mpoly/hun_db/ --readFilesCommand zcat --readFilesIn _Lh2-1_S110_L007_R1_001.fastq.gz _Lh2-1_S110_L007_R2_001.fastq.gz --outSAMtype BAM SortedByCoordinate --outBAMsortingThreadN 5 --outFileNamePrefix S2-1$STAR --runThreadN 20 --genomeDir /datadisk02/mpoly/hun_db/ --readFilesCommand zcat --readFilesIn _Lh3-1_S108_L007_R1_001.fastq.gz _Lh3-1_S108_L007_R2_001.fastq.gz --outSAMtype BAM SortedByCoordinate --outBAMsortingThreadN 5 --outFileNamePrefix S1-1 比对结束后我最关心的是比对率，按照预期，地下部位的比对率比地上部位低。 123456789101112131415161718192021222324$less S1-1Log.final.out Started job on | Aug 20 05:48:00 Started mapping on | Aug 20 05:48:01 Finished on | Aug 20 06:42:35 Mapping speed, Million of reads per hour | 26.61 Number of input reads | 24198466 Average input read length | 300 UNIQUE READS: Uniquely mapped reads number | 15397710 Uniquely mapped reads % | 60.89%$less S3-1Log.final.out Started job on | Aug 20 08:38:29 Started mapping on | Aug 20 08:38:30 Finished on | Aug 20 08:49:15 Mapping speed, Million of reads per hour | 134.06 Number of input reads | 24018884 Average input read length | 300 UNIQUE READS: Uniquely mapped reads number | 19151198 Uniquely mapped reads % | 79.73% 可以看到结果符合预期，地下部位的reads比对率为64%，地上部位为80%。 地下部位转录组分析接下来用地下部位的转录组分析确定共生藻，首先的想法是利用转录组数据比对到初步确定的共生藻Coccomyxa subellipsoidea上，使用Coccomyxa subellipsoidea的基因组建库进行比对 123S$ATR --runMode genomeGenerate --genomeDir /datadisk02/mpoly/cocco/ --genomeFastaFiles /datadisk02/mpoly/Coccomyxa.fa$STAR --runThreadN 20 --genomeDir /datadisk02/mpoly/cocco/ --readFilesCommand zcat --readFilesIn _Lh1-1_S110_L007_R1_001.fastq.gz _Lh1-1_S110_L007_R2_001.fastq.gz --outSAMtype BAM SortedByCoordinate --outBAMsortingThreadN 5 --outFileNamePrefix S1-1C 结果有点出乎意料，只有零点几的比对率， 123456789101112$less S1-1CLog.final.out Started job on | Aug 19 14:25:11 Started mapping on | Aug 19 14:25:16 Finished on | Aug 19 20:51:41 Mapping speed, Million of reads per hour | 3.96 Number of input reads | 25517519 Average input read length | 300 UNIQUE READS: Uniquely mapped reads number | 92457 Uniquely mapped reads % | 0.36% 由于地下部位比对到真菌部也有64%的比对率，所以我重新跑了一遍STAR，利用unmapped reads进行比对。 1234567891011121314151617181920$STAR --runThreadN 32 --genomeDir hun_db/ --readFilesIn _Lh1-1_S110_L007_R1_001.fastq.gz _Lh1-1_S110_L007_R2_001.fastq.gz --readFilesCommand zcat --outSAMtype SAM --outFileNamePrefix S1-1 --outReadsUnmapped Fastx$awk -F &quot; &quot; &#x27;&#123;print $1&#125;&#x27; S1-1Unmapped.out.mate1| awk &#x27;&#123;if (NR%4==1||NR%4=3) print&#125;&#x27; &gt; S1-1.left.fa$sed -i &quot;s/@/&gt;/g&quot; S1-1.left.fa$awk -F &quot; &quot; &#x27;&#123;print $1&#125;&#x27; S1-1Unmapped.out.mate2| awk &#x27;&#123;if (NR%4==1||NR%4=3) print&#125;&#x27; &gt; S1-1.right.fa$sed -i &quot;s/@/&gt;/g&quot; S1-1.right.fa$STAR --runThreadN 20 --genomeDir cocco/ --readFilesIn S1-1.left.fa S1-1.right.fa --outSAMtype SAM --outFileNamePrefix S1-1UC --outReadsUnmapped Fastx$less S1-1UCLog.final.out Started job on | Aug 26 10:59:26 Started mapping on | Aug 26 10:59:39 Finished on | Aug 26 15:32:14 Mapping speed, Million of reads per hour | 1.58 Number of input reads | 7180320 Average input read length | 300 UNIQUE READS: Uniquely mapped reads number | 96710 Uniquely mapped reads % | 1.35% 比对率也只有可怜的1.35%，一开始我怀疑是不是藻类物种鉴定错了，后来我用了ncbi中所有藻类的基因组，比对率都不到1%。 后来去网上搜索比对率低的原因，在github上发现相应解答,加入–outFilterScoreMinOverLread 0.3和–outFilterMatchNminOverLread 0.3 参数 12345678910111213141516171819202122232425262728$STAR --runThreadN 20 --genomeDir hun_db/ --readFilesCommand zcat --readFilesIn _Lh1-1_S110_L007_R1_001.fastq.gz _Lh1-1_S110_L007_R2_001.fastq.gz --outFileNamePrefix S1-1fli --outReadsUnmapped Fastx --outSAMtype SAM --outFilterScoreMinOverLread 0.3 --outFilterMatchNminOverLread 0.3$less S1-1fliLog.finall.out Started job on | Aug 27 09:52:31 Started mapping on | Aug 27 09:52:37 Finished on | Aug 27 13:02:11 Mapping speed, Million of reads per hour | 8.08 Number of input reads | 25517519 Average input read length | 300 UNIQUE READS: Uniquely mapped reads number | 16371292 Uniquely mapped reads % | 64.16%$STAR --runThreadN 20 --genomeDir cocco/ --readFilesCommand zcat --readFilesIn _Lh1-1_S110_L007_R1_001.fastq.gz _Lh1-1_S110_L007_R2_001.fastq.gz --outFileNamePrefix S1-1Cfli --outReadsUnmapped Fastx --outSAMtype SAM --outFilterScoreMinOverLread 0.3 --outFilterMatchNminOverLread 0.3$less S1-1CfliLog.final.out Started job on | Aug 27 09:52:51 Started mapping on | Aug 27 09:52:53 Finished on | Aug 28 04:02:41 Mapping speed, Million of reads per hour | 1.40 Number of input reads | 25517519 Average input read length | 300 UNIQUE READS: Uniquely mapped reads number | 1475579 Uniquely mapped reads % | 5.78% 对率有5.78%，提高了一点。 接下来，我使用真菌的unmapped reads进行比对，看看没有比到真菌上的reads有多少是藻类的。 12345678910111213141516171819$awk -F &quot; &quot; &#x27;&#123;print $1&#125;&#x27; S1-1fliUnmapped.out.mate1| awk &#x27;&#123;if (NR%4==1||NR%4=3) print&#125;&#x27; &gt; S1-1fli.left.fa$sed -i &quot;s/@/&gt;/g&quot; S1-1.left.fa$awk -F &quot; &quot; &#x27;&#123;print $1&#125;&#x27; S1-1fliUnmapped.out.mate2| awk &#x27;&#123;if (NR%4==1||NR%4=3) print&#125;&#x27; &gt; S1-1fli.right.fa$sed -i &quot;s/@/&gt;/g&quot; S1-1.right.fa$STAR --runThreadN 20 --genomeDir cocco/ --readFilesIn S1-1fli.left.fa S1-1fli.right.fa --outSAMtype SAM --outFileNamePrefix S1-1Ufli --outReadsUnmapped Fastx --outFilterScoreMinOverLread 0.3 --outFilterMatchNminOverLread 0.3$less S1-1UfliLog.final.out Started job on | Aug 27 14:28:39 Started mapping on | Aug 27 14:28:44 Finished on | Aug 27 21:38:00 Mapping speed, Million of reads per hour | 0.86 Number of input reads | 6123885 Average input read length | 300 UNIQUE READS: Uniquely mapped reads number | 1441904 Uniquely mapped reads % | 23.55% 也就是说，在剩余的36%未比对的reads中有23%属于Coccomyxa，总比对率有70%左右，地上部位按照相同的步骤进行比对有83%的比对率，这个现象也正常，因为地下部位的组织特别复杂，在取样时肯定包含了很多杂质，比对率肯定比地上部位低。 总结目前已经可以确定地下部位的藻类就是Coccomyxa属的，是不是Coccomyxa subellipsoidea目前还不确定，接下来的工作是确定地下部位未比对上reads的所属。","tags":"bioinformatics transcriptome"},{"title":"基因共表达网络图的绘制","url":"/2020/08/10/2020-08-10-cytoscape/","text":"前面的教程已经进行了WGCNA分析并将各个模块的网络图绘制文件导出，接下来将进行共表达网络的绘制，本次教程依旧根据PlantTech的Cytoscape课程编写，希望对大家有所帮助。 WGCNA教程 WGCNA分析原理 WGCNA应用场景 WGCNA分析实践 1.数据导入WGCNA分析后有许多模块，我选择上次分析中与Luminal 亚型最相关的pink模块进行分析。 打开cytoscape， 选择File&gt;import&gt;import network from file,打开WGCNA分析中得到的CytoscapeInput-edges-pink.txt文件，可以看到如下界面 接下来我们需要修改每个表头（每一列的属性），改成如下即可 可以看到做出来的网络非常丑，不着急，下一步进行网络的修改，美化一下 2.修改网络点击Tools&gt;networkanalyzer&gt;network analysis&gt;analyze network弹出以下界面 选择第二个的无方向网络，接着选择node degree distribution，点击下方的Visualize Parameters。 出现四个选择项：上边两个是调节node的，下边两个是调节edge的，大家可以根据自己的需要去选择。 可以看到所有的node已经根据节点数的多少有不同的大小。 在最下方的表格中将数据按照节点数目排序，将大于100的node选出，在name一列选择相应的node然后右键select node from selected rows可以将想要的node选出，然后拖拽到合适的位置。 选中degree大于100的所有点，点击layout&gt;circular layout&gt;select node only ,将选中的nodes按照圆形排列 出现了奇怪的图，点击layout&gt;setting,设置Circle size的大小，可以设置圆的大小。 最后，我们再修改一下node和egde的颜色 左侧的设置栏我们可以修改node的颜色以及标签的颜色 然后点击下方的edge，修改edge的状态。在做WGCNA分析时，不同基因的之间的相关度有一个weight值，我们可以根据weight值的大小判断两个基因之间的相关性。 将Edge color to arrows打钩，选择最上方的Color（Unselected）选项。column选择weight，mapping type选择continuous mapping选项 点击那个渐变的色块，我们可以修改颜色 点击上面的三个小箭头，然后点击下方的Edge Color，可以对不同位置的颜色进行修改。 最后放上成品图，可能有点丑，大家根据自己的需要自行修改即可 3.数据导出最后，我们可以将网络的表格文件和网络图导出 首先导出网络表格，点击最右侧的export，将表格文件导出至想要的位置即可 接下来是导出图片，选择file&gt;export&gt;network to image,选择想要的图片文件格式，需要注意，保存图片时其实是对主界面进行一个截图操作，先将网络调成自己想要的大小然后再导出即可 最后我们也可以将图例导出，选择create legend，保存想要的图例格式即可 后记该课程主要借鉴了PlantTech的Cytoscape课程编写，视频我已下载，大家有需要可以去百度云下载（提取码：5z41） 视频压缩包解压密码是我博客about界面下的一行小字（出自《蒲公英女孩》，标点是英文），如果链接炸了去博客找我联系方式。 网络图绘制教程个人感觉还是用视频教程更好，目前有录制视频的打算，录制好之后我会放到B站，主要还是看自己的时间允不允许。","tags":"bioinformatics cytoscape"},{"title":"WGCNA学习：WGCNA分析实战","url":"/2020/08/08/2020-08-08-WGCNA3/","text":"WGCNA笔记第三弹 WGCNA分析原理 WGCNA应用场景 WGCNA分析实践 本代码借鉴了生信技能树的WGCNA教程以及PlanTech的WGCNA课程编写，转载请注明出处 1.WGCNA安装12345678910111213141516171819&gt; install.packages(&quot;BiocManager&quot;)&gt; BiocManager::install(&quot;WGCNA&quot;)&gt; library(WGCNA)载入需要的程辑包：dynamicTreeCut载入需要的程辑包：fastcluster载入程辑包：‘fastcluster’The following object is masked from ‘package:stats’: hclust载入程辑包：‘WGCNA’The following object is masked from ‘package:stats’: cor 2.数据准备与读入2.1数据准备需要两个数据 表达矩阵（All_fpkm.list） 表型文件（pheno.txt）,需要注意表型文件分为两类，连续变量型与分类变量型. 连续变量 分类变量 2.2 数据读入12345678910111213141516171819202122232425library(WGCNA)library(reshape2)library(stringr)setwd(&#x27;D:/data/wgcna/Categorical&#x27;)options(stringsAsFactors = FALSE)# 在读入数据时，遇到字符串后，不要将其转换成因子，仍然保留为字符串格式enableWGCNAThreads()#打开多线程##====================step 1 :数据读入RNAseq_voom &lt;- fpkm## 因为WGCNA针对的是基因进行聚类，而一般我们的聚类是针对样本用hclust即可，所以这个时候需要转置WGCNA_matrix = t(RNAseq_voom[order(apply(RNAseq_voom,1,mad), decreasing = T)[1:5000],])datExpr &lt;- WGCNA_matrix ## top 5000 mad genes#明确样本数和基因nGenes = ncol(datExpr)nSamples = nrow(datExpr)#首先针对样本做个系统聚类datExpr_tree&lt;-hclust(dist(datExpr), method = &quot;average&quot;)par(mar = c(0,5,2,0))png(&quot;img/step1-sample-cluster.png&quot;,width = 800,height = 600)plot(datExpr_tree, main = &quot;Sample clustering&quot;, sub=&quot;&quot;, xlab=&quot;&quot;, cex.lab = 2, cex.axis = 1, cex.main = 1,cex.lab=1)dev.off() 3. β值估计123456789101112131415161718192021222324##====================step 2：β值确定====datExpr[1:4,1:4]powers = c(c(1:10), seq(from = 12, to=20, by=2))#设置beta值的取值范围sft = pickSoftThreshold(datExpr, RsquaredCut = 0.9,powerVector = powers, verbose = 5)#设置网络构建参数选择范围，计算无尺度分布拓扑矩阵png(&quot;img/step2-beta-value.png&quot;,width = 800,height = 600)par(mfrow = c(1,2));cex1 = 0.9;# Scale-free topology fit index as a function of the soft-thresholding powerplot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2], xlab=&quot;Soft Threshold (power)&quot;,ylab=&quot;Scale Free Topology Model Fit,signed R^2&quot;,type=&quot;n&quot;, main = paste(&quot;Scale independence&quot;));text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2], labels=powers,cex=cex1,col=&quot;red&quot;);# this line corresponds to using an R^2 cut-off of habline(h=0.90,col=&quot;red&quot;)# Mean connectivity as a function of the soft-thresholding powerplot(sft$fitIndices[,1], sft$fitIndices[,5], xlab=&quot;Soft Threshold (power)&quot;,ylab=&quot;Mean Connectivity&quot;, type=&quot;n&quot;, main = paste(&quot;Mean connectivity&quot;))text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col=&quot;red&quot;)dev.off() 可以确定最佳β值为6 4. 一步法构建共表达矩阵最核心的一步，同时也是最耗费计算资源的一步 12345678910111213141516##====================step 3:自动构建WGCNA模型==================# 首先是一步法完成网络构建net = blockwiseModules( datExpr, power = sft$powerEstimate, #软阈值，前面计算出来的 maxBlockSize = 6000, #最大block大小，将所有基因放在一个block中 TOMType = &quot;unsigned&quot;, #选择unsigned，使用标准TOM矩阵 deepSplit = 2, minModuleSize = 30, #剪切树参数，deepSplit取值0-4 mergeCutHeight = 0.25, # 模块合并参数，越大模块越少 numericLabels = TRUE, # T返回数字，F返回颜色 pamRespectsDendro = FALSE, saveTOMs = TRUE, saveTOMFileBase = &quot;FPKM-TOM&quot;, loadTOMs = TRUE, verbose = 3) 5. 模块可视化12345678910111213141516171819202122232425262728293031323334353637383940414243##===============================step4:模块可视化=========================# Convert labels to colors for plottingmergedColors = labels2colors(net$colors)table(mergedColors)moduleColors=mergedColors# Plot the dendrogram and the module colors underneathpng(&quot;img/step4-genes-modules.png&quot;,width = 800,height = 600)plotDendroAndColors(net$dendrograms[[1]], mergedColors[net$blockGenes[[1]]], &quot;Module colors&quot;, dendroLabels = FALSE, hang = 0.03, addGuide = TRUE, guideHang = 0.05)dev.off()## assign all of the gene to their corresponding module## hclust for the genes.#明确样本数和基因nGenes = ncol(datExpr)nSamples = nrow(datExpr)#首先针对样本做个系统聚类datExpr_tree&lt;-hclust(dist(datExpr), method = &quot;average&quot;)par(mar = c(0,5,2,0))plot(datExpr_tree, main = &quot;Sample clustering&quot;, sub=&quot;&quot;, xlab=&quot;&quot;, cex.lab = 2, cex.axis = 1, cex.main = 1,cex.lab=1)## 如果这个时候样本是有性状，或者临床表型的，可以加进去看看是否聚类合理#针对前面构造的样品矩阵添加对应颜色sample_colors &lt;- numbers2colors(as.numeric(factor(datTraits$subtype)), colors = c(&quot;white&quot;,&quot;blue&quot;,&quot;red&quot;,&quot;green&quot;),signed = FALSE)## 这个给样品添加对应颜色的代码需要自行修改以适应自己的数据分析项目# sample_colors &lt;- numbers2colors( datTraits ,signed = FALSE)## 如果样品有多种分类情况，而且 datTraits 里面都是分类信息，那么可以直接用上面代码，当然，这样给的颜色不明显，意义不大#10个样品的系统聚类树及性状热图par(mar = c(1,4,3,1),cex=0.8)png(&quot;img/sample-subtype-cluster.png&quot;,width = 800,height = 600)plotDendroAndColors(datExpr_tree, sample_colors, groupLabels = colnames(sample), cex.dendroLabels = 0.8, marAll = c(1, 4, 3, 1), cex.rowText = 0.01, main = &quot;Sample dendrogram and trait heatmap&quot;)dev.off() 可以看到模块用不同的颜色来标注，灰色模块是无法归类于任何模块的基因，在后续分析的时候不需要考虑 6.模块与性状的关系12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849##===============================step5:模块与性状的关系===================table(datTraits$subtype)nGenes = ncol(datExpr)nSamples = nrow(datExpr)design=model.matrix(~0+ datTraits$subtype)colnames(design)=levels(datTraits$subtype)moduleColors &lt;- labels2colors(net$colors)# Recalculate MEs with color labelsMEs0 = moduleEigengenes(datExpr, moduleColors)$eigengenesMEs = orderMEs(MEs0); ##不同颜色的模块的ME值矩 (样本vs模块)# 输出每个基因所在的模块，以及与该模块的KME值file.remove(&#x27;All_Gene_KME.txt&#x27;)for(module in substring(colnames(MEs),3))&#123; if(module == &quot;grey&quot;) next ME=as.data.frame(MEs[,paste(&quot;ME&quot;,module,sep=&quot;&quot;)]) colnames(ME)=module datModExpr=datExpr[,moduleColors==module] datKME = signedKME(datModExpr, ME) datKME=cbind(datKME,rep(module,length(datKME))) write.table(datKME,quote = F,row.names = T,append = T,file = &quot;All_Gene_KME.txt&quot;,col.names = F)&#125;moduleTraitCor = cor(MEs, design , use = &quot;p&quot;);moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples)sizeGrWindow(10,6)# Will display correlations and their p-valuestextMatrix = paste(signif(moduleTraitCor, 2), &quot;\\n(&quot;, signif(moduleTraitPvalue, 1), &quot;)&quot;, sep = &quot;&quot;);dim(textMatrix) = dim(moduleTraitCor)png(&quot;img/step5-Module-trait-relationships.png&quot;,width = 800,height = 600)par(mar = c(6, 8.5, 3, 3));# Display the correlation values within a heatmap plotlabeledHeatmap(Matrix = moduleTraitCor, xLabels = colnames(design), yLabels = names(MEs), ySymbols = names(MEs), colorLabels = FALSE, colors = blueWhiteRed(50), textMatrix = textMatrix, setStdMargins = FALSE, cex.text = 0.5, zlim = c(-1,1), main = paste(&quot;Module-trait relationships&quot;))dev.off()#绘制两两模块间的邻接矩阵png(&quot;img/wgcna.adjacency.heatmap.pdf&quot;,height = 800,width = 600)plotEigengeneNetworks(MEs, &quot;Eigengene adjacency heatmap&quot;,plotDendrograms = F, marDendro = c(4,4,2,4))dev.off() 可以看到不同的模块与不同的性状是有不同的相关性的，在后续分析的时候我们可以选择感兴趣的模块进行分析。 两两模块之间的邻接矩阵，主要看不同模块之间的相关性 7. 选择感兴趣的模块进行分析123456789101112131415161718192021222324252627282930313233343536373839##===============================step 6：感兴趣性状的模块的具体基因分析=====# 查看第五步出图：step5-Module-trait-relationships.png# 发现跟 Luminal 亚型 最相关的是 pink 模块# 所以接下来就分析这两个Luminal = as.data.frame(design[,3])names(Luminal) = &quot;Luminal&quot;module = &quot;pink&quot;# names (colors) of the modulesmodNames = substring(names(MEs), 3)geneModuleMembership = as.data.frame(cor(datExpr, MEs, use = &quot;p&quot;))## 算出每个模块跟基因的皮尔森相关系数矩阵## MEs是每个模块在每个样本里面的## datExpr是每个基因在每个样本的表达量MMPvalue = as.data.frame(corPvalueStudent(as.matrix(geneModuleMembership), nSamples))names(geneModuleMembership) = paste(&quot;MM&quot;, modNames, sep=&quot;&quot;)names(MMPvalue) = paste(&quot;p.MM&quot;, modNames, sep=&quot;&quot;)geneModuleMembership[1:4,1:4]## 只有连续型性状才能只有计算## 这里把是否属 Luminal 表型这个变量0,1进行数值化Luminal = as.data.frame(design[,3])names(Luminal) = &quot;Luminal&quot;geneTraitSignificance = as.data.frame(cor(datExpr, Luminal, use = &quot;p&quot;))GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples))names(geneTraitSignificance) = paste(&quot;GS.&quot;, names(Luminal), sep=&quot;&quot;)names(GSPvalue) = paste(&quot;p.GS.&quot;, names(Luminal), sep=&quot;&quot;)module = &quot;pink&quot;column = match(module, modNames)moduleGenes = moduleColors==modulepng(&quot;step6-Module_membership-gene_significance.png&quot;,width = 800,height = 600)#sizeGrWindow(7, 7)par(mfrow = c(1,1))verboseScatterplot(abs(geneModuleMembership[moduleGenes, column]), abs(geneTraitSignificance[moduleGenes, 1]), xlab = paste(&quot;Module Membership in&quot;, module, &quot;module&quot;), ylab = &quot;Gene significance for Luminal&quot;, main = paste(&quot;Module membership vs. gene significance\\n&quot;), cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2, col =module)dev.off() 由于是分类变量，只能按照0至1量化，可以看出模块内的基因与表型有很好的线性关系 然后再绘制性状与模块的关系 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465# Recalculate module eigengenesMEs = moduleEigengenes(datExpr, moduleColors)$eigengenes## 只有连续型性状才能只有计算## 这里把是否属 Luminal 表型这个变量0,1进行数值化Luminal = as.data.frame(design[,3]);names(Luminal) = &quot;Luminal&quot;# Add the weight to existing module eigengenesMET = orderMEs(cbind(MEs, Luminal))# Plot the relationships among the eigengenes and the traitsizeGrWindow(5,7.5);par(cex = 0.9)png(&quot;img/step6-Eigengene-dendrogram.png&quot;,width = 800,height = 600)plotEigengeneNetworks(MET, &quot;&quot;, marDendro = c(0,4,1,2), marHeatmap = c(3,4,1,2), cex.lab = 0.8, xLabelsAngle = 90)dev.off()# Plot the dendrogramsizeGrWindow(6,6);par(cex = 1.0)## 模块的进化树png(&quot;img/step6-Eigengene-dendrogram-hclust.png&quot;,width = 800,height = 600)plotEigengeneNetworks(MET, &quot;Eigengene dendrogram&quot;, marDendro = c(0,4,2,0), plotHeatmaps = FALSE)dev.off()# Plot the heatmap matrix (note: this plot will overwrite the dendrogram plot)par(cex = 1.0)## 性状与模块热png(&quot;img/step6-Eigengene-adjacency-heatmap.png&quot;,width = 800,height = 600)plotEigengeneNetworks(MET, &quot;Eigengene adjacency heatmap&quot;, marHeatmap = c(3,4,2,2), plotDendrograms = FALSE, xLabelsAngle = 90)dev.off()# Recalculate module eigengenesMEs = moduleEigengenes(datExpr, moduleColors)$eigengenes## 只有连续型性状才能只有计算## 这里把是否属 Luminal 表型这个变量0,1进行数值化Luminal = as.data.frame(design[,3]);names(Luminal) = &quot;Luminal&quot;# Add the weight to existing module eigengenesMET = orderMEs(cbind(MEs, Luminal))# Plot the relationships among the eigengenes and the traitsizeGrWindow(5,7.5);par(cex = 0.9)png(&quot;img/step6-Eigengene-dendrogram.png&quot;,width = 800,height = 600)plotEigengeneNetworks(MET, &quot;&quot;, marDendro = c(0,4,1,2), marHeatmap = c(3,4,1,2), cex.lab = 0.8, xLabelsAngle = 90)dev.off()# Plot the dendrogramsizeGrWindow(6,6);par(cex = 1.0)## 模块的进化树png(&quot;img/step6-Eigengene-dendrogram-hclust.png&quot;,width = 800,height = 600)plotEigengeneNetworks(MET, &quot;Eigengene dendrogram&quot;, marDendro = c(0,4,2,0), plotHeatmaps = FALSE)dev.off()# Plot the heatmap matrix (note: this plot will overwrite the dendrogram plot)par(cex = 1.0)## 性状与模块热png(&quot;img/step6-Eigengene-adjacency-heatmap.png&quot;,width = 800,height = 600)plotEigengeneNetworks(MET, &quot;Eigengene adjacency heatmap&quot;, marHeatmap = c(3,4,2,2), plotDendrograms = FALSE, xLabelsAngle = 90)dev.off() 8.网络的可视化123456789101112131415161718192021222324252627282930# 主要是可视化 TOM矩阵，WGCNA的标准配图# 然后可视化不同 模块 的相关性 热图# 不同模块的层次聚类图# 还有模块诊断，主要是 intramodular connectivitynGenes = ncol(datExpr)nSamples = nrow(datExpr)geneTree = net$dendrograms[[1]];dissTOM = 1-TOMsimilarityFromExpr(datExpr, power = 6);plotTOM = dissTOM^7;diag(plotTOM) = NA;#TOMplot(plotTOM, geneTree, moduleColors, main = &quot;Network heatmap plot, all genes&quot;)nSelect = 400# For reproducibility, we set the random seedset.seed(10);select = sample(nGenes, size = nSelect);selectTOM = dissTOM[select, select];# There’s no simple way of restricting a clustering tree to a subset of genes, so we must re-cluster.selectTree = hclust(as.dist(selectTOM), method = &quot;average&quot;)selectColors = moduleColors[select];# Open a graphical windowsizeGrWindow(9,9)# Taking the dissimilarity to a power, say 10, makes the plot more informative by effectively changing# the color palette; setting the diagonal to NA also improves the clarity of the plotplotDiss = selectTOM^7;diag(plotDiss) = NA;png(&quot;img/step7-Network-heatmap.png&quot;,width = 800,height = 600) TOMplot(plotDiss, selectTree, selectColors, main = &quot;Network heatmap plot, selected genes&quot;)dev.off() 不知道为啥，这张图有点奇怪 9. 模块的导出12345678910111213141516171819202122232425##===============================step 8：模块导出 =========# 导出模块内部基因的连接关系，进入其它可视化软件# 比如 cytoscape软件等等。# Recalculate topological overlapTOM = TOMsimilarityFromExpr(datExpr, power = 6);# Select modulemodule = &quot;pink&quot;;# Select module probesprobes = colnames(datExpr) ## 我们例子里面的probe就是基因inModule = (moduleColors==module)modProbes = probes[inModule]## 也是提取指定模块的基因名# Select the corresponding Topological OverlapmodTOM = TOM[inModule, inModule]dimnames(modTOM) = list(modProbes, modProbes)## 模块对应的基因关系矩cyt = exportNetworkToCytoscape( modTOM, edgeFile = paste(&quot;CytoscapeInput-edges-&quot;, paste(module, collapse=&quot;-&quot;), &quot;.txt&quot;, sep=&quot;&quot;), nodeFile = paste(&quot;CytoscapeInput-nodes-&quot;, paste(module, collapse=&quot;-&quot;), &quot;.txt&quot;, sep=&quot;&quot;), weighted = TRUE, threshold = 0.02, nodeNames = modProbes, nodeAttr = moduleColors[inModule]) 模块导出后可以用cytoscape构建网络，后面的教程会教大家利用这个文件构建网络图 后记本次WGCNA的代码结合了生信技能树和PlantTech的WGCNA教程，原始数据也来自这两个教程，我将代码和原始数据上传到自己的github中，其中PlantTech课程是收费课程，我已将其下载，大家有需要可以去百度云下载（提取码：es41） 视频压缩包解压密码是我博客about界面下的一行小字（出自《蒲公英女孩》，标点是英文），如果链接炸了去博客找我联系方式。","tags":"bioinformatics wgcna"},{"title":"WGCNA学习：WGCNA应用场景与实例解读","url":"/2020/08/05/2020-08-05-WGCNA2/","text":"WGCNA笔记第二弹 WGCNA分析原理 WGCNA应用场景 WGCNA分析实践 1.WGCNA应用场景 不同组织样品 时间序列样品：生长发育，胁迫处理 单个材料：相同处理不同时间，不同处理相同时间，不同处理不同时间 两个材料：相同处理不同时间，不同处理相同时间，不同处理不同时间 表型数据：同级相关表型的数据 2.WGCNA实验设计 1.时间序列样品，两个材料相同处理，可以一起做WGCNA分析，也可以分别做然后比较，相同材料不同处理之间也一样 2.同一物种，不同来源的转录组数据，可以放在一起做WGCNA，也可以分开来比较 3.一般建议15个样品以上进行WGCNA分析有生物学意义，可以使5个时间点三个重复的15个样品 4.表型数据，建议收集可以统计量化的性状数据，可将模块和表型数据关联分析，有助于筛选关键基因模块和基因来解释相关表型 3.单个材料案例Floral Transcriptomes in Woodland Strawberry Uncover Developing Receptacle and Anther Gene Networks 野草莓花器官转录组解析花发育中花托和花药的基因调控网络 3.1方案设计 单个材料不同组织样品 取材野草莓花器官不同组织 从不同发育时期的花器官分离花药、花粉、心皮、花托等组织，再加上小苗叶片，共17个组织。每个组织两个重复，共34个样本。 3.2 转录组数据整体分析 3.2 鉴定配子体孢子体相关基因在不同发育时期花药中共同表达的基因鉴定为雄性孢子体特异性基因 GO富集显示，雄性孢子基因集主要为代谢生物学过程，如小分子、有机酸、细胞内酮代谢等等 在花粉和小孢子特异表达的基因中共同表达的基因鉴定为配子体特异基因 3.3花发育过程转录组的时空表达模式分析对所有差异表达的基因进行K-means聚类分析鉴定19个cluster，呈现出发育时期和组织特异性表达模式，如C1 C22为心皮特异性 进一步将19个cluster合并为10个supercluster，并进行功能富集分析，如心皮特异性的supercluster，并进行功能富集分析。如心皮特异性的supercluster1富集的功能为DNA合成。 对cluster中的161个转录因子进行表达量聚类分析，也呈现发育时期和组织特异性的表达模式。 3.4 WGCNA构建共表达网络用差异表达基因进行WGCNA分析，鉴定了23个基因模块。 用每个模块的epigengene值与不同组织样品进行关联分析，鉴定组织紧密关联的基因模块。 12个模块与单一的组织样品特异性高度相关，如blue模块与花粉（pollen）特异性相关。 WGCNA鉴定的组织特异性基因集合与K-means的结果相符合 WGCNA鉴定的花托特异性模块（light yellow）和幼嫩花（stage1-4）特异性模块（dark red），在K-means的cluster中并没有 3.5 组织特异性表达模块WGCNA鉴定的花托特异性模块（light yellow）和幼嫩花（stage1-4）特异性模块，在K-means的cluster中并没有。 分析了Dark red模块和Light yellow模块epigengene在各样品中的表达模式 热图呈现了Dark red模块和Light yellow模块中每个基因在各个样品中的表达模式 3.6 花托特异性模块内部分析关键基因（hub gene）：模块内网络中连接度较多的基因。 关注模块中的转录因子：花托特异性模块111个基因中有27个转录因子，重点分析这些转录因子。 大部分hub gene为参与调控分生组织的转录因子，如WOX、GRS、NAC等。 hub gene中连接度最高的为GRS转录因子家族的FveLOM3。拟南芥中三突变体lom1 lom2 lom3表现出分生组织异常的表型。因此FveLOM3可能是花托发育的关键调控因子。 此外，高连接度的hub gene还包括一个B3 domain转录因子、一个Myb转录因子和WUS同源基因 3.7 花药发育差异基因分析stage9花药中上调表达的1453个基因中，211个编码FBX domain蛋白。在野草莓基因组中包含820个FBX基因。大比例FBX上调表达说明在花药减数分裂这个时期发生了大量的蛋白降解。 K-means的cluster富集分析中花药-9的cluster富集的为蛋白降解。 FBX基因表达聚类热图分析显示，大部分FBX只在stage9时期暂时高表达，随后的stage10和11下调表达。 在花药发育过程中，共296个FBX基因差异表达，其中6个亚家族占的比例较大，包括FBD、LRR、DUF295 3.8花药特异性模块分析花药stage9特异性基因模块为pink，其中包含了37个FBX基因。 通过筛选连接度较高的基因来鉴定hub gene。5个基因的度数目高于200。 其中4个基因参与蛋白降解，F-box、WD-repeat 3.8 小结：WGCNA分析思路实验方案：单个材料，不同组织样品，所有差异表达基因进行WGCNA分析 通过模块Epigengene值与不同组织样本进行关联分析，鉴定组织特异性模块 hub基因筛选 连接度较高的基因 重点关注转录因子（花托特异性模块） 前期结果中的目标基因（话要特异性模块中的FBX） 4.两个材料 Global transcriptome and coexpression network analyses reveal cultivara specific molecular signatures associated with seed development and seed size/weight determination in chickpea 4.1方案设计 4.2 两个鹰嘴豆栽培种的种子发育表性分析两个鹰嘴豆栽培种Himchana1(小种子，平均100粒种子重量为13.1g)和JGK3(大种子，平均100粒种子重量为53.3g).种子发育的7个时间段（S1-S7),分别代表了种子发育的三个阶段：胚芽发育（S1-S3)、早期和中期成熟阶段（籽粒灌浆，S4-S5)、成熟晚期（种子干燥，S6-S7) 种子的不同发育阶段S1-S7依据授粉天数（Day after Pollination,DAP)划分，5、9.12,19,25、30和40 DAP分别为S1、S2、S3.S4、S5、S6和S7. 表型分析：种子发育不同时间点的种子重量和大小的统计数据比较。 4.3 两个材料种子发育过程转录组的整体解析为了分析两个材料种子发育过程转录组动态变化的差异，基于16个组织样品所有表达基因的表达量的斯皮尔曼相关系数（SCC）进行层次聚类和主成分分析（PCA）。 两个材料中相同发育时期组织样品表现出很高的相关性。两个材料叶片聚在一起，与所有种子样品表现出明显差异。两个材料的S3有差异，JGK3-S3与S2更接近，而HC1-S3与S4更像。这说明HC1在种子发育早期比JGK3生长发育得更快。虽然两个材料S5也聚类在一起，但是关系并没有其他时期的紧密，也呈现一定的差异。因此，S3和S5可能是两个材料种子大小和重量差异的关键发育时期 4.4 种子发育过程中差异基因表达分析鉴定种子发育过程中每个时期特异表达的基因 各个时期特异表达的基因数目差异很大，S2最少，S5最多。两个材料中各自时期特异表达的基因数目也有所不同，HC1在S2最少，JGK3则在S6最少，但是两者在S5都是最多的。两个材料中均时期特异表达的基因比例也不小，表达量层次聚类分析呈现出明显的发育时期特异性。说明每个发育阶段有着自己独立的发育程序。Go富集分析，主要为生殖过程、细胞壁组装、细胞周期和细胞分裂、碳代谢等，这些都是已知参与种子发育的。有些GOterm在两个材料中均富集，有些只在一个材料中富集。 4.5两个材料差异表达基因分析定两个材料在种子发育每个时期的显著差异表达基因集。HC1 VS JGK3,共有8562个基因上调表达，9023个下调表达。差异基因数目最多的是S7，其次为S3；最少的为S4。重点分析了TF，许多TF家族在JGK3中显著上调或下调模式。GO富集显示，在JGK3中上调表达基因主要富集在一些细胞分裂相关term中，尤其在S3中。代谢通路注释分析显示，在S3时期某些代谢通路呈现显著的差异。在JGK3中淀粉代谢和光合作用相关基因激活表达，细胞周期和细胞分裂相关基因也上调表达。在S3时期JGK3中细胞壁合成和修饰的许多基因上调表达。 4.6 WGCNA鉴定共表达基因模块WGCNA分别鉴定了HC1的27个基因模块和JGK3的21个基因模块。所有模块中都包含TF，数量从几个到几百个不等。模块和发育时期样品关联分析（PCC），13个HC1模块和6个JGK3模块与发育时期样品高度关联（0.6以上）。许多模块不仅与一个发育时期关联，一些模块仅与某个特定发育时期样品关联。如JGK 3的lightyellow模块与S4高度特异关联（0.93）.模块的GO富集分析结果与差异表达基因分析结果相一致。如，种子发育早期相关模块主要富集的GO term为细胞分离、细胞形态、细胞壁组装、基因表达调控。 4.7 两个材料的基因模块保守性分析鉴定两个材料共表达基因模块的保守性。计算不同模块中的相同基因数目，然后通过Fisher精确检验的P-value值评估显著性。两个材料中大部分保守模块关联的是相似的种子发育时期样品。少部分保守模块在不同材料中表型不同的发育时期关联性和转录激活时期。鉴定了材料特异性模块，如HC1的3个模块（organe-HS4等）和4个JGK3模块（如lightgreen-JS4）。HC1特异性模块主要富集GO term为转录调控、细胞程序性死亡、衰老等；JGK3特异性模块富集的为DNA复制、细胞分裂、基因表达、蛋白修饰等。 4.8 种子发育和种子大小、重量相关转录调控模块分析目的：鉴定JGK3发育S3和S5的转录调控网络。主要为TFs及其共表达的靶基因（包含TFs结合位点，motif显著富集分析） 候选模块：HC1和JGK3中与S3、S5时期相关的共表达基因模块 JGK3的S3时期相关模块brown转录调控网络：显著富集的DNA motifs有ATHB1、JASE1等，相关的TFs有woX9、PDF2、RLT2等，以及靶基因相关的GO term，基因表达调控、细胞壁组装、表达大小调控等。 比较JS3和HS3模块转录调控网络，大部分组分是相同的，但是也有一些材料特异性的组分。 同样也分析了JS5和HS5相关模块转录调控网络组分，包括DNA motifs、TFs，以及GO term。 JS5和HS5的调控网络大部分组分是相同的，但是也有一些材料特异性的组分。 该分析鉴定了种子发育中的关键调控因子，两个材料的调控相似但不完全一样。 4.9 种子发育和种子大小、重量相关转录调控模块分析一些基因模块在两个材料的S3和S5时期表现出相反表达模式。 主要有3类：HS3下调JS3上调，HS3上调JS3下调，HS5下调JS5上调。 这些模块可能与两个材料种子发育不同相关，进行转录调控网络分析。 HJ3上调JS3下调转录调控网络鉴定：motifs、TF、GOterms。 S3时期的top hub基因表达模式反应了这不同模块中所有基因的表达模式。 这些网络中的许多motifs、TFs都是已知参与调控种子大小、重量的重要调控因子。 4.10 小结实验方案：两个材料，不同发育时期样品，所有差异表达基因进行WGCNA分析。两个材料分别进行WGCNA分析鉴定各自的基因模块。通过模块Epigengene值与不同发育时期样品进行关联分析，鉴定时期特异性模块，并通过模块GO功能富集来解析各发育时期的调控机制。两个材料模块保守性分析，鉴定保守性和特异性模块，通过Go富集解析各自表型。模块筛选：依据前面研究结果S3和S5两个材料差异最大，重点分析这两个时期相关的基因模块。依据表达模式筛选在两个材料的S3和S5时期表现出相反表达模式的模块。转录调控网络关键基因筛选：TFs和包含显著富集motifs的靶基因、top 20/40 hub gene。 5. 表型数据Root Cell-Specific Regulators of Phosphate-Dependent Growth 5.1 PRCE在根部的细胞特异性表达验证和T-DNA插入突变体筛选构建了12个PRCE基因的启动子-GFP转基因line，验证它们是否呈现细胞特异性表达模式。其中10个基因表现出严格的细胞类型特异性表达模式（皮层、中柱鞘、中柱、木质部薄壁细胞等）。筛选鉴定了11个PRCE基因的T-DNA插入纯合突变体，其中10个为功能缺失突变体，1个为功能获得型突变体。 5.2 突变体表型分析prce突变体在磷足够和缺乏条件下，植物根和芽中磷的浓度变化。prce突变体在磷足够和缺乏条件下，植物生长情况，根和芽中生物量的变化。大部分prce突变体表现出明显不同于野生型（Col-0)的特征，包括所有定量的生理表型。 5.3 prce突变体根中相应基因的转录水平变化选取以前发表文献中的缺磷的两个转录组数据集，包含不同的基因型材料，其中Col-0和phr1-1为对照材料。 在两个数据集中，Col-0的63%和6%的PSR基因在phr1-1中没有变化；许多野生型PSR基因在prce突变体中呈现出不同的表达。 在两个数据集中筛选了Col-0中差异表达2倍以上的831个磷响应核心基因，进步通过层次聚类分析其在不同基因型材料中的表达模式。并依据基因表达模式分析不同基因型样品之间的关系。 S6k2突变体表现出与phr1-1类似的缺磷反应，而wdd1突变体表现出类似Col-0的缺磷反应。 5.4 鉴定prce突变体相关共表达网络对32个RNA-seq数据集（磷足够和磷缺乏）的所有表达转录本分别进行WGCNA分析，都鉴定了18个共表达基因模块。计算模块的特征值（Eigengene)，并通过特征值来计算模块和生理性状（数量性状，如磷含量和浓度、生物量、根相对生长速率、初根根长等)的相关性。重点关注与性状显著相关的10个模块，以及在不同基因型中呈现相反表达模式的模块。缺磷时，yellowf和red模块与生物量显著正相关；磷充足时，black模块与生物量显著负相关。与生物量呈现相反关联的还有缺磷的green模块和磷足够的pink模块。 5.5 重点模块和模块内hub基因分析缺磷的yellow模块，包含684个基因，与生物量、磷含量、根芽比例都显著相关。其中24%基因与之前转录组鉴定的PSI基因相一致。 模块基因，相对野生型，在phr1-1中下调表达，在prce突变体（cb/1、prce2等）上调表达。 筛选与该模块的ME（kME)排在前300的基因进行富集分析，显著富集的GO term有缺磷相关、磷脂和半乳糖脂代谢等。 模块hub gene筛选：kME大于0.9。主要为脂代谢、感知磷、磷信号导、磷运输等相关基因。 Yellow模块在cb/1中表现较高的ME值，说明钙信号通过CBL1影响磷转运。进一步筛选该模块中钙信号相关基因，重点关注，作为hub gene候选。 5.6 小结实验方案：两种处理，不同基因型样品，所有表达基因进行WGCNA分析。两种处理分别进行WGCNA分析鉴定各自的基因模块。模块筛选：通过模块Epigengene值与不同表型（数量性状）进行关联分析，筛选性状相关模块；筛选在缺磷和磷足够条件下与表型呈现相反关联的模块。模块功能分析：GO功能富集分析。模块hub gene筛选：与模块的kME值大于0.9；分析模块特征值在各基因型样品中表达模式，筛选关联高的突变体，重点关注突变基因及相关通路基因。","tags":"bioinformatics wgcna"},{"title":"WGCNA学习：WGCNA分析原理","url":"/2020/08/03/2020-08-03-WGCNA1/","text":"本教程根据PlantTech的WGCNA课程编写，课程还是不错的，所以将该课程给大家分享一下。 WGCNA笔记第一弹 WGCNA分析原理 WGCNA应用场景 WGCNA分析实践 1.WGCNA简介WGCNA(Weighted Gene Co-Expression Network Analysis, 加权基因共表达网络分析)，鉴定表达模式相似的基因集合（module）。解析基因集合与样品表型之间的联系，绘制基因集合中基因之间的调控网络并鉴定关键调控基因。 WGCNA适合于复杂的转录组数据 研究不同器官/组织类型和不同阶段的发育调控、生物和非生物胁迫的不同时间点响应机制 2.主要内容 一、WGCNA原理 1.构建基因关系网络 2.构建基因模块 3.筛选关键基因 4.鉴定关键基因 二、WGCNA应用 1.应用场景-实验设计、经典文献 2.实例分析-单个材料、两个材料 3.实例分析-结合表型 三、WGCNA实战 3.WGCNA原理 4.构建基因关系网络 4.1 计算基因间相关关系基因间相似性（similarity）：根据基因在不同样品中的表达情况，计算任意两个基因间的相关关系。用Pearson相关系数 基因共表达矩阵： S=[Sij] Sij 表示基因i和基因j的Pearson相关系数。 软阈值：通过加权函数将相关系数变换，形成邻接矩阵（Adjacency Matrix）,矩阵中元素连续化。 邻接函数：power函数（幂指数函数） aij=power(Sij, β)=|Sij|^β^ 需要确定邻接函数的参数β，依据无尺度网络原则，即基因表达网络符合无尺度网络的幂函数分布 4.2 无尺度网络 网络图的点指图中的每一个节点，度指与该点的连接数 随机网络（Random network），每个节点的度相对平均 无尺度网络（Scale-free network），少数节点具有明显高于一般点的度，这些点被称为hub，由少数hub与其他节点关联，最终构成整个网络 无尺度网络的幂率分布：节点连接数为k的节点数h，k与h成反比，负相关 尺度：随机网络中每个节点的连接数符合泊松分布，大部分节点的连接数居中，中值称为随机网络的尺度。 无尺度网络符合幂率分布，大多数点只有很少的连接，少数点有很多的连接 基因相关关系，幂函数处理后，少数强相关性不受影响或者影响较小，而相关性弱的取n次幂后，相关性明显下降。 4.3 确定关键参数β寻找合适的β，使得基因表达关系符合无尺度网络，度数高的节点少，度数低的节点多。 节点度数k与具有该度数节点的个数h服从幂律分布 具体计算度数为k的节点个数的对数值log（k），与该节点出现的概率对数（log(p(k))）呈现负相关，一般会设置相关系数大于0.8 为了检测设置的参数β是否满足无尺度网络，对log10(p(k))和log10(k)作图，同时为更好评估，对两者之间的相关系数做平方，即R^2^。如果模型R^2^接近1，则两者之间为很好的线性关系。 4.4 计算基因间表达关系评估基因间表达关系：直接关系 生物体内基因间的关系：直接关系+间接关系 TOM：用拓扑重叠（topological overlap measure，TOM）来计算基因之间关联程度，除了分析两个基因之间的关系，还考虑这两个基因与其他基因之间的连接。这样更具有生物学意义。 建立TOM矩阵$$（TOM）\\Omega=[\\omega_{ij}]=[TOM_{ij}]$$ $$TOM_{ij}=\\frac{\\sum_{\\mu}a_{i\\mu}a_{\\mu j}+a_{ij}}{min(k_i,k_j)+1-a_{ij}}$$ TOM公式中，计算i与j之间的关系，不仅考虑了i和j的直接关系，还考虑了第三个基因μ的间接关系 5 构建基因模块5.1 层次聚类树基因模块的划分基于基因间的连接稀疏性，将TOM矩阵（Similarity）转化为相异度矩阵（Dissimilarity）:$$d^\\omega_{ij}=1-\\omega_{ij}$$ 利用基于TOM值的相异度$$d^\\omega_{ ij}$$层次聚类建树 建树方法：动态剪切树和静态剪切树 5.2 动态混合剪切法 第一步：识别满足设定条件的初级模块 1.满足模块预定义的最低基因数目 2.距离集群过远的基因，即使与集群处于同一分支，也去除 3.每个集群与其他周围的集群显著不同 4.处在树分支尖端的每个群集的核心基因紧密相连 第二步：测试步骤 将未分配的基因进行测试，如果足够接近某个初级群集，则分配进去 通常WGCNA使用动态混合剪切法建树 5.3 建树过程的参数 模块最少基因数目（minModuleSize） 合并模块的最小距离（mincutHeight）计算模块的特征值，利用模块特征值建树，合并距离很近的模块（如Height小于0.2） 模块特征值（Epigengene） 模块内所有基因进行主成分分析（PCA），第一主成分的值即为Epigengene。它代表该模块内基因表达的整体水平 6 筛选基因模块主要介绍四种方法 6.1 表达模式分析模块表达模式分析：模块在各个样品中的丰度 模块特征值（Epigengene）：模块内所有基因进行主成分分析（PCA），第一主成分的值即为Epigengene。它代表该模块内基因表达的整体水平。 如果某模块在样品中特征值正或负表达较高，说明模块与这个样品关系紧密 6.2 模块与表型性状关联分析模块显著性值（Module significance，MS）：模块内所有基因的基因显著性值的平均值。 基因显著性值（Gene significance, GS）:基因表达水平与因变量水平的相关系数。用T检验计算每个基因在不同表型样品组间的差异表达显著性检验P值（Pearson相关系数），通常将P值取以10底对数值定义为基因显著性GS 计算各模块与一表型性状的MS值，如一个模块的MS值显著高于其他模块，则这一模块与该性状存在关联关系 模块特征值显著性（Epigengene significance, ES）:模块特征值与某一性状的相关系数，筛选与性状关联度最高的模块 6.3 富集分析对各个模块都进行GO和KEGG富集分析，找出与我们研究性状相关通路相关性最强的模块进行深入挖掘 6.4 依据目标基因筛选模块依据研究目的、前期研究结果和已发表文献，有重点关注的目标基因，可直接筛选目标基因所在的基因模块重点进一步分析 7 鉴定关键基因7.1 模块内部基因连接度分析Connectivity(degree)-连接度：与某个基因连接的所有其他基因的总和，即描述一个基因与其他所有基因的关联程度，一般用K值表示。 Intramodular connectivity KIM-模块内部连接度IC:某个模块中的基因与该模块中其他基因的关联程度（共表达程度）。可用来衡量模块身份（module membership,MM). Module Membership MM,or Epigengene-based connectivity KME:模块身份，用一个基因在所有样本中的表达语与某个模块特征值的表达谱的相关性，来衡量这个基因在这个模块中的身份。 KME值接近0,说明这个基因不是该模块的成员：KME接近1或者－1,说明这个基因与该模块密切相关（正相关或者负相关）。可以对所有基因计算相对某个模块的KME值，并不一定要是该模块的成员。KME与KIM高度相关。某个模块中KIM值高的hub基因一定与该模块的KME也很高。KME与KIM的区别：IC衡量基因在特定模块中的身份，MM衡量基因在全局网络中的位置。 筛选关键基因：TOM值（模块调控系表中的weight值）大于阈值（默认是0.15)的两个基因才认为是相关的，然后计算每个基因的连接度。即先筛选有足够强度的关系，然后计算连接度。 模块内部高连接度的基因，模块内排名前30或者10%(KME或KIM).筛选关键基因：将该基因模块身份MM相对于基因显著性GS做散点图，选择右上角MM和GS均高的基因进一步分析。基因显著性值（Gene significance,GS)因变量水平的相关系数。衡量基因与表型性状的关联程度，GS越高，说明与表型越相关，越具有生物学意义。GS可以为正值或负值（正相关或负相关）Cytoscape中一般用weight值（TOM值）来绘制网络图。 7.2 特定功能基因分析高连通性的基因一般位于调控网络的上游；低连通性的基因一般位于调控网络的下游。 调控网络上游一般是调控因子，如转录因子；下游一般是功能性的酶或蛋白分子 重点关注具有调控功能的基因，典型的为转录因子，这些基因往往是关键基因 7.3 目标基因关联分析依据研究目的，选取跟目标基因关系紧密的基因，如筛选与目标基因的TOM值排名前10，或者TOM值大于0.2的基因 可准确筛选与目标基因存在上下游调控关系的候选基因 当目标基因连接度不高时，可筛选与目标基因TOM值很高，且自身连接度也很高的基因 参考文献： Langfelder, P., Horvath, S. WGCNA: an R package for weighted correlation network analysis. BMC Bioinformatics 9, 559 (2008). https://doi.org/10.1186/1471-2105-9-559","tags":"bioinformatics wgcna"},{"title":"文献导读:真菌和陆栖藻类水平基因转移","url":"/2020/07/30/2020-07-30-HGT/","text":"这篇文献于2014年12月30日发表在Organism Diversity &amp; Evolution ,主要描述了在地衣中，地衣真菌可以向藻类捐赠基因,该文献对藻类进行测序，探究真菌基因进入藻类基因组的HGT证据，我的课题是对真菌进行了测序，藻类有参考基因，也可以借鉴该方法。 摘要 科学家们几个世纪前就已经知道真菌和藻类之间亲密而持久的关系，而这些古老的共生关系可能为这两种生物伙伴之间编码蛋白的基因水平转移(HGT)提供了极好的机会。在本研究中，对地衣Xanthoria parietina（子囊菌门：Ascomycota，茶渍纲：Lecanoromycetes，黄枝衣科：Teloschistaceae）中的绿色藻类光生生物Trebouxia decolorans（绿藻门：Chlorophyta，共球藻科：Trebouxiaceae）（PS:我做的项目里，地衣的藻类与该藻类属于一个纲：共球藻纲（Trebouxiophyceae））进行了基因组测序，组装出451Mbp的全基因组。这种藻类也是一种自由生活的陆生生物。该研究的目的是在地衣真菌和地衣藻类之间寻找指向HGT的候选基因。发现了真菌基因进入Trebouxia基因组的三个假定的HGT事件的证据，但这些可能比真菌子囊菌中的地衣化起源更古老(超过600mya)。这三个被转移的基因是编码抗碲酸二羧酸转运蛋白(TDT)家族蛋白的基因组的一部分，一个I类nitrilase/cyanide酶（CH），和一个氧化还原酶/视黄醇脱氢酶。在每一种情况下，系统基因组分析显示，从Trebouxia到所有真菌或子囊菌的同源基因是姐妹的，而绿藻和陆生植物的同源基因形成了独立的进化谱系。备择假设测试显著支持这些HGT事件。通过PCR扩增分离Trebouxia 的DNA，验证了这些基因在Trebouxia中的存在。这些特殊绿藻的基因组中古老的真菌基因的结合是有趣的，它可能是早期地球上陆地生命中存在的藻类和真菌的主要真核分支之间的共生和进化关系的早期证据。这些基因可能在一些真菌和藻类共生地衣起源中发挥了易感作用，但这还需要进一步的研究来详细评价。 引言 水平基因转移(HGT)涉及遗传物质从一个生物体转移到另一个生物体，属于独立的进化谱系。HGT在原核生物的进化和多样性中起着重要的作用;然而，HGT在真核生物宏观进化中的程度尚不清楚。最近的基因组研究表明，在真菌、细菌和真菌之间以及真菌和植物之间存在HGT。HGT也发生在有密切联系的(微生物)有机体之间，如宿主和它们的寄生虫，微生物的猎物和它们的捕食者。即使知道真核HGT事件的数量(包括真菌)很小,这些事件可能有相当大的影响功能创新和适应特定的生态位。 例如，在豌豆蚜虫、青桃蚜虫和双斑蜘蛛螨中合成类胡萝卜素是可行的，因为真菌类胡萝卜素生物合成基因进入节肢动物基因组。 HGT还促进了卵菌中植物寄生机制的进化，过氧化氢酶基因进入真菌致病物种Nosema locustae, Stagonospora nodorum, Mycosphaerella fijiensis和Botrytis cinerea中有助于克服宿主防御机制。同样，多酮合酶基因在大量次生地衣物质的产生中起着至关重要的作用，是细菌和地衣真菌之间HGT的结果。地衣真菌和光生物之间的DNA转移的可能性之前已经被提出，但到目前为止还没有证据表明这一点。在藻类地衣光生生物中，有报道称Trebouxia物种间I组内含子的HGT，并解释为病毒的发生可能促进内含子的迁移。 ​ Trebouxia是最常见的绿藻地衣光合生物。当它们生活在地衣共生系统中时，它们的种群数量最多，但至少有一些物种是自由生活的。Trebouxia也是共球藻纲的模式属，与石莼纲和淡水绿藻纲共同构成绿藻门的核心。 绿藻是包括陆地植物在内的链状植物的姐妹谱系，它们共同构成了真核生物的绿色植物谱系。 ​ 真菌通常与藻类形成共生关系，形成微生物土壤结壳或生物膜。其中一些紧密的联系导致了被称为地衣的共生生物体的形成，至少一种真菌(支原体)和一种藻类或蓝藻细菌(光生物体)生物的稳定共存，通常还包括额外的内聚真菌和细菌，所有这些共同形成了自成一体的微型生态系统。地衣是极其成功的，从热带到极地地区，从海岸到高海拔地区，几乎所有的陆地栖息地都有地衣的身影。地衣共生的基础尚不清楚，观点从互惠共生到寄生。在发现地衣的共生性质一百多年后，许多关于地衣生物学的基本问题仍然没有得到解答。其中之一是真菌和光生物之间复杂的相互作用是如何实现的，以产生复杂的和形态上不同的结构，如叶状或果状地衣。遗传控制(例如，蛋白质信号)似乎是必要的，因为地衣共生体之间的细胞外交流已被证明无需物理细胞接触。此外，地衣共生系统内的相互作用还伴随着光生物和支原体基因调控和表达的变化。特别值得注意的是地衣藻类，它们向真菌提供碳水化合物，因此可能受到真菌衍生基因的严重影响，以促进这一过程，从而加强共生关系。 ​ 在地衣中，真菌的种类对每一种地衣来说都是独一无二的，但藻类成分通常可以在几种地衣中找到。这种藻类并不表现出严格的共同进化的寄主特异性，正如前面提到的，有时可以在没有真菌的情况下生存。据报道，T. decolorans是来自其他几个地衣真菌科（如Lecidiaceae, Parmeliaceae, Physciaceae）的光生物。 ​ 对于所有的基因，考虑了三种可能的情况:(1)没有HGT的证据，(2)最近从真菌转移到藻类的证据，(3)古代从真菌转移到绿色植物的证据。考虑到真核生物中也存在相当多的HGT，希望至少能在地衣真菌或其直系祖先的光生藻类(Trebouxia;假设2)，当对光生藻类的基因组数据进行测序并与大量真核生物基因组进行比较时，就会发现这一点。在系统基因组学分析中，这将被显示为地衣化真菌基因支中高度嵌套的藻类基因的进化模式。为了验证这一假设，对Trebouxia的部分基因组进行了测序，并将推断出的基因与许多其他真核生物、细菌和古菌的大型基因组数据库进行了比较，结果在本研究中公布。 结论 利用illumina·平台得到的T. decolorans数据为451Mbp。从头组装产生共计55.3Mbp的基因组数据，保留长度为250 bp或平均覆盖面积为5的contigs子集以作进一步分析。该序列包括24,655个序列(N50= 590 bp)，总计13.4 Mbp，共编码18,178个假定蛋白。 亚硫酸盐外排泵/tellurite-resistance二羧酸转运体（TDT）家族 该家族的360氨基酸序列包括76个序列，其中27个来自真核生物，49个来自原核生物。为了去除模糊区域，该序列被手工细化为343个氨基酸长度。树的根是monophyletic Archaea，来自由绿色植物、红藻、真菌和细菌形成了一个副系级序列。 在得到的树中，来自两个地衣藻类部的T.decolorans和*asterochris sp.*的分支放在了20种担子菌和子囊菌的姊妹组中。另外四个来自绿藻门的绿藻成员被定位为两个红藻门的姐妹（图1），但这种关系仅在贝叶斯分析中得到了很好的支持（84%）。 ​ 在GenBank中的Blastp搜索中，与该序列最相似的是一个来自于Dorhistroma septosporum的序列，PCR分析证实在T. decolorans和T. impressa存在该序列。然而，这一序列不能从Dictyochloropsis symbiontica（共球藻纲）。 I类nitrilase/cyanide酶（CH） 分析T. decolorans中的CH蛋白序列，与细菌、古细菌和真核生物进行比对，并利用古细菌作为外群。除了一个真菌外，其他所有的真菌和T. decolorans在一个分支中 ​ 在GenBank中的Blastp搜索中，与该序列最相似的是一个来自于Chaetomium globosum的序列，PCR分析证实在T. decolorans存在该序列。然而，这一序列不能从Dictyochloropsis symbiontica和T. impressa扩增出来。 Oxidoreductase/retinol dehydrogenase​ Trebouxia的该片段长度有145个氨基酸，利用100个来自细菌和真核生物（绿色植物、真菌、变形虫、后生动物、隐藻门和单倍体）构建发育树。以单系细菌作为外群。Trebouxia位于真菌分支中的基底部，真菌分支的姐妹分支由Coccomyxa和 Micromonas、11个被子植物序列以及其他细菌序列和2个真核生物序列（变形虫和单胞菌科）组成。 在GenBank中的Blastp搜索中，与该序列最相似的是一个来自于Verticillium dahlia的序列，PCR分析证实在T. decolorans存在该序列。然而，这一序列不能从Dictyochloropsis symbiontica和T. impressa扩增出来。 候选基因的真菌和藻类序列重组分析 为了测试HGT事件是否真的正确（即Trebouxia的分类位置是否正确），使用RAT分析了基因树的氨基酸序列。没有发现重组的迹象。只有在真菌序列之间才能检测到重组的证据。 讨论​ 不同有机体谱系间的水平基因转移通常是通过对一个基因的系统发生或系统基因组学分析来检测的，该基因显示出与其他分类群的不同关系，而不是基于这些分类群中该基因的其他副对数而预期的。这种异常模式只能（或最有可能）用罕见的水平基因转移来解释，而不是通常的垂直遗传，这种遗传是经过亿万年和/或几千年进化和物种形成的结果。值得注意的是，本研究系统基因组学结果是由于HGT，以及原核生物之间以及（历史上）真核生物非常基础分支之间的基因交换。如前所述，HGT在真核生物的衍生和现存分支中不太常见。转移的方向通常是从相关基因的近亲推断出来的，如果基因嵌套在一组分类学上未分类的有机体中，那么周围的类群很可能就是基因的起源。未来需要进行后续的分析，这些分析基于来自Trebouxia的扩展基因组数据集以及更广泛的分类单元采样，包括更多的绿藻、基础真菌群和地衣形成真菌。研究结果讲述了真菌和地衣藻类之间的三个古老HGT故事，*期待着通过全世界科学家正在进行的基因组测序工作，在未来几年里，这些情景是如何发展的。","tags":"literature_reading hgt"},{"title":"文献导读:菌虫共生真菌测序","url":"/2020/07/27/2020-07-27-Symbiotic/","text":"Amylostereum areolatum基因组测序与分析：揭示菌虫共生的生物学基础最近做的地衣共生没有什么头绪，找到的文献都是宏基因组相关，无奈，只好找了菌虫共生菌的基因组分析作为借鉴，看看能不能从中发掘出有用的方法。 这篇文献2020年5月发表在ASM上，主要对Sirex noctilio的真菌共生体Amylostereum areolatum进行基因组测序分析，与我进行的工作类似。 摘要​ Amylostereum areolatum是一种全球入侵物种-欧亚树蜂(Sirex noctilio)的共生真菌，这种互惠共生关系与木蜂有关，可协助其昆虫伙伴的破坏过程，并为其提供营养。A. areolatum的定植和生长对S.noctilio的发育和传播有重要影响，但两者之间相互作用的机制尚不清楚。在这项研究中，对这种共生真菌的第一个基因组进行了测序、组装和注释。首次组装了A.areolatum基因组为57.5 Mb (54.51% GC含量)，有15611个蛋白编码基因。鉴定了580个碳水化合物活性酶(CAZymes)， 661个基因与病原-宿主相互作用，以及318个基因编码转运蛋白。基因组注释揭示了10种萜类/植物烯合成酶，可分为三个亚类。第二类萜烯合成酶基因簇在整个红菇(Russulales)中保存良好。在这个簇中，编码甲羟戊酸激酶（MK）、EGR12（COG1557）和非植物萜环化酶（CD00687）的基因是已知的生物合成和调控基因。通过对该真菌基因组序列的分析，从分子水平上证明了A.areolatum挥发物对S.noctilio寄主选择的影响。进一步阐明了A. areolatum是一种严格的专性共生真菌。蜂在通过产卵将其引入合适的寄主基质前对其进行保护，同时为S.noctilio幼虫的生长提供适宜的环境和营养。 ​ Sirex noctilio与一种共生真菌A.areolatum一起，对世界各地的松树物种造成了严重的危害。在我国，它导致蒙古松大面积死亡。木蜂与其真菌之间存在一定的依赖互惠关系。研究表明，真菌的生长速度会影响黄蜂的体型:较大的成虫会出现在真菌生长速度较高的地方。通过对该真菌的基因组序列分析，证明了A.areolatum挥发物在分子上影响S. noctilio寄主选择的可能性。进一步阐明了A. areolatum是一种严格的专性共生真菌，为S. noctilio幼虫的生长提供了适宜的环境和营养物质。这些结果将为我们理解这种菌虫共生的机理奠定基础。 引言 木蜂与真菌共生体间存在着严格的专性依赖互惠共生关系。S. noctilio有一个专门的器官来储存共生真菌，贮菌器（mycangium）。首先，在真菌被引入合适的宿主基质之前，贮菌器可以保护真菌。 在产卵期间，雌性木蜂通过产卵器将其共生真菌和植物毒毒液黏液与卵接种到寄主树中。当成虫出现时，真菌从蛹腔壁被吸进囊膜。通过这种方式，雌性收集虫室中产生的虫卵，传播并接种到新树中。反过来，这种真菌也对S. noctilio的发育乃至繁殖潜力至关重要。A.areolatum感染并干燥木材基质，为虫卵和幼虫提供更适合的微环境。此外，共生真菌的纤维素，半纤维素和果胶的降解酶含量较多也可能是对S. noctilio幼虫至关重要的一环。S. noctilio的发育及其繁殖潜力与共生真菌的活力密切相关。研究表明，S. noctilio幼虫在三龄或四龄时都以A.areolatum提供的降解物为食，然后以白色腐烂的木材为食。真菌的生长速度影响了S. noctilio的体型大小;较大的成虫出现在真菌生长率较高的地方。碳水化合物活性酶(CAZymes)和毒力相关基因在真菌定植和生长中起着重要作用。白腐真菌能有效地降解木质纤维素生物质，特别是从植物中提取的木质纤维素。许多已被研究的毒力相关基因被发现与操纵植物防御促进真菌感染有关。这些基因在防御机制、信号转导、碳水化合物运输和代谢、细胞内运输、分泌和囊泡运输等方面发挥重要作用。 ​ 挥发性成分在吸引雌胡蜂到植物寄主的过程中起着重要的作用。先前的研究表明S. noctilio对A.areolatum的挥发性成分的反应比对受袭树木的反应更强。这些真菌挥发物也能吸引S. noctilio到受A.areolatum感染的寄主那里。对A.areolatum及其他蒙古松内生真菌的挥发性有机化合物(VOCs)进行了分析，发现倍半萜类化合物对已交配的S. noctilio有吸引力，但对未交配的S. noctilio无吸引力。虽然萜类化合物可能在木蜂的空间聚集中发挥重要作用，但迄今为止在A. areolatum中尚未发现萜类生物合成酶，而且基因组测序方法是通过识别参与次生代谢物活性的基因来发现萜类化合物生物合成途径的常用方法。 ​ 在本研究中，作者完成了A.areolatum的基因组测序，分析了碳水化合物酶、毒力基因和次生代谢基因。这些发现将有助于解释这样一个假设，即在的S. noctilio生命周期中，有一种酶起着至关重要的作用，例如通过降解植物细胞壁为夜蛾幼虫的定殖和生长提供营养，以及通过产生倍半萜类化合物来吸引雌虫产卵。本研究结果为更好地了解S. noctilio和A. areolatum之间的互利共生机制奠定了基础。 Sirex系统的最新见解。(a):对与S. noctilio交配和寄主位置有关的视觉和嗅觉线索的研究证实了新出现的个体具有强烈的趋光反应，并确定了推测的信息素，这两者都有助于树冠上方观察到的交配群。这一认识，再加上植物挥发物（kairomone）诱饵的优化，将使研究人员能够开发出更有效的监测工具。（b） S. noctilio种群中抗性的可能进化或真菌种群毒性降低的进化会导致S. noctilio和菌株之间的不相容性，因此并非所有的卵都被真菌寄生。（c） 通过松树寄主与其他S. noctilio或真菌有性繁殖来实现水平及因转移。（d）Amylostereum areolatum分解木材中的木质素和纤维素，释放出碳水化合物，这些碳水化合物作为液体从木材中挤压出来，并被发育中的幼虫摄取。细菌有助于纤维素的消化，很可能为幼虫固定氮。（e） 氮对真菌也有限制，但可以通过细菌或线虫寄生获得。这种寄生可能会影响树木中的线虫数量。（f）幼虫在化蛹期离开真菌定殖区。 结果基因组特征 二代测序(illumina)与三代测序(PacBio)相结合，经过质量控制，得到HiSeq数据6839 Mb (118 coverage)和PacBio数据4314 Mb (74 coverage)。 重复原件与转座酶​ 除了编码蛋白质的基因序列外，真菌基因组的一个重要部分是重复元件。在A. areolatum基因组中，鉴定了14,513,406 bp(基因组序列的25.21%)的重复元件。串联重复序列占1.1%，转座因子(transposable elements, TEs)占24.11%。在TEs中，I类元素和II类元素(DNA) TEs分别占基因组的15.50%和1.36%。未知和其他重复元素占8.17%。长末端重复序列(LTRs)是I类TEs中最丰富的(占总基因组序列的14.79%)，包括Copia、Gypsy和BEL/Pao逆转录转座子超家族。 种系发生(Phylogeny) 利用Orthofinder鉴定出56374个基因簇，其中913个为所有真菌共有的基因。从这些共享的基因簇中，选择41个单拷贝基因，分析A.areolatum与其他82个伞菌纲的参考基因组的进化关系。最大似然（ML）分析在高支持率（70%）的情况下，确定了15种主要真菌分支的进化关系。 系统发育分析表明，该菌与其它红菇属植物群聚在一起，与植物病原真菌松果体菌（Peniophora sp.CONT）关系密切。 碳水化合物酶 在A. areolatum基因组中，鉴定出580种CAZymes，包括219种糖苷水解酶（GHs）、67种糖基转移酶（GTs）、16种多糖裂解酶（PL）、60种碳水化合物酯酶（CE）、58种碳水化合物结合模块（CBM）和160种具有辅助活性的酶（AAs）。与传统真菌相比，A. areolatum含有更多的CAZymes，与森林病原菌（forest pathogens）类似。 在A.areolatum基因组中，编码GHs和AAs的基因比其他蛋白类型多。45个GH基因家族中GH3(15拷贝)、GH5(18拷贝)和GH18(16拷贝)的数量尤其丰富。此外，还发现2个GH6和8个GH7成员与结晶纤维素的降解有关。AA家族的分类显示,多数AAs AA3家族的成员(62拷贝),包括亚科纤维二糖脱氢酶(EC 1.1.99.18),葡萄糖氧化酶1 (EC 1.1.3.4)、芳基醇氧化酶(EC 1.1.3.7)、酒精氧化酶(EC 1.1.3.13)和吡喃糖氧化酶(EC 1.1.3.10)。 推测的毒性相关基因​ 总共有661个与病原体-宿主相互作用(PHI)相关的预测A. areolatum基因。毒力降低所占比例最高(45.39%)，其次是未受影响的致病性(23.45%)、失去致病性(10.14%)、致死(9.23%)、混合结果(8.47%)、化学目标(1.21%)、毒力增加(高毒力)(1.66%)和效应器(植物无毒性决定因素)(0.45%)。此外，我们还注释了47个已报道为致病菌毒力因子(VFs)的基因(致病菌毒力因子[毒力因子数据库VFDB])。根据这些基因在其他寄主物种的发病机制中所起的作用，这些基因可能是A. areolatum假定致病性因子。此外，还鉴定了A. areolatum中83个家族318种转运蛋白。在这些转运蛋白中，37个基因编码MFS蛋白，18个基因编码ATP结合盒蛋白;其他科中编码蛋白的基因较少。 倍半萜烯合酶集群​ AntiSMASH分析表明 A. areolatum次生代谢物基因的数量和类型与报道的其它红菇属植物相似，后者携带19个次生代谢基因簇，包括编码8个萜烯/植物烯合成酶的基因簇，2个非核糖体肽合成酶（NRPS），1个I型聚酮合酶（T1PKS）、一个铁载体合成酶和七个未知基因簇。值得一提的是，鉴定出的萜烯/植物烯合酶基因簇数量最多。这些酶可能参与了萜类化合物的生物合成，尽管还需要进一步的研究来确定这一点。 为了阐明萜烯生物合成簇的保守性和多样性结构，从83个伞菌纲基因组中获得了两个包含5个倍半萜合成酶（STS）基因的同源群。A. areolatum基因组含有10个萜烯合成酶基因，与伞菌纲中这类酶的数量一致。系统发育树是利用三种合成酶（Cop3、Cop4和Cop5）的同源序列构建的，这三种合成酶是在A. areolatum基因组中鉴定出来的。萜合成酶基因与Cop-STS基因分为三大类，表明每个簇中的酶可能通过保守的环化途径产生相关的萜类化合物。 在真菌中，次生代谢产物生物合成基因通常位于相邻的簇中。有趣的是，第二类萜烯合成酶基因簇在整个红菇中保存得很好。A.areolatum、S. hirsutum和H. irregulare 之间的共线性表明，参与萜类化合物合成的基因具有良好的共线性，这表明红菇可能共享与萜烯代谢相关的保守核心基因。保守的基因簇包括甲羟戊酸激酶（MK）、EGR12（COG1557）、非植物萜烯环化酶（cd00687）、烯醇辅酶A（enoyl-CoA）水合酶/异构酶和P激酶，其中一些基因已被证实与甲羟戊酸途径（合成萜类的途径之一）有关。除了参与倍半萜代谢的核心萜烯环化酶外，倍半萜簇中还存在ABC转运体ATP结合蛋白（CL0023）和P450（PF00067）。这些酶可能在氧化和羟基化等修饰以及倍半萜的运输中发挥作用。 讨论一般基因组特征和系统发育 A. areolatum基因组组装约为53mb，相当于红菇相关成员的组装体大小，从26mb到122mb不等。A. areolatum基因组包含15611个编码基因。系统进化树表明，在进化上，A. areolatum与植物病原真菌Peniophora sp.CONT的进化关系较近。 与降解植物细胞壁和角质层相关的蛋白家族 毒液和真菌共生体的存在会导致寄主的弱化和树脂压力的下降，为S.noctilio的卵孵化和幼虫发育提供了更为适宜的微环境。此外，S.noctilio的行为和形态适应表明，S.noctilio幼虫不摄取木质部，而是利用A.areolatum对难降解的木质纤维素化合物进行外部消化。A. areolatum能分泌大量的纤维素酶、半纤维素和木质素酶，能有效降解植物细胞壁成分，提供营养物质（如葡萄糖、甘露糖、半乳糖、醋酸、木糖等）因此，A. areolatum的成功定殖和生长对其发育起着至关重要的作用。真菌的解聚能力与其分泌一系列酶的能力成正比。在分析中，A. areolatum的胞浆酶数量与森林病原菌相当，并且显著高于传统腐生蘑菇，这表明A. areolatum能够突破植物细胞壁，以类似于其他森林病原菌的方式成功建立感染。它可以通过破坏植物细胞的结构来削弱松树，并为S.noctilio幼虫的生长提供营养。 植物细胞壁含有丰富的纤维素。GHs是降解纤维素、半纤维素和淀粉的常见酶。它们参与碳水化合物分子之间或内部糖苷键的水解。共有219个GHs被分为45个家系。编码GH3和GH5类酶的基因数量超过了编码其他GH酶的基因。这与树木腐烂真菌（白色、棕色和软腐真菌）GHs的组成特征相似。此外，真菌基因组中发现了丰富的GH18基因编码，这些基因催化几丁质的分解。几丁质酶能降解真菌细胞壁，抑制孢子萌发、菌丝生长、芽管伸长等发育活动。因此，推测GH18可能对其它内生真菌如麦冬菌和球毛壳菌在蒙古松上的拮抗作用起了一定的作用。在CAZy数据库中，90%的木质纤维素降解真菌含有编码裂解多糖单加氧酶（LPMOs）的基因。这些酶主要参与非碳水化合物结构组分（木质素）的解聚，或作为植物的主要细胞壁成分被发现（34，39）。在本研究中，我们分别检测到62个和25个AA3和AA1拷贝。AA3家族（GMC氧化还原酶/脱氢酶）主要存在于森林病原菌中，如S. hirsutum（48个AA3基因）和Heterobasidion annosum（32个AA3基因）。AA3家族包含氧化还原酶的甘糖醇-胆碱（GMC）家族中的酶，该家族通过其反应产物协助其他AA家族酶的活性或支持糖苷水解酶在木质纤维素降解中的作用。它们通过产生过氧化氢和回收聚合物氧化攻击所需的电子给体和受体，促进木质纤维素的分解。 ​ Laccase另一种重要的木质素降解酶，属于AA1家族。在真菌中Laccase有不同的角色,如介导真菌病原体和宿主植物之间的相互作用,大量的AA3和AA1基因导致松树的氧化降解,使A. areolatum具有强烈穿透植物细胞壁和降解木质素的能力。这不仅有利于真菌的定植和生长，也为S.noctilio幼虫提供了营养。 毒力相关基因 病原体-宿主相互作用数据库（PHI-base）收录了来自真菌、细菌和原生病原体的2800多个基因，并通过实验验证了致病性、毒性和效应基因。这些基因表达的失活或减少可以降低或消除致病能力。在对PHI-base数据库检索得到的所有预测基因中，与毒性降低、未受影响的致病性和致病性丧失相关的基因是最常见的。生理学实验表明，单独接种A. areolatum并不会显著降低树势，也不会影响树木的生长。本研究所描述的A.areolatum毒力相关基因的特征有助于解释这一现象。致死基因的缺失或低表达会导致真菌无法存活。基因组中只有9.23%的致死基因。这可能是因为A.areolatum是一种典型的共生真菌；在将其引入合适的宿主基质之前，S.noctilio会保护真菌。 在真菌转运蛋白中，ATP结合盒（ABC）转运蛋白和主要促进因子超家族（MFS）是最大的两个超家族。ABC转运蛋白是多组分的，主要是活性转运蛋白，在ATP水解条件下，它既能运输小分子，也能运输大分子。它们能运输多种化合物，如多糖、药物、糖、重金属、寡肽、氨基酸和无机离子。研究表明，在所有测序真菌中，S.pombe只含有19个ABC蛋白，这可能接近自由生命有机体的最小值。A. areolatum中ABC蛋白的含量比S.pombe少，而且更显著的是，它缺乏ABC-D转运体，而ABC-D转运体在所有测序物种中都有发现，除了Encephalitozoon cuniculi和S.pombe。从真菌中提取的ABC蛋白只有少数已被功能性鉴定，而ABC-D转运蛋白的缺乏还需要进一步的研究。 A. areolatum含有大量的糖类酶基因，但毒力和转运基因较少。这与它们的共生关系是一致的；A. areolatum通过分泌胞外酶为S.noctilio幼虫的生长提供营养，而S.noctilio通过将真菌带到一个特殊的器官——贮菌器中，保护和转移真菌，然后将其引入一个新的合适的寄主基质。 倍半萜烯合酶集群​ 研究表明，与寄主植物相比，交配后的雌性S.noctilio对A. areolatum挥发性成分更具吸引力；倍半萜类化合物可能在这一过程中发挥作用。对红菇属真菌的序列分析表明，倍半萜合成酶同源基因在这些真菌中广泛存在。然而，尽管倍半萜合成酶同系物在真菌中占优势，但对其活性和生物学功能知之甚少。在大肠杆菌表达载体上克隆和鉴定了灰曲霉的倍半萜合成酶，结果表明在Cop3培养基中产生了muurolene、elemene、muurolene、germacrene D和cadinene。在Cop4培养物中检测到了Cadinene、cubebene、sativene、copaene和cubebol。因此推测，同样的化合物也出现在A. areolatum的挥发性成分中。 材料和方法基因组组装 利用Illumina序列进行k-mer分析，并对PacBio组装进行校正。为了得到高质量的装配，使用GATK 对序列错误进行了修正。然后，使用SSPACE_Basic 工具将contigs合并成scaffolds，使用PBJELLY 封闭间隙。最后，基于成对序列相似度搜索，应用冗余管道来识别和去除杂合的contigs和scaffolds。利用BUSCO 和来自真菌谱系的数据集对候选assembly进行了评估。 基因预测与注释​ 结合从头预测和基于转录体的预测方法对编码蛋白的基因进行预测。初步预测采用SNAP、Augustus和GeneMark ES 进行编码基因预测。然后，使用Tophat 将转录组测序(RNA-Seq)数据(未发表)映射到assembly上，使用Cufflinks将转录组组装到基因模型上。最后，利用循证emodeler (EVM)将上述方法预测的所有基因模型组合成一个非冗余的基因结构集合。使用tRNAscan-SE 检测tRNA区域和二级结构。使用RNAmmer软件分析小rna，使用Infernal对Rfam数据库进行搜索，预测小rna (sRNAs)。预测的基因模型通过BLASTp搜索、Swiss-Prot、TrEMBL、Orthologous、GO和KEGG进行功能注释。 转座因子和串联重复序列的鉴定 本研究采用序列比对预测法和从头预测法来评估A. areolatum基因组中的TEs。对于序列比对预测方法，使用RepeatMasker，使用数据库Repbase搜索TEs。优化的默认参数与-lib选项一起使用以查找重复项，-species真菌选项用于单独的分析以查找真菌重复。RepeatProteinMasker和与RepeatMasker相关的转座子蛋白文库也被用来鉴定TEs。从头预测方法，利用buildXDFDatabase生成扩展数据库格式（XDF）。然后，使用RepeatModeler和XDF数据库建立TE模型，然后使用RepeatMasker对TE进行预测。串联重复序列用RepeatMasker进行评估。 系统发育分析​ 从NCBI数据库以FASTA格式下载79种蘑菇菌种的基因组序列。利用正交法获得了真菌基因组中的一组同源基因(系统进化保守)。我们选择41个单拷贝同源基因构建系统发育树。使用MAFFT进行序列比对，使用Gblocks提取并连接保守位点。我们运行ProtTest以选择最合适的模型，并使用RAxML构建ML基因树，其中-f a -x 12345 -p 12345 -m PROTGAMMAILGF -N 1000 选项。使用Wallemia sebi蛋白序列作为外组 碳水化合物酶分析​ 利用BLAST对A. areolatum和其他10种真菌中的CAZymes进行鉴定和注释，并使用dbCAN注释程序HMMER对CAZy数据库进行搜索。当E值小于1e05时，将结果进行汇总。II类过氧化物酶和DyPs通过BLAST在过氧基数据库中的搜索得到了进一步证实。 毒力相关基因预测 候选毒力相关基因在A. areolatum基因组中使用BLASTp来搜索PHI-base。对蛋白进行比对，以确定在A. areolatum中可能存在的毒力相关基因，其识别率超过40%，查询覆盖率超过70%。毒力因子(VFs)检索使用BLAST比对毒力因子数据库。运输分类数据库(TCDB)包含序列，分类，和结构，功能，和进化信息的运输系统从各种分类。基于转运体分类数据库的搜索，以E值阈值1e-05和识别值为40%确定了A. areolatum中的候选转运体。利用MAFFT对蘑菇真菌ABC转运蛋白进行序列比对，利用FastTree构建系统发育树 次生代谢基因预测 利用AntiSMASH对A.areolatum、S.hirsutum、Peniophora sp. CONT和H. irregulare的次级代谢生物合成基因和基因簇进行了预测。在两个同源类群中获得83个伞菌纲基因组的假定真菌萜烯合酶序列。还包括五个在C.cinereus中发现的倍半萜合酶同源物(分别命名为Cop1和Cop5)。在构建系统发育树时，要手动检查比对以排除注释错误的序列(例如，序列似乎太短或太长)。在MAFFT中对902个萜烯合成酶基因进行序列比对，利用FastTree构建系统发育树。","tags":"literature_reading"},{"title":"文献导读：真菌进化","url":"/2020/07/20/2020-07-20-fungi/","text":"最近在做地衣（真菌与藻类的共生体）的相关课题，对于真菌理解的较少，于是选择2019年发表在Biological Reviews上的文献进行阅读，文献比较长，耗费很长时间看完，而且在阅读过程中主要侧重于植物方面 摘要真菌是一种高度多样化的异养真核生物，其特征是没有吞噬营养（phagotrophy）和有几丁质（chitinous）细胞壁。虽然单细胞（unicellular）真菌非常常见，但该群体进化成功的部分原因在于它们能够无限期地生长为圆柱形多核细胞（hypha）。有了这些形态特征和极高的代谢多样性，真菌已经征服了许多生态位，并形成了一个与其他生物相互作用的世界。本篇文献主要调查了主导真菌多样性的主要进化和生态过程。首先回顾孢子谱系的生态学和进化以及陆生化（terrestrialization）的过程，作为这个王国的主要进化转变之一。对于真菌的陆生化，已经提出了几个可行的设想，在本次研究中提出了一个新的设想，即把冰环境看作是水和陆地之间的一个过渡的小生境。然后，将重点探讨真菌与其他生物体(其他真菌、原生动物、动物和植物)的主要生态关系，以及适应群体内特定生态位（地衣、黑真菌和酵母）的起源。在这篇综述中，使用进化和比较基因组学的观点来理解真菌的生态多样性。最后，我们强调了基因组推断（genome-enabled inferences）的重要性，为重要的转变设想合理的叙述和场景。 Ⅰ:引言真菌界是一个高度多样化的真核生物分支，几乎存在于所有环境中，特别是在陆地生态系统中。真菌在营养循环中起着关键作用，可以充当无数其他生物的捕食者、病原体和寄生物，并且可以与植物、藻类、动物和其他生物共生。一些重要的真菌类群（主要是蘑菇和地衣）产生的肉眼可见的（macroscopic）结构一直是形态学、细胞学和生物化学研究的重点。除这些之外大多数真菌是通过基于培养的微生物学技术或通过评估它们在宿主或共生伙伴身上产生的症状和特殊结构来进行研究的。在过去的二十年里，基因组革命对真菌学领域产生了积极的影响，基因组和转录组测序的出现使几乎所有真菌类群的研究成为可能，这反映在一个爆炸性的研究中，涵盖了越来越多来自不同谱系的真菌物种，同时环境测序研究揭示了真菌生物学的一个新维度。在过去的二十年里，基于条形码的方法被用于研究环境真菌群落的特殊成分的多样性，例如外生菌根真菌；或者评估特定环境中的真菌成分。真菌学已经开始接受单细胞技术的使用，尽管暂时由于丝状生长与细胞分类方法不兼容。每一种方法都有其特定的局限性，但它们共同提供了一个关于真菌在哪里，它们是谁，以及它们是如何变成现在这个样子的一个新画面。 大多数真菌以菌丝体的形式生活。真菌一般通过固体基质生长，利用胞外酶和蛮力挖掘基质，开发其周围的资源。此外，它们通过分泌有毒化合物杀死其他微生物来控制自己的领地。真菌有一个发育良好的分泌体（secretome），使它们能够从高度聚合且通常非常疏水的化合物中提取营养物质，例如纤维素或木质素（cellulose or lignin），这对其他微生物来说非常困难。在这篇综述中，综合了目前关于真菌主要的生态适应和进化转变的知识。把进化的转变定义为在一个新的，完全不同于以前的状态的生活方式谱系中的获得。这类转变的例子包括从自由生活的祖先那里获得寄生的生活方式，建立共生关系（例如地衣）。如果可能的话，将这种转变置于一个进化的框架内，解释游动孢子（zoosporic）真菌是如何从能动的真核寄生物（motile eukaryvorous parasitoids）进化到霉菌（moulds）的，以及不同的真菌群体如何从这两种生活方式中形成与其他生物群的关系，并适应新的生态环境。综述将着重描述每种生态生活方式的表型和基因组概貌、分类学多样性、进化趋势和与文化无关的环境信息。 Ⅱ:in the beginning，早期真菌进化推测最后的共同真菌祖先( last common fungal ancestor ：LCFA)的潜在生活方式是具有挑战性的。根据宏基因组研究，真菌的姊妹类群核仁类是海洋环境中常见的是变形原生动物，核菌纲。在大多数分子年代测定分析中，真菌的年龄比陆地生物的化石证据还要早，表明真菌可能起源于海洋。然而，所有已知的现存真菌谱系显然主要是大陆的，要么是真正的陆地的，要么是与非海洋水体相关的。原始真菌必须主要是水生的，然而，因为所有陆生真菌都形成了一个明显的单系分支，并且可以推断鞭毛（flagellum）的单一缺失。因此，要么真菌起源于大陆水体，要么失去了关键的海洋血统。根据环境研究，早期分支谱系Aphelida、Rozellida和壶菌(Chytridiomycota)在海洋环境中表现出高度的多样性，而一些高度多样化的海洋壶菌谱系似乎是最早出现分化的，这表明我们可能接近于找到缺失的一环。然而，需要注意的是，壶菌系统发育和它在真菌生命树中的位置仍然没有很好地解决。 从生态学角度讲，寄生生物的生活方式将后孢菌（Opisthosporidia）, 壶菌门（Chytridiomycota） 和 Blastocladiomycota结合在一起（图1）。这表明所有真菌的祖先可能是微藻的寄生体，具有吞噬能力，同时具有变形虫和鞭毛的运动性，至少在某些生命阶段具有几丁质细胞壁，这一套适应性进化将真菌从剩余的菌物总界（Holomycota）分支中分离出来。在这一前提下，早期的Aphelidea和Rozellida可能与不同的藻类和原生动物群有关，而其他同时代谱系的祖先可能大多生活在绿藻门（Chlorophyta）的寄生生物中。真菌可能涉及碳水化合物活性酶（CAZy）的发展，这是大多数真菌谱系的特征，穿透固体表面和消化纤维素和其他生物聚合物的能力促进了生活方式从寄生到腐生的转变，具有寄生生物生活方式的特征则很少使用，所以这使得它们保存在化石记录中的可能性降低。然而，新元古代（neoproterozoic）真核生物的间接证据已经被发现，与动孢子（zoosporic ）真菌拟寄生的生活方式相一致，所以未来对动孢子菌及其变形虫姊妹谱系的基因组比较分析可能会为这一时期的真菌进化提供新的见解。 图1：系统发育树显示了主要的非Dikarya生态过渡。右边的符号表示转换已在组内发生。 Ⅲ:down to earth，真菌的陆地化 真菌最明确的进化特性性是对陆地环境的适应（陆地化），包括菌丝生长的发育和鞭毛的丧失（图1）。菌丝的发育对感染更大有机体和在腐生生活方式中增加接触面积是必要的。分泌消化酶和优先在菌丝顶端表达丰富的膜转运蛋白的能力，可以理解为生物体祖先掠夺生活方式的直接结果，这种掠夺生活方式必须闯入其他生物结构以获取营养。在这方面，真菌表现出的钙代谢与外界介质的没有联系，可以解释为一种适应，可以打入其他细胞，那里游离Ca2+浓度太低，不足以构成可靠的来源。对于其他的细胞内寄生虫，如利什曼原虫、弓形虫和疟原虫，也有专门的Ca2+稳态适应。 大多数丝状真菌的菌丝是围绕着一个叫做Spitzenk orper（SPK）的细胞器组织起来的。SPK由高尔基体中的一系列小泡组成，这些小泡含有合成膜和细胞壁所需的酶、脂类和多糖。围绕SPK的是极性体和外囊。极性体是一系列蛋白质，它们组织细胞骨架成分并调节细胞骨架介导的囊泡运输。这些结构对于维持菌丝生长的方向性，调节SPK组分的胞吐，调节Ca2+信号和重塑细胞壁有重要作用。菌丝生长研究揭示了这一分子机制在整个双核亚界（担子菌与子囊菌的祖先）（Dikarya）中的守恒性，但这些群体之外的信息非常有限。例如，大多数合子真菌表现出一种不太有组织特性的小泡聚集，称为新月形顶端小泡（ apical vesicle crescent (AVC)）。SPK似乎存在于Basidiobolus和Conidiobolus中，它们是虫霉门（Entomophthoromycota）中早期分化的谱系。芽生枝菌门(Blastocladiomycota)的成员也具有形态上可识别的SPK。SPK在这些谱系中的存在表明，所有陆地真菌的共同祖先可能有一个SPK在合子真菌中丢失或修饰成AVC，不排除SPK在这些谱系中的独立起源的可能性。 2007年，在数十位真菌学家与分类学家通力研究之下，诞生了一套新的真菌分类系统，其中子囊菌门与担子菌门共同组成双核亚界，是真菌中多样性最高的类群，包含绝大多数蕈类、植物病原菌以及用于食品工业的真菌，而传统分类系统中的壶菌门与接合菌门都被认为是并系群而有所调整，芽枝霉门与新美鞭菌门从壶菌门中分出，成为两个独立的门，接合菌门则被分拆成球囊菌门与毛霉亚门（Mucoromycotina）、虫霉亚门（entomophthoromycotina）、梳霉亚门（Kickxellomycotina）和捕虫霉亚门（Zoopagomycotina）等四个亚门。2018年，Tedersoo等人又发表了新的真菌分类系统，将真菌细分至十八个门。下面的演化树是根据Silar等人（2016年)与Tedersoo等人（2018年）做出的新分类系统绘制，包含真菌的主要分类单元。注意演化支的长度与演化距离无关 几种可能的进化情景可以解释真菌是如何在陆地上定居的，这反过来又触发了真菌的爆炸性多样化。要解决这个问题，就需要提高我们对早期土壤微生物组成的认识，更精确地测定关键事件的年代，如陆地植物多样化和陆生真菌的辐射。将这些替代假设称为真菌陆地化的绿色、棕色和白色情景，分别以植物、土壤和冰为重点（图2）。 图2：真菌陆生的三个假设的图示。绿色情景意味着真菌的陆生依赖于绿色植物的陆生，可能是链霉菌。棕色情景假设在鞭毛消失之前，动孢菌获得腐殖质习性并在沉积物或潮湿的土地上定植，接着是菌丝生长发育并完全陆生。白色的路径意味着动孢菌适应冰冻的环境，作为水生和陆地环境的中间体。 绿色场景：真菌必须作为维管植物的寄生虫存在，才能在陆地的早期阶段抵抗缺水。设想是真菌与陆生植物的祖先共同进化，它们以绿藻中的寄生虫的身份从淡水水体中来到河流和湖泊的边缘，随着植物对陆地环境的适应而征服了陆地世界。这很可能伴随着复杂性的增加（首先是类根，后来是菌丝生长），因为多细胞性在链状植物中变得普遍。陆地植物和单细胞绿藻Trebouxia基因组中包含了一些推测真菌起源的古代水平基因转移的证据；与真菌共生所需的基因在绿藻中也显示出同源性。在某些情况下，这些转移的基因在功能上与适应旱地有关。虽然这意味着当绿藻开始在陆地上定居时，真菌就出现了，但这并不能说明它们是一起陆地化的。 棕色场景：出现的土地可能有微生物的群落主宰着整个景观，包括细菌，可能还有真核藻类和原生动物。在这种情况下，真菌会在这些原生质土壤中定居，迅速分裂为与链型植物（Streptophyta） 相关的一个谱系（毛霉亚门，球囊菌门（glomeromycota）和双核亚界）和一个原生动物的寄生虫相关的谱系（捕虫霉亚门）。值得注意的是，目前生活在包括土壤在内的许多环境中的有壳变形虫的微体化石可追溯到元古代。因此，可想而知的是，捕虫霉亚门（Zoopagomycotina）的某些种已经是这种变形虫的寄生虫，尽管还没有找到令人信服的化石证据来证实这一点。埃迪卡拉纪的化石被认为是代表微生物的化石，与已知的某些现代真菌群落相似。很多人声称这些化石来自地衣和黏菌，这表明陆地微生物生态系统已经很发达。 白色场景：在本篇综述中新提出的假设，涉及到冰川环境作为真菌从水环境过渡到陆地环境的促进者。由于冰川环境是由非生物因素形成的，因此可以肯定地认为它们在陆生真菌分化之前就已经存在。在这种环境中，主要的挑战似乎是液态水的限制，与水环境相比，冰环境的异质性和不稳定性要高得多，这是土壤的共同特征。冰环境中的某些微冰，如高盐盐水通道和冰晶中排除溶质而形成的冰锥，具有相当高的微生物多样性。通过对南极麦克默多山谷5个冰封湖泊的18s核糖体RNA（rRNA）序列分析，在一个以壶菌门和Rozellidea（隐菌门的一个纲）为主的群落中，共发现1313个真菌操作分类学单位（operational taxonomic units （OTUs）），还包括子囊菌纲、担子菌纲、芽枝菌类和zygomycetous。对两个南极大陆盐水中的6个重复进行分析，发现600个OTU聚集在两个明显不同的群落中，几乎没有重叠。这表明冰环境可能具有巨大的空间异质性。冰团中含有重要的雪藻群落，它们可能是陆生真菌动孢菌祖先的寄主，动孢菌可以很容易地通过半融化的冰表面繁殖，甚至现代的冰环境（如冰缘土壤或北冰洋）也包含着出乎意料的丰富多样的动孢菌谱系。 真菌陆生谱系的发生估计日期与前寒武纪冰期重叠，这一时期也被称为冰河世纪。这一时期还见证了至少两个非链藻纲陆生藻类（树藻科和沟藻门）的发生。根据上述证据，提出了真菌陆地化的以下过程：（i）冰河环境创造了微生物生态位的多样化。（ii）真菌作为藻类的游动孢子捕食者到达冰层环境。（iii）其他生物坏死物的积累有利于菌丝生长和渗透（iv）间歇条件有利于抗性休眠孢子的发育。在冰川作用的情况下，这些条件会持续更长时间。鞭毛运动丧失。（v） 真菌适应于在寒冷环境中的水限制条件下生存，然后能够在土壤环境中定居。 综上所述，真菌陆地化起源的三种假设情景集中在不同的生物或非生物因素上，这些因素可能是顺序或组合作用的。由于缺乏清晰的化石记录，支持每一种情况的证据都是间接证据，但所有这三种情况的一个共同因素是真菌的陆生化过程必须与其他真核生物群体（变形虫、藻类或植物）的陆生化过程同步。在陆地化之后，与其他生物群的关系将影响主要陆生谱系的辐射，其中捕虫霉亚门主要与其他微生物和后生动物联系在一起，而球囊菌门、毛霉门和双核亚界主要与植物有关。 IV. 真菌和其他微小的真核生物1.真菌斑狼疮（Fungus fungo lupus）:真菌中的真菌寄生症真菌能够攻击和消化几乎任何一种生命结构，包括其他真菌。在最古老的真菌化石中，已经发现了真菌寄生的联系，这种生活方式可能出现得更早，因为真菌寄生在早期分化的真菌中很普遍（图3）。最近通过使用单细胞测序技术获得了其中几种生物营养型寄生菌的基因组，鉴于它们通常是小菌体，这是必要的。这些生物中的许多都失去了重要代谢途径的基因，如生物素、多胺、同化硫酸盐或三羧酸循环。真菌可以感染植物，藻类和其他真菌的生物营养，寄生或坏死营养两种方式相互作用。坏死营养型寄生菌具有很强的攻击性，通常有广泛的宿主。其中一些似乎能够作为内生菌在植物组织中定殖（图4），在那里它们为宿主提供了一种有效的抵御真菌病原体的机制，这推动了对这种真菌生态位的大量研究。木霉具有显著的几丁质酶基因扩增，以及多种次级代谢酶。然而，实验证据表明，这些酶的功能专一性是有限的，即使在属内，营养策略也是可变的。在肉座菌目（Hypocreales）中，有基因组信息的其他重要的真菌寄生属有Olypocladium属、Clonostachys属和Escovopsis属。对这些真菌的基因组比较表明，分枝营养化是通过不同的策略独立进化而来的。但生物营养的寄生在实验上不易控制，而且它们在较窄的宿主范围内产生较轻的表型。 从进化的观点来看，支原体和无脊椎动物的病原体之间似乎存在某种关系（图4）。例如，blastoclad Catenaria、Orbiliomycetes Arthrobotrys和肉座菌目Trichoderma和Clonostachys，已被报道为支原体和线虫寄生虫。在几乎所有腐生物中，真菌寄生物种的几个重要特征必然存在：为了攻击其他真菌，它们需要几丁质降解酶，还必须保护自己不受酶降解的影响。生产有毒化合物是一种有效的、非常常见的保卫的策略，但也很容易用于进攻目的。支原体可以作为水平基因转移（HGT）的供体和促进者，通过直接向宿主供体或去除宿主细胞壁，从而获取DNA，从理论上讲，各种各样的寄生菌甚至可以从宿主那里获得基因，然后将它们捐赠给另一个宿主，从而有效地充当载体。 图3：系统发育树显示主要的生态过渡。右边的符号表示转换已在组内发生。 图4:真菌生态型之间已知的关系。每个连接箭头可以是单向的或双向的。每一条途径都说明了一个经历了这样一个转变的群体的例子 2.真菌和原生动物真菌和原虫变形虫之间的关系很大程度上是未被探索的。一些原生生物可以早于真菌菌丝和孢子，似乎是控制真菌种群的重要因素。相反的情况是，真菌以变形虫为食，变形虫真菌通常遵循两种策略：内寄生和诱捕。在内寄生虫病中，真菌通常以孢子的形式进入细胞，然后在寄主体内形成叶状体。这已经在罗兹菌属（Nucleophaga, Paramicrosporidium）和动孢子属（Cochlonemataceae）中被描述过（图1）。另一方面，捕捉变形虫的真菌产生的结构，可以像孢子一样简单，附着在变形虫上，产生一个菌丝体，穿透微生物，以其细胞质内容物为食。这种策略在捕虫霉亚门，子囊菌亚门和伞菌纲（图1和图3）中是已知的。 第一批嗜阿米巴真菌基因组于2019年初公布，全部来自于捕虫霉亚门，不过由于难以将样本与宿主分离，样本代表了宏基因组（metagenomes）。这种真菌在自然环境中的生物量非常低，即使用分子方法检测，通常也很难将序列与其生态位联系起来。大多数嗜阿米巴真菌的捕虫霉亚门具有异常长的内部转录间隔区（internal transcribed spacer（ITS）），这阻碍了它们在典型环境条形码研究中的检测。这限制了我们对关键领域真菌的理解。首先，罗兹菌与微孢子虫的关系以及后者的进化起源需要更多的罗兹菌属成员的描述，这一任务近年来由于变形虫寄生虫的研究而有所进展。 其次，所有种类的阿米巴诱捕真菌也都含有捕食线虫的物种（图4）。事实上，陆生真菌（Zoopagomycota）最早的辐射传统上与无脊椎动物寄生有关，变形虫在这些生物的祖先多样化中所起的作用应该认真考虑。 Ⅵ.真菌和动物1.Overview与植物提供的纤维素相比，几丁质更易于消化，含氮量更高这些特性使微生物真菌成为土壤无脊椎动物如节肢动物、环节动物、软体动物或线虫的重要食物来源。某些种类的白蚁、蚂蚁或甲虫，以及某些蜗牛，都可以培养真菌生物量并将其作为主要的食物来源。许多肉眼可见的子实体和地衣壳可食用，是包括人类在内的动物的重要食物来源。 许多真菌系与动物关系密切(图1和图3)。大多数研究集中在脊椎动物、昆虫或线虫的真菌寄生虫上，但至少在软体动物、环节动物、轮虫、足爪动物、扁腹动物和刺胞动物中，真菌病原体是已知的。尽管自然界存在着巨大的动物多样性，但几乎所有动物对真菌的免疫反应都非常相似，主要依赖于吞噬性免疫细胞和细胞外陷阱的产生。 2.动物专性寄生后生动物的专性真菌寄生虫具有基因组和代谢减少的特征，是高度专业化的寄生虫的典型特征。 微孢子虫是已知的许多后生动物谱系，包括几个海洋类群。微孢子虫的特点是基因组极度减少，许多重要的代谢途径丧失，以及线粒体衍生的有丝分裂体的存在。它们的姊妹类群，Rozellida，已经被证明含有寄生于变形虫的微孢子虫样细胞内生活方式的物种。基于此，微孢子虫很可能已经是后生动物单细胞祖先的寄生虫。 3.动物兼性寄生许多自由生存的真菌能够感染不同种类的动物(图1和图3)。这些寄生关系通常非常具体，与植物坏死病原体的关系类似。在寄主特异性寄生虫中，真菌可能表现出高度复杂的致病机制，包括但不限于:免疫逃避、毒素、结构成分水解酶的分泌，甚至诱导寄主行为改变的能力。与专性寄生不同，兼性病原体的致病性通常很高，而且在很大程度上与寄主的密度无关。 节肢动物是迄今为止真菌丰富的陆地环境中种类最多的动物门。由动孢菌和担子菌纲引起的节肢动物真菌病是已知的，但它们是相当罕见的（图1和图3）。昆虫的寄生真菌主要在子囊菌亚门【腔菌目(Podonectria), 多腔菌目(Myriangium), 肉座菌目】中独立进化了好几次。其中一些肉座菌目（如冬虫夏草、白僵菌、蛇床子属）具有很强的寄主特异性，有些种类能够影响寄主神经系统并改变寄主行为，以帮助传播孢子。另一方面，昆虫可以利用巨噬细胞、抗菌肽、黑色素和活性氧物种来保护自己，也可以采取某些行为，例如消除受感染的群体成员或将自己暴露在更高的温度下。综合上述情况，这种真菌在杀死昆虫后能够在昆虫身体上生长，并且很可能在环境中以活跃的菌丝体形式存在，而不依赖于宿主。值得注意的是，节肢动物寄生物必须能够利用海藻糖作为碳源，海藻糖在这些动物的组织中含量非常丰富。 微型无脊椎动物是土壤、沉积物和其他环境中生物量的重要组成部分，一些真菌已经获得了感染它们的能力（图1和图3）。线虫是微型无脊椎动物群落中研究得最好的部分，因为它们与农业生产力相关，而食线虫真菌也因其作为控制剂的潜力而被研究。线虫寄生真菌可见于捕虫霉亚门 ,粪壳菌纲, 圆盘菌纲 ,散囊菌纲 (Pezizomycotina) ,伞菌纲 (Agaricomycotina)，被孢霉纲，虫霉纲，甚至在芽枝菌门中。许多食线虫真菌的行为类似于规则的丝状腐生菌，但容易攻击卵和其他静息结构，例如某些植物寄生线虫中不活动的雌性。几种食线虫真菌的基因组分析表明它们往往产生几丁质降解酶和蛋白酶家族的基因扩展。此外，线虫捕食往往拥有一个发育良好的纤维素降解代谢，但很少有传统的植物致病相关基因，这表明其具有腐殖质祖先（图4）。这些适应与在昆虫病原真菌和寄生真菌中发现的非常相似，而且这些不同生活方式之间的相互转换似乎在肉座菌目（Pezizomycotina）中很常见。许多食线虫真菌是已知的植物内生菌或木材分解者（图4）。在这些寄生性的生活方式中，无花果是一种很常见的寄生性和寄生性的寄生性真菌（寄生性真菌和寄生性真菌之间的共生关系）。 脊椎动物与其他动物群体相比有几个重要的特点。首先，脊椎动物体型大，身体微绒毛相当多样。其次，它们缺乏几丁质结构。第三，它们都拥有一个完善的基于抗体的免疫系统，这对试图在它们内部生长的任何微生物都构成了严重的挑战。脊椎动物（鸟类和哺乳动物）的一部分是温血生物，其内部温度对微生物构成了另一个重要的屏障。 但只要引发真菌感染，就会造成严重的疾病，三个具体的例子说明了这一点：两个壶菌种（Batrachochytrium endrobatidis和B. salamandrivoransare）会对两栖动物造成致命的皮肤损伤，并威胁到全球人口。第二个是假裸囊菌属（Pseudogymnoascus destructans），它在北美造成了大量蝙蝠死亡。这种高毒力菌株来自欧洲，那里的本地蝙蝠种群对它有抵抗力。腐皮镰刀菌（Fusarium solani）是一种对海龟造成极大伤害的真菌，因为它在这些爬行动物的卵上定居和破坏。这是一个特别有趣的案例，因为镰刀菌是一个传统的植物致病属（图4）。 人类的真菌感染是引起重大公共卫生关注的一个原因。最常见的真菌感染是皮肤病，很少危及生命，但影响外貌，并且较难治愈。大多数引起皮肤感染的真菌是黑色真菌（腔菌目和刺盾炱目）这些真菌已经进化到在高度疏水性和辐照环境下定居，这可以类似地代表沙漠岩石或人的指甲。与这些无关但也会引起皮肤感染的是马色拉菌（黑粉菌亚门）的成员。除此之外，散囊菌目的一些成员已经获得了在皮肤和其他身体环境中生长的能力，特别是在肺部，这是一种与黑真菌有关的生物，专门降解角质化组织。主要病原菌有组织胞浆菌属、芽生菌属和球孢子菌属。这些属真菌的黑色素化程度很高，这使得它们能够在高氧化条件下生存。第二类最常见的人类病原体是酵母菌属，特别是假丝酵母属和Nakaseomyces的酵母菌，它们既能引起粘膜表面感染，又能引起系统性血流感染，死亡率高。最后，其他丝状真菌（曲霉属、青霉属、拟青霉属、顶孢霉属、镰刀菌属、木霉属、孢子丝菌属、假丝酵母属）、假丝酵母属（红酵母属）、粘霉属（根霉属、地衣菌属、毛霉属）和虫霉属（担子菌属）中的其他丝状真菌，分生孢子虫）在软体组织中产生高度侵袭性感染。这些真菌通常是空气和土壤传播的腐生物，能够快速生长，不会受到高温的过度抑制（图4）。这些疾病的病程变化很大。有些会产生结节，可能导致器官损伤，或者至少严重毁容。另一些则发展为慢性感染，对器官造成持续损害。肺曲霉菌病是这些疾病中最常见的，引起广泛的呼吸系统问题。最后，有些真菌毒性很强，通过软组织迅速生长，这可能导致严重的致残和器官损伤。人们一直致力于研究机会性病原体是如何产生的。虽然其机制是高度可变的，但通常病原体在某些战略蛋白家族中表现出基因扩增（如细胞粘附、蛋白酶、脂酶、活性氧清除）。许多人类真菌病原菌具有高度杂合子甚至不稳定的基因组，具有常见的非整倍体、多倍体和杂交事件。完全有可能这些事件在其他真菌中也很常见。然而，非整倍体与获得抗真菌耐药性有关，杂交与某些物种复合体中新的毒性菌株的出现有关。 4.动物-真菌的共生酵母菌中的酵母菌是昆虫和脊椎动物黏液中肠道菌群的常见成分。甚至有人认为昆虫的肠道可能是酵母菌属（图4）和一些属的进化的重要环境，例如最近描述的Suhomyces(syn. Saccharomyces tanzawaensis)似乎优先发现在这样的生态位昆虫以树液或水果为食，其饮食中含有极为丰富的单糖。共生真菌（木素菌）的成员被描述为与几种甲虫有关，它们似乎帮助宿主解毒植物有毒化合物。除此之外，有些物种是健康脊椎动物粘液的常见成员。由于白色念珠菌与人类病原体的相关性，它已被广泛研究。除此之外，担子菌中的其他酵母样形式是哺乳动物皮肤和粘膜的重要共生体。 真菌脊椎动物共生体的一个重要而常被忽视的群落是心丽鞭毛菌门的成员。事实上，还没有研究解决这些奇异真菌如何与宿主免疫系统相互作用的问题。作为真菌最早的分化谱系之一，它们的分化一定比它们现在的脊椎动物宿主的出现要早得多。第一种可能性是，这些真菌最近通过与脊椎动物宿主的联系，形成了自己特有的生活方式。第二种可能是这些真菌是与其他可能已经灭绝的谱系联合进化而来的。第三种可能是这个谱系的成员可能生活在尚未开发的环境中，从那里他们可以进入脊椎动物宿主并建立起重要的共生体。 Ⅵ :真菌-植物生物群落：植物与真菌的相互作用1.overview真菌和陆地植物在生物圈中有着持续时间最长、最亲密的关系。真菌界是造成植物病害的主要原因，也是植物坏死物质的主要分解者。另一方面，植物有无数的真菌以共生体和/或共生体的形式与其组织紧密结合。菌根是一种共生真菌，与植物的根相联系，帮助植物获得养分和水分。大约90%的植物物种存在内菌根联合体。此外，内生真菌是真菌共生体，生活在植物组织内，不会对植物造成伤害。内生真菌并没有像菌根那样受到关注，因此对其丰度、相关性和多样性的精确估计仍然缺乏。这些真菌的存在似乎通过刺激植物的防御和作为生态位竞争对手来保护植物免受致病真菌的侵害。其中一些真菌是其他有机体的寄生虫，如其他真菌、昆虫或线虫，产生次级代谢物，帮助植物对抗食草动物，或促进植物生长。研究更少的是生活在植物表面的真菌（附生植物），形成所谓的叶面群落。这些群落具有高度多样性，与内生菌一样，可以影响寄主植物的生理学。它们代表着一个尚未开发的生物多样性池，在保护工作中经常被忽视。 2. 菌根和共生植物菌根组合出现在球囊菌门、毛霉门（内生殖腺）、伞菌纲和几种子囊菌纲中。其中，最重要的类群是球囊菌门，其中几乎所有的物种都形成丛枝菌根。化石证据表明，在4亿年前的Rhynie Chert化石中存在菌根联合体，这意味着真菌的相互作用对植物的陆地化至关重要。 Geosiphon和Densospora是目前解决菌根进化难题的关键。 有可能是由与蓝藻或陆生植物祖先的类似地衣管属进化而来的。然而，Geosiphon被放置在一组分解良好的菌根形成菌群中，这使得这种关联很可能是二次进化的。另一方面，如果Densopora是毛霉科的一员，也许是内囊门目的一员，它可能会对毛霉科菌根的进化提供更深入的了解，并可能暗示整个门的菌根起源。一些研究指出，球囊菌门和第一批陆地植物之间存在关联。优良的内生菌与传统上被认为是丛枝菌根真菌的一种，在形态上形成了一种独特的组合。 除了内囊门目外，外生菌根真菌似乎是最近才独立地在几个类群中产生的，只有一小部分植物形成这种菌根组合，大多数是树木，这意味着外生菌根在森林环境中具有重要作用。与有限的植物种类形成鲜明对比的是，外生菌根真菌表现出高度的多样性。这种多样性得到了很好的描述，因为大多数真菌产生宏观的子实体。最后，兰科植物是一个高度多样化的分支，它与真菌的多样性形成高度特异的菌根组合。与球囊菌门和内囊门目不同，这些真菌对其植物寄主的依赖性相对较低。 Ⅶ.地衣真菌 共生是两个或两个以上有机体之间互利的结合。地衣是由真菌起源的组织形成的宏观结构，即真菌生物，它包裹着一种光营养的蓝藻或绿藻，即光生物。它们可以在所有陆地生物群落中找到，并且在对其他光合生命体不利的环境中特别丰富和多样，例如高海拔山脉、冻土带和沙漠。这种真菌对光照和干燥有很强的抵抗力，不需要底物，能够从光生物中获得碳，有时是氮，为其提供了一个保护环境。地球约6.8%的陆地表面被地衣覆盖，地衣在全球生物地球化学中扮演着重要角色。 地衣主要在子囊菌亚门（图3），占总数的近一半（约20000种）。 地衣在六个类群中都有代表性，其中茶渍纲和星裂菌纲两个种类是最丰富的地衣形成分支。地衣含有多种多样的微生物，包括其他真菌。有人提出，内生生活方式可能代表腐生和内生之间的中间步骤。其中一些相关的微生物是寄生虫，包括寄生在叶状体上并慢慢取代叶状体的地衣物种。内生真菌可能对整个叶状体产生表型效应。 地衣化石的记录非常古老，至少可以追溯到泥盆纪，尽管一些Ediacaran化石和类似地衣的化石可能是最早的陆生真菌之一。Winfrenatia reticulata 是泥盆纪早期的化石，被认为是zygomycetous地衣。现代地衣主要的谱系至少早在石炭纪就多样化了。目前还不清楚地衣生活方式在子囊菌纲中出现了多少次。一些早期的研究提出了一个单一的事件，然后是多个独立的转变为腐殖质的习性。多重起源是目前最受欢迎的观点，尽管对于转变的数量还没有达成共识支持这一点的是，有些物种既可以被发现为地衣，也可以是自由生活的腐生物，这意味着生活方式之间的转变是可能的。考虑到地衣真菌与光生生物和其他微生物的紧密联系，地衣真菌是接收外源基因的主要候选物种，并且有证据表明地衣特有的几种次级代谢物已从细菌水平转移。地衣也可以将基因捐赠给它们的光生生物。 在基因组研究方面，地衣真菌的一些特性意味着它们落后于其他真菌。地衣是复合生物，需要单独培养或使用类宏基因组方法。独立培养限制了对共生体本身的研究，在实验室条件下维持真菌活性存在一系列挑战。宏基因组学的方法在实验和计算上都要复杂得多，并且可能导致碎片化的装配和污染问题。基因组测序和比较分析揭示了一些可能与共生相关的特征。它的基因组只有一个很小的分泌体，糖转运蛋白的数量也减少了，但是在编码氮和镁转运蛋白、细胞信号传导途径和防止干燥的蛋白质的基因家族中却经历了扩张。增强氮转运在地衣化过程中似乎很重要，至少在光生伴侣不能固氮的真菌中是如此，基因复制和HGT似乎都在这种基因扩展中发挥作用。尽管目前还没有发表比较研究报告，但几种地衣形成真菌的基因组已具备不同程度的完整性和质量。 Ⅷ.结论 (1)最早的真菌是其他单细胞真核生物的动孢菌。如今，这种生活方式可以在后孢菌、壶菌门和芽枝菌门中找到。 (2)有两种主要假设可以解释真菌的陆生化过程。棕色场景假设真菌在沉积物中进化出腐殖质习性，它们在土壤中繁衍。绿色情景假设真菌的陆生化与绿藻和链霉菌的陆生化密切相关。在这里，提出了第三个白色的场景，真菌在适应冰冻环境后殖民了陆地环境。 (3)真菌和其他微生物真核生物之间关系的进化意义一直被忽视。在陆地化的早期阶段，真菌一定与其他真菌和原生动物有过相互作用。这些生物体的寄生可能是动物寄生进化的第一步。 (4) 几种真菌已经获得了一种必须的寄生生活方式，并表现出许多寄生虫常见的典型特征。真菌是脊椎动物和无脊椎动物的重要寄生物，尽管这两类动物之间的机制差异很大。无脊椎动物寄生物与支原体和嗜线虫菌有关，利用其几丁质降解能力攻击宿主。脊椎动物寄生必须能够克服宿主的免疫反应。这些谱系的发病机制似乎来自共生，通常是兼性病原体。 (5)真菌和植物之间的关系非常古老，Glomeromycota化石是陆地真菌生活的第一个直接证据。Endophytism是一种未被充分探索的真菌生态位，拥有令人印象深刻的生物多样性。寄生在植物中主要有两种策略:生物饲养和坏死饲养。这些策略带来了完全不同的进化压力，这反映在它们的基因组特征上。最后，值得一提的是伞菌纲中有一组，他们发展了独特的酶降解木质素的能力。这种能力的获得与它们形成高度复杂子实体的能力有关，赋予它们巨大的进化和生态成功。 (6)与其他真菌相比，地衣在基因组研究方面一直落后于其他真菌。地衣的生活方式可能是陆生过程中的关键，在子囊菌中被认为是非常古老的，许多腐殖质谱系是派生的状态。 转载请注明周小钊的博客&gt;&gt;文献阅读：真菌进化","tags":"literature_reading"},{"title":"利用orthofinder寻找单拷贝基因构建系统发育树","url":"/2020/07/18/2020-07-18-orthofinder/","text":"1.orthofinder介绍 OrthoFinder是一种快速、准确和全面的比较基因组学分析工具。它可以找到直系和正群，为所有的正群推断基因树，并为所分析的物种推断一个有根的物种树。OrthoFinder还为比较基因组分析提供全面的统计数据。OrthoFinder使用简单，只需运行一组FASTA格式的蛋白质序列文件（每个物种一个）。 2.基础知识介绍Orthologue（直系同源基因）指的是来自两个物种的基因。Orthologue是由两个物种的最后共同祖先(LCA)上的单个基因进化而来的成对基因(图1A和B)。正群是同源概念在物种群中的自然延伸。一个Orthogroup（正交群）是由一个物种的LCA中的单个基因进化而来的一组基因(图1A)。当观察基因树时，一个邻位群体中基因的第一次分化是一个物种形成事件，对同源基因来说也是如此。 作为基因复制事件的结果，当观察直系同源基因和正交群时，可能会有来自同一物种的多个基因。在这个例子中(图1A和B)，人类和老鼠的HuA基因是鸡中ChA1和ChA2的同源基因。再看一下正交群，我们发现有两个鸡的基因(图1A)，但是只有一个来自老鼠和人类的基因。一些作者将ChA1和ChA2基因作为HuA的共同源基因，以强调存在多个同源基因的事实。由于基因重复和丢失在进化中经常发生，一对一的直系同源物很少见，通过分析正交群所有直系同源的情况（一对一，多对一，多对多），我们可以分析数据的所有情况。 paralogues (旁系同源基因)是指在基因复制事件中从单个基因中分离出来的成对基因，鸡的两个基因ChA1和ChA2是旁系同源基因(图1C)。来自不同物种的两个基因如果在基因重复事件中彼此分离，也可能是同源的。由于基因树中所有的分支事件要么是物种形成事件(产生直系同源基因)，要么是重复事件(产生旁系同源基因)，因此同一正交群中任何不是直系同源基因的基因必然是旁系同源基因。 图1 直系同源物是同源性基因，是物种形成事件的结果。Paralogs（旁系同源物)是同源基因，是重复事件的结果。可以看到(图2)，不同物种间的α-chain gene互为Orthologs(直系同源物)。正交群用来形容自一组物种的LCA中的单个基因的基因组（α-chain gene）。然后同一物种间α 和β chain gene互为Paralogs(旁系同源物)。最后所有这些关系都可以由OrthoFinder来识别。 图2 ## 3.安装 在这里推荐大家使用conda来安装，简单明了，不用担心其他Dependencies的安装 1$conda install orthofinder 4.运行orthofinder运行Orthofinder，相当简单的操作, “-f”输入目录，里面包含你需要运行的蛋白质fasta文件，“-t”所用到的CPU数目，“-S”选择的比对模式（默认diamod，可选blast）。 我使用的物种有九个：大豆（G.max）、菠萝（A.comosus）、柑橘（C.sinensis）、无油樟（A.trichopoda）、拟南芥（A.thaliana）、黄瓜（C.sativus）、水稻（O.sativa）、小立碗藓（P.patens）、江南卷柏（S.moellendorffii） 将所有物种的蛋白文件放到Angiospermae文件夹下 1$nohup orthofinder -t 16 -f Angiospermae/ -S blast &amp; 生成的结果会存储于Orthofinder/Results_XXX文件中，现在简单看看里面有啥。 1234567Citation.txt OrthologuesComparative_Genomics_Statistics Phylogenetically_Misplaced_GenesGene_Duplication_Events Putative_XenologsGene_Trees Resolved_Gene_TreesLog.txt Single_Copy_Orthologue_SequencesOrthogroups Species_TreeOrthogroup_Sequences WorkingDirectory 我们主要使用Orthoogroups查看正交群的基因和使用 Single_Copy_Orthologue_Sequences里的单拷贝基因构建系统发育树 WorkingDirectory其中包含运算过程的中间文件，例如blast结果，如果我们想去掉某一物种，在SpeciesIDs.txt中将该物种注释掉 1234567891011$vi SpeciesIDs.txt#0: Acomosus.pro.fa1: Athaliana.pro.fa2: Atrichopoda.pro.fa3: Csativus.pro.fa4: Csinensis.pro.fa5: Gmax.pro.fa6: Osativa.pro.fa7: Ppatens.pro.fa8: Smoellendorffii.pro.fa~ 1$nohup orthofinder -b WorkingDirectory 如果我们想增加额外的物种进行分析，可以按照如下方式运行 1$nohup orthofinder -b WorkingDirectory -f new_fasta_directory 5.利用单拷贝基因构建系统发育树Orthofinder的 Single_Copy_Orthologue_Sequences下存放着单拷贝同源基因的序列，我们可以利用这些序列构建系统发育树 5.1.多序列比对多序列比对推荐使用muscle 1234$wget http://www.drive5.com/muscle/downloads3.8.31/muscle3.8.31_i86linux64.tar.gz$tar xzvf muscle3.8.31_i86linux64.tar.gz$chmod +x muscle将muscle添加至环境变量 单拷贝的序列较多，所以使用shell批量运行 1234567$vi bash.shfor i in *.fado muscle -in $i -out $i.1done$sh bash.sh 5.2.提取保守序列.1文件是比对好的序列文件，接下来使用Gblocks提取保守序列 12345678$wget http://molevol.cmima.csic.es/castresana/Gblocks/Gblocks_Linux64_0.91b.tar.Z$tar Zxf Gblocks_Linux64_0.91b.tar.Z添加至环境变量$vi bash2.shfor i in *.1do Gblocks $i -b4=5 -b5=h -t=p -e=.2done$sh bash2.sh -t= default:p设置序列的类型，可选的值是 p,d,c 分别代表 protein， DNA， Codons 。-b1= default:（ 序列条数的 50% + 1 ）,设定保守性位点必须有 &gt;= 该值的序列数。该参数后接一个 integer 数，默认下比序列条数的 50% 大 1.-b2= default: 序列条数的 85%,确定保守位点的侧翼位点时，其位点必须有 &gt;= 该值的序列数。该值必须要比 -b1 的值要大。-b3= default: 8,最大连续非保守位点的长度。-b4= default: 10,保守位点区块的最小长度。该值必须 &gt;=2 。-b5= default: n, 设置允许含有 Gap 位点。可选的值有 n,h,a 分别代表 None, With Half, All 。 当为 h 时，表示-e= default: .2, 设置输出结果的后缀。 5.3.序列合并比对好之后我们需要将所有文件合并，在合并之前，需要对每个序列文件进行排序，并将多行序列转换为一行序列，此时用到的工具是seqkit 123456789101112$conda install seqkit$vi bash3.shfor i in *.2do seqkit sort $i &gt;$i.3seqkit seq $i.3 -w 0 &gt; $i.3.4done$sh bash3.sh$mkdir new$mv *.4 new/$cd new$paste -d &quot; &quot; *.4 &gt; all.fa$sed -i &quot;s\\ \\\\g&quot; all.fa 此时我们已经把所有的单拷贝序列合并，接下来使用notepad++把所有的ID更改 5.4.选择合适的替代模型修改结束后选择合适的氨基酸替代模型准备构建系统发育树，在这里我使用prottest预测合适的模型，prottest使用phy格式文件，所以用python脚本先将fa文件转换为phy文件， 12345678import rewith open(&#x27;all.fa&#x27;, &#x27;r&#x27;) as fin: sequences = [(m.group(1), &#x27;&#x27;.join(m.group(2).split())) for m in re.finditer(r&#x27;(?m)^&gt;([^ \\n]+)[^\\n]*([^&gt;]*)&#x27;, fin.read())]with open(&#x27;all.phy&#x27;, &#x27;w&#x27;) as fout: fout.write(&#x27;%d %d\\n&#x27; % (len(sequences), len(sequences[0][1]))) for item in sequences: fout.write(&#x27;%-20s %s\\n&#x27; % item) 从[]官网上](https://www.softpedia.com/dyn-postdownload.php/cc45406e35260b47bfa4132e67f8c446/5f13ff63/286c7/4/1)下载prottest 12$ tar zxf prottest-3.4-20140123.tar.gz$java -jar /opt/biosoft/prottest-3.4-20140123/prottest-3.4.jar -i all.phy -all-distributions -F -AIC -BIC -tc 0.5 -threads 24 -o prottest.out 在prottest.out中可以看到最佳模型 5.5.构建系统发育树使用raxml构建系统发育树 12345678$wget https://github.com/stamatak/standard-RAxML/archive/master.zip$unzip master.zip$cd standard-RAxML$make -f Makefile.SSE3.gcc$make -f Makefile.SSE3.PTHREADS.gcc$make -f Makefile.SSE3.MPI.gcc$make -f Makefile.SSE3.HYBRID.gcc添加至环境变量 选择JTT+I+G+F模型构建发育树，外群选择江南卷柏和小立碗藓 12$nohup raxmlHPC-PTHREADS-SSE3 -T 16 -f a -x 123 -p 123 -N 1000 -m PROTGAMMAJTT -k -O -o Smoellendorffii,Ppatens / -n all.tre -s all.fa &amp; 运行结束后使用figtree打开RAxML_bipartitions.all.tre，对进化树进行修改。 至此，利用单拷贝基因构建系统进化已经完成 参考链接https://www.jianshu.com/p/16e0bbb2ba19 http://www.chenlianfu.com/?p=2217 https://github.com/stamatak/standard-RAxML https://github.com/davidemms/OrthoFinder 转载请注明周小钊的博客&gt;&gt;利用orthofinder寻找单拷贝基因构建系统发育树","tags":"bioinformatics comparative_genomics"},{"title":"利用github和jekyll构建个人博客","url":"/2020/07/09/2020-07-09-github+jekyll/","text":"我们知道，一个网站要能够在任何地方都能够被访问，那么需要部署到服务器上，但是对于我们来说，构建服务器的花销是巨大的。幸运的是，github就提供了这样的功能，只要按照github格式要求，新建一个仓库，把你的网站代码上传到里面，你就有一个自己的免费网站了。 废话不多说，让我们利用jekyll和github来构建自己的博客吧！！ 一：软件下载jekyll支持mac、linux、windows等，鉴于大部分童鞋使用的是windows系统，那我就用windows构建 1.下载安装ruby installerhttps://rubyinstaller.org/ ，点击相应的版本进入下载页面即可下载 2.下载rubygemshttps://rubygems.org/pages/download ，可以选择相应版本下载 下载完成后解压到你想放的位置，比如我放在了“D:/soft/rubygems3-1.4”下,打开cmd用命令执行 1234D:cd soft/rubygems3-1.4ruby setup.rbgem install jekyll 二：网站构建软件下载有点耗时，在此期间我们可以挑选一个自己喜欢的主题来构建自己的博客 首先你要到GitHub上注册一个账号,例如jungleblack007（用户名可以在设置里改），创建完成后可以去jekyll主题网站选择自己喜欢的主题，然后在这个主题基础上修改到满足自己需求的博客. 我选择的是潘柏信的博客主题，因为这个主题有中文说明，而且有个B站up主对该主题进行了详细的操作，适合我们入门，先让我们看一下该博客的外貌！ 我们找到作者的源代码块,点击右上角的fork可以将它拷到我们自己的github中，顺便star一下支持作者 拷到自己的github后，我们点击setting，先进行改名，推荐：你的用户名.github.io 然后下拉找到GitHub Pages，source选择master branch，我已经点了所以看不到，然后上方出现一个网址，这个就是你的域名了，可以先看看和原博客有没有区别 三：运行jekyll生成静态网页把别人的主题fork以后，我们可以利用atom把主题代码转到自己的电脑上 打开atom，按ctrl+shift+p，输入github clone，选择要克隆的网址和要保存的路径。点clone即可 clone完成后，就会有如下界面 修改_config.xml,把一些信息修改为自己的 图像也可以换，根据img的文件夹的图片名称可以换成你想要的，名字要一致，img/posts主要放置的是笔记中的图片，可以删掉，以后写笔记的时候想插入图片需要把图片路径设置成img/posts/XXXX。赞赏功能的图片在paying里，需要赞赏就改成自己的二维码，不需要赞赏就删掉new-old.html里的所有内容 此时，我们可以用jekyll来生成一个静态网页查看 1234Dcd data/gitbundler installbundle exec jekyll serve http://127.0.0.1:4000 这是我们生成的一个静态页面，浏览器输入即可查看 可以看到背景和个人信息都已经改为了自己的，说明修改成功！ 四，写一篇自己的博客jekyll比较好的一点是可以识别笔记文件，我们可以把写好的文件放到_post文件夹下，然后在md文件前面加一串代码。 写好后可以再运行bundle exec jekyll serve查看自己写的博客是否已经能在静态网页上查看 五：添加网站统计功能我们可以给自己的网站添加统计功能，在这个主题中也支持该功能，推荐使用百度统计，首先注册账号 注册结束后添加新的域名统计 添加结束后点击管理—代码获取，会看到一串代码， 12345678910&lt;script&gt;var _hmt = _hmt || [];(function() &#123; var hm = document.createElement(&quot;script&quot;); hm.src = &quot;https://hm.baidu.com/hm.js?60e2d4433f4c77b3ae5db5cac1b62829&quot;; var s = document.getElementsByTagName(&quot;script&quot;)[0]; s.parentNode.insertBefore(hm, s);&#125;)();&lt;/script&gt; ?后面的60e2d4433f4c77b3ae5db5cac1b62829可以粘贴替换掉_config.yml文件中的百度统计 这样统计功能就添加上了 六：添加评论功能评论功能也可以根据自己的喜好添加，我添加评论功能使用的是来必力 注册账号后添加网页，与百度统计类似，添加结束后点击管理界面-代码管理，可以看到一串代码 123456789101112131415161718&lt;!-- 来必力City版安装代码 --&gt;&lt;div id=&quot;lv-container&quot; data-id=&quot;city&quot; data-uid=&quot;MTAyMC81MDkzOC8yNzQyMA==&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt; (function(d, s) &#123; var j, e = d.getElementsByTagName(s)[0]; if (typeof LivereTower === &#x27;function&#x27;) &#123; return; &#125; j = d.createElement(s); j.src = &#x27;https://cdn-city.livere.com/js/embed.dist.js&#x27;; j.async = true; e.parentNode.insertBefore(j, e); &#125;)(document, &#x27;script&#x27;);&lt;/script&gt;&lt;noscript&gt;为正常使用来必力评论功能请激活JavaScript&lt;/noscript&gt;&lt;/div&gt;&lt;!-- City版安装代码已完成 --&gt; 将该代码复制，替换掉_include/comments.html中的全部内容即可（这里的bioinformatics-rookie.github.io是我自己的博客，文中出现的jungleblack007.github.io是我用来做试验的账号） 七：上传到github所有内容修改完成后可以将自己的代码上传到github，atom也提供此功能。 当你所有的内容修改完毕后，atom右侧unstaged changes会显示你修改了什么内容,点击stage all,所有的会移动到下方的staged changes. 在 commit message中随便写点东西点击下方按钮，在push出会出现一个待上传的指令 ctrl+左键点击push，使用force push功能可以将自己修改过的内容传到github服务器上，这样输入你的github域名就可以打开自己的网页了，后续的更改同样采取此操作。 参考链接https://github.com/leopardpan/leopardpan.github.io https://www.jianshu.com/p/9f71e260925d https://www.bilibili.com/video/BV14x411t7ZU?t=537 转载请注明转载请注明：周小钊的博客- 利用github和jekyll构建个人博客","tags":"blog"},{"title":"RepeatModeler+RepeatMasker的安装与使用","url":"/2020/07/08/2020-07-08-repeat/","text":"在基因组注释中第一步就是重复序列的屏蔽，目前常用的从头注释pipeline就是RepeatModeler + RepeatMasker。 一：RepeatMasker安装1.TRFtrf下载地址：[https://tandem.bu.edu/trf/trf409.linux64.download.html] mv trf409.linux64 trf chmod a+x trf。 2.RMblast推荐使用2.9.0版本 使用conda安装 1conda install RMblast=2.9.0 3.RepeatMasker1234wget -c http://www.repeatmasker.org/RepeatMasker-4.1.0.tar.gztar xzvf RepeatMasker-4.1.0.tar.gzchmod 755 *./configure “./configure”执行后，根据提示信息进行 1.perl环境，系统会默认自动检测 2.TRF，默认自动检测，不过我没有使用conda安装也没有加入环境变量需要自己输入 3.序列搜索引擎，在这里使用的是RMblast，默认检测 最后配置环境变量 123vi ~/.bashrc输入 export PATH=&quot;/datadisk02/soft/RepeatMaker:$PATH&quot;source ~/.bashrc 二：RepeatModeler安装1.RepeatMasker、TRF、RMblast（已安装，不再赘述）2. RECON1wget -c http://eddylab.org/software/recon/RECON1.05.tar.gz 也可以使用conda安装 3.RepeatScout1wget -c http://www.repeatmasker.org/RepeatScout-1.0.6.tar.gz 4.可选软件，运行LTR结构搜索必须软件，也可以不安装LtrHarvestLtrHarvest程序是GenomeTools套件的一部分。安装genometools即可，但安装时老报错，还好有万能的conda 1conda install genometools-genometools Ltr_retriever123https://github.com/oushujun/LTR_retriever/archive/master.zipunzip LTR_retriever-master添加至环境变量 MAFFT123456wget http://mafft.cbrc.jp/alignment/software/mafft-7.158-without-extensions-src.tgzperl -p -i -e &#x27;s#PREFIX =.*#PREFIX = /opt/biosoft/mafft#&#x27; Makefileperl -p -i -e &#x27;s#BINDIR =.*#BINDIR = /opt/biosoft/mafft/bin/#&#x27; Makefilemakemake install添加环境变量 CD-HIT1234wget https://github.com/weizhongli/cdhit/archive/master.zipunzip cdhit-master.zip &amp;&amp; cd cdhit-master/sudo make添加至环境变量 Ninja12wget https://github.com/TravisWheelerLab/NINJA/archive/master.zip解压后安装 Ninja安装非常让人头疼 123sudo makeg++-7 命令未找到 查看Makefile后发现该问题 该软件需要c++11(4.8.1)以上的编译器，首先查看自己的gcc以及g++版本,4.8.1版本以上 12sudo gcc -vsudo g++ -v g++-7这个命令是没有的，我们需要在Makefile里找到g++-7并把它改为g++，然后make 安装结束后打开NINJA文件夹 看到有Ninja出现 12./Ninja缺失 libstdc++.so.6: version’GLIBCXX_3.4.20’ 又tm报错，都快要崩溃了，去网上搜解决方案呗，后来发现是 libstdc++.so.6的版本过低造成的，自己服务器上的libstdc++.so.6是一个软链接，它链接到了实际的动态库文件：libstdc++.so.6.0.19；由于该问题已解决，我的软连接改为了libstdc++.so.6.0.24 1234sudo cp /usr/local/lib64/libstdc++.so.6.0.24 /usr/lib64cd /usr/lib64sudo rm libstdc++.so.6ln libstdc++.so.6.0.20 libstdc++.so.6 这时候回到NINJA下运行成功，添加到环境变量 5.RepeatModeler安装如果前几步都添加了环境变量，软件会自动检测,只需要敲回车即可 12cd RepeatModelerperl ./configure 终于成功，开心 三：重复序列的屏蔽无library直接使用RepeatMasker中的RepBase数据库来计算重复序列，若RepBase数据库对目标物种的覆盖不好，则很可能只找到较少的重复序列。此时，使用RepeatModeler构建library就很有必要。 无library的构建方法在RepeatMasker官网上有个流程，http://www.repeatmasker.org/RepeatModeler/，根据example run的来就行 1.构建数据库1BuildDatabase -name hud Lichenomphalia_hudsoniana_LH.genome.fasta 2.构建library1nohup RepeatModeler -pa 10 -database hud -LTRStruct &gt;&amp; run.out &amp; 运行成功完成后，将生成两个文件，还有一个文件夹 12hud-families.fahud-families.stk 让我们看一下这两个文件都是啥 1less hud-families.fa 这是一个fa文件，在id上会注明这个序列是什么结构，比如这条序列就是LTR,再看一下所有的ID 1grep &quot;&gt;&quot; hud-families.fa 可以发现在repeatmodeler运行完就已经把基因组的所有序列进行了标识 1less hud-families.stk 这个文件看的我有点懵，没见过的格式啊，后来去官网查了一下这是Dfam兼容的Stockholm格式，可以通过将数据提交到&#104;&#101;&#108;&#112;&#64;&#x64;&#x66;&#x61;&#109;&#46;&#111;&#114;&#103;上传到Dfam数据库。 不过咱们也别纠结这个问题，下一步用到的只有xxx-families.fa 3.运行RepeatMasker1nohup RepeatMasker -e rmblast -lib hud-families.fa -pa 16 Lichenomphalia_hudsoniana_LH.genome.fasta &amp; 运行速度很快，结果生成三个文件 123Lichenomphalia_hudsoniana_LH.genome.fasta.maskedLichenomphalia_hudsoniana_LH.genome.fasta.outLichenomphalia_hudsoniana_LH.genome.fasta.tbl Lichenomphalia_hudsoniana_LH.genome.fasta.out：这个文件主要记录了基因组重复的位置信息以及类型 Lichenomphalia_hudsoniana_LH.genome.fasta.tbl，对各个重复进行了归类并汇总基因组重复信息， 逆转录因子 ：SINEs，短散在重复序列。 LINEs，长散在重复序列。LTR，长末端重复序列。 DNA转座子 Lichenomphalia_hudsoniana_LH.genome.fasta.masked：这个就我们要的最终文件，把重复序列替换为N的基因组序列文件，利用这文件就可以进行下一步注释了 参考链接https://blog.csdn.net/libaineu2004/article/details/77100132?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase http://www.repeatmasker.org/ https://www.jianshu.com/p/50ce4bcd1972 各个软件的链接都在http://www.repeatmasker.org/，我就不整理在这了 转载请注明：周小钊的博客» RepeatModeler+RepeatMasker的安装与使用","tags":"bioinformatics gene_annotion"},{"title":"about","url":"/about/index.html","text":"Hello,我是周小钊，目前在昆明植物研究所学习，一位快要秃头的研究生，生信小菜鸟,主要分享一些自己的学习过程，预防遗忘，也欢迎大家一起来学习交流。闲暇喜欢看动漫，制作面食(作为一个北方人感觉昆明的馒头太软，不如自己做)，目前博客和简书是我的主战场，大家可以在这两个地方找到我。 联系方式邮箱：&#122;&#x68;&#x6f;&#117;&#x73;&#x68;&#105;&#122;&#x68;&#97;&#111;&#x40;&#109;&#x61;&#x69;&#108;&#x2e;&#x6b;&#x69;&#x62;&#46;&#x61;&#99;&#x2e;&#99;&#x6e; QQ：443001574 微信：keyancaijizhousz 地址：昆明市盘龙区蓝黑路132号中国科学院昆明植物研究所 如果有生信或者搭建博客技术的问题可以一起讨论.","tags":""},{"title":"search","url":"/search/index.html","text":"","tags":""},{"title":"tags","url":"/tags/index.html","text":"","tags":""},{"title":"categories","url":"/categories/index.html","text":"","tags":""}]}